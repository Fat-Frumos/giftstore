Message-Layer Security 	In message-layer security, security information is contained within the SOAP message and/or SOAP message attachment, which allows security information to travel along with the message or attachment. For example, a portion of the message may be signed by a sender and encrypted for a particular receiver. When sent from the initial sender, the message may pass through intermediate nodes before reaching its intended receiver. In this scenario, the encrypted portions continue to be opaque to any intermediate nodes and can be decrypted only by the intended receiver. Message-layer security is also sometimes referred to as end-to-end security.
Transport-layer security 	is provided by the transport mechanisms used to transmit information over the wire between clients and providers; thus, transport-layer security relies on secure HTTP transport (HTTPS) using Secure Sockets Layer (SSL). Transport security is a point-to-point security mechanism that can be used for authentication, message integrity, and confidentiality. When running over an SSL-protected session, the server and client can authenticate each other and negotiate an encryption algorithm and cryptographic keys before the application protocol transmits or receives its first byte of data. Security is active from the time the data leaves the client until it arrives at its destination, or vice versa, even across intermediaries. The problem is that the data is not protected once it gets to the destination. One solution is to encrypt the message before sending.
Application-Layer Security 	component containers are responsible for providing application-layer security, security services for a specific application type tailored to the needs of the application. At the application layer, application firewalls can be used to enhance application protection by protecting the communication stream and all associated application resources from attacks. Java EE security is easy to implement and configure and can offer fine-grained access control to application functions and data. However, as is inherent to security applied at the application layer, security properties are not transferable to applications running in other environments and protect data only while it is residing in the application environment. In the context of a traditional enterprise application, this is not necessarily a problem, but when applied to a web services application, in which data often travels across several intermediaries, you would need to use the Java EE security mechanisms along with transport-layer security and message-layer security for a complete security solution.
Java Authentication Service Provider Interface for Containers (JASPIC) 	specification defines a service provider interface (SPI) by which authentication providers that implement message authentication mechanisms may be integrated in client or server message-processing containers or runtimes. Authentication providers integrated through this interface operate on network messages provided to them by their calling container. The authentication providers transform outgoing messages so that the source of the message can be authenticated by the receiving container, and the recipient of the message can be authenticated by the message sender. Authentication providers authenticate incoming messages and return to their calling container the identity established as a result of the message authentication.
Bean Validation 	specification defines a metadata model and API for validating data in JavaBeans components. Instead of distributing validation of data over several layers, such as the browser and the server side, you can define the validation constraints in one place and share them across the different layers.
Contexts and Dependency Injection (CDI) 	for the Java EE platform defines a set of contextual services, provided by Java EE containers, that make it easy for developers to use enterprise beans along with JavaServer Faces technology in web applications. Designed for use with stateful objects, CDI also has many broader uses, allowing developers a great deal of flexibility to integrate different kinds of components in a loosely coupled but type-safe way.
Java Persistence API 	is a Java standards-based solution for persistence. Persistence uses an object/relational mapping approach to bridge the gap between an object-oriented model and a relational database. The Java Persistence API can also be used in Java SE applications, outside of the Java EE environment
Java Transaction API 	provides a standard interface for demarcating transactions. The Java EE architecture provides a default auto commit to handle transaction commits and rollbacks. An auto commit means that any other applications that are viewing data will see the updated data after each database read or write operation. However, if your application performs two separate database access operations that depend on each other, you will want to use the JTA API to demarcate where the entire transaction, including both operations, begins, rolls back, and commits.
Path Expressions 	Path expressions are important constructs in the syntax of the query language, for several reasons. First, path expressions define navigation paths through the relationships in the abstract schema. These path definitions affect both the scope and the results of a query. Second, path expressions can appear in any of the main clauses of a query (SELECT, DELETE, HAVING, UPDATE, WHERE, FROM, GROUP BY, ORDER BY). Finally, although much of the query language is a subset of SQL, path expressions are extensions not found in SQL.
Container-Managed Entity Managers 	 an EntityManager instance’s persistence context is automatically propagated by the container to all application components that use the EntityManager instance within a single Java Transaction API (JTA) transaction. JTA transactions usually involve calls across application components. To complete a JTA transaction, these components usually need access to a single persistence context. This occurs when an EntityManager is injected into the application components by means of the javax.persistence.PersistenceContext annotation. The persistence context is automatically propagated with the current JTA transaction, and EntityManager references that are mapped to the same persistence unit provide access to the persistence context within that transaction. By automatically propagating the persistence context, application components don’t need to pass references to EntityManager instances to each other in order to make changes within a single transaction. The Java EE container manages the lifecycle of container-managed entity managers.
Entity Inheritance 	Abstract Entities can be queried just like concrete entities. If an abstract entity is the target of a query, the query operates on all the concrete subclasses of the abstract entity. Entities may inherit from superclasses that contain persistent state and mapping information but are not entities. That is, the superclass is not decorated with the @Entity annotation and is not mapped as an entity by the Java Persistence provider. These superclasses are most often used when you have state and mapping information common to multiple entity classes. Mapped superclasses cannot be queried and can’t be used in EntityManager or Query operations. You must use entity subclasses of the mapped superclass in EntityManager or Query operations. Mapped superclasses can’t be targets of entity relationships. Mapped superclasses can be abstract or concrete. Entities may have non-entity superclasses, and these superclasses can be either abstract or concrete. The state of non-entity superclasses is nonpersistent, and any state inherited from the non-entity superclass by an entity class is nonpersistent. Non-entity superclasses may not be used in EntityManager or Query operations. Any mapping or relationship annotations in non-entity superclasses are ignored.
Direction in Entity Relationships 	can be either bidirectional or unidirectional. A bidirectional relationship has both an owning side and an inverse side. A unidirectional relationship has only an owning side. The owning side of a relationship determines how the Persistence runtime makes updates to the relationship in the database.
Bidirectional Relationships 	each entity has a relationship field or property that refers to the other entity. Through the relationship field or property, an entity class’s code can access its related object. If an entity has a related field, the entity is said to “know” about its related object. For example, if Order knows what LineItem instances it has and if LineItem knows what Order it belongs to, they have a bidirectional relationship. Bidirectional relationships must follow these rules: The inverse side of a bidirectional relationship must refer to its owning side by using the mappedBy element of the @OneToOne, @OneToMany, or @ManyToMany annotation. The mappedBy element designates the property or field in the entity that is the owner of the relationship. The many side of many-to-one bidirectional relationships must not define the mappedBy element. The many side is always the owning side of the relationship. For one-to-one bidirectional relationships, the owning side corresponds to the side that contains the corresponding foreign key. For many-to-many bidirectional relationships, either side may be the owning side.
Unidirectional Relationships 	only one entity has a relationship field or property that refers to the other. For example, LineItem would have a relationship field that identifies Product, but Product would not have a relationship field or property for LineItem. In other words, LineItem knows about Product, but Product doesn’t know which LineItem instances refer to it.
Queries and Relationship Direction 	Java Persistence query language and Criteria API queries often navigate across relationships. The direction of a relationship determines whether a query can navigate from one entity to another. For example, a query can navigate from LineItem to Product but cannot navigate in the opposite direction. For Order and LineItem, a query could navigate in both directions because these two entities have a bidirectional relationship.
Cascade Operations and Relationships 	Entities that use relationships often have dependencies on the existence of the other entity in the relationship. For example, a line item is part of an order; if the order is deleted, the line item also should be deleted. This is called a cascade delete relationship.
Collections in Entity Fields and Properties 	Collection-valued persistent fields and properties must use the supported Java collection interfaces regardless of whether the entity uses persistent fields or properties. The following collection interfaces may be used: java.util.Collection, java.util.Set, java.util.List, java.util.Map, If the entity class uses persistent fields, the type in the preceding method signatures must be one of these collection types. Generic variants of these collection types may also be used
Conditional Expressions 	Every WHERE clause must specify a conditional expression, of which there are several kinds. In the previous examples, the conditional expressions are comparison expressions that test for equality. The following examples demonstrate some of the other kinds of conditional expressions. For descriptions of all conditional expressions
The Java Persistence query language 	defines queries for entities and their persistent state. The query language allows you to write portable queries that work regardless of the underlying data store.The query language uses the abstract persistence schemas of entities, including their relationships, for its data model and defines operators and expressions based on this data model. The scope of a query spans the abstract schemas of related entities that are packaged in the same persistence unit. The query language uses an SQL-like syntax to select objects or values based on entity abstract schema types and relationships among them.
The Criteria API 	is used to define queries for entities and their persistent state by creating query-defining objects. Criteria queries are written using Java programming language APIs, are typesafe, and are portable. Such queries work regardless of the underlying data store. is based on the abstract schema of persistent entities, their relationships, and embedded objects. The Criteria API operates on this abstract schema to allow developers to find, modify, and delete persistent entities by invoking Java Persistence API entity operations. The Metamodel API works in concert with the Criteria API to model persistent entity classes for Criteria queries.
Querying entities 	in JPA involves using the Java Persistence Query Language (JPQL) or native SQL queries to retrieve data from the database. To perform a query, developers can use the EntityManager's createQuery or createNamedQuery methods, passing the query string and optional parameters. The query can be defined to retrieve specific entities or select specific attributes using the SELECT clause. Once the query is executed, the EntityManager returns the query result as a list of entity objects or as a single result object, depending on the query type. Developers can then process the retrieved entities or attributes as needed. Querying entities allows for flexible and dynamic retrieval of data based on specific criteria and conditions, enabling powerful data manipulation and analysis within the application.
Managing Entities 	Entities are managed by the entity manager, which is represented by javax.persistence.EntityManager instances. Each EntityManager instance is associated with a persistence context: a set of managed entity instances that exist in a particular data store. A persistence context defines the scope under which particular entity instances are created, persisted, and removed. The EntityManager interface defines the methods that are used to interact with the persistence context.
The EntityManager Interface 	API creates and removes persistent entity instances, finds entities by the entity’s primary key, and allows queries to be run on entities. 
Container-Managed Entity Managers 	With a container-managed entity manager, an EntityManager instance’s persistence context is automatically propagated by the container to all application components that use the EntityManager instance within a single Java Transaction API (JTA) transaction.
JTA transactions	usually involve calls across application components. To complete a JTA transaction, these components usually need access to a single persistence context. This occurs when an EntityManager is injected into the application components by means of the PersistenceContext annotation. The persistence context is automatically propagated with the current JTA transaction, and EntityManager references that are mapped to the same persistence unit provide access to the persistence context within that transaction. By automatically propagating the persistence context, application components don’t need to pass references to EntityManager instances to each other in order to make changes within a single transaction. The Java EE container manages the lifecycle of container-managed entity managers.
EntityManager 	instance is associated with a persistence context. A persistence context is a set of entity instances in which for any persistent entity identity there is a unique entity instance. Within the persistence context, the entity instances and their lifecycle are managed. The EntityManager API is used to create and remove persistent entity instances, to find entities by their primary key, and to query over entities. The set of entities that can be managed by a given EntityManager instance is defined by a persistence unit. A persistence unit defines the set of all classes that are related or grouped by the application, and which must be colocated in their mapping to a single database.
Persistence Context 	An EntityManager instance is associated with a persistence context. A persistence context is a set of entity instances in which for any persistent entity identity there is a unique entity instance. Within the persistence context, the entity instances and their lifecycle are managed. The EntityManager API is used to create and remove persistent entity instances, to find entities by their primary key, and to query over entities. The persistence context is the first-level cache where all the entities are fetched from the database or saved to the database. It sits between our application and persistent storage. Persistence context keeps track of any changes made into a managed entity. If anything changes during a transaction, then the entity is marked as dirty. When the transaction completes, these changes are flushed into persistent storage. Persistence contexts are available in two types: Transaction-scoped persistence context, Extended-scoped persistence context
PersistenceUtil 	interface between the application and the persistence provider(s), instance obtained from the Persistence class is used to determine the load state of an entity or entity attribute regardless of which persistence provider in the environment created the entity.
HibernatePersistenceProvider 	 is responsible for creating EntityManagerFactory instances based on the provided persistence unit properties and configuration. It utilizes Hibernate's configuration and mapping metadata to set up the EntityManagerFactory, enabling developers to leverage Hibernate's features and capabilities within their JPA applications.
EntityManagerFactory 	Interface used to interact with the entity manager factory for the persistence unit. When the application has finished using the entity manager factory, and/or at application shutdown, the application should close the entity manager factory. Once an EntityManagerFactory has been closed, all its entity managers are considered to be in the closed state.
Interface PersistenceUtil Utility	 interface between the application and the persistence provider(s). The PersistenceUtil interface instance obtained from the Persistence class is used to determine the load state of an entity or entity attribute regardless of which persistence provider in the environment created the entity.
isLoaded 	Determine the load state of an entity. This method can be used to determine the load state of an entity passed as a reference. An entity is considered loaded if all attributes for which FetchType.EAGER has been specified have been loaded.
Entities 	An entity is a lightweight persistence domain object. Typically, an entity represents a table in a relational database, and each entity instance corresponds to a row in that table. The primary programming artifact of an entity is the entity class, although entities can use helper classes. The persistent state of an entity is represented through either persistent fields or persistent properties. These fields or properties use object/relational mapping annotations to map the entities and entity relationships to the relational data in the underlying data store.
Requirements for Entity Classes 	An entity class must follow these requirements. The class must be annotated with the javax.persistence.Entity annotation. The class must have a public or protected, no-argument constructor. The class may have other constructors. The class must not be declared final. No methods or persistent instance variables must be declared final. If an entity instance is passed by value as a detached object, such as through a session bean’s remote business interface, the class must implement the Serializable interface. Entities may extend both entity and non-entity classes, and non-entity classes may extend entity classes. 
Persistent instance variables must be declared private, protected, or package-private and can be accessed directly only by the entity class’s methods. Clients must access the entity’s state through accessor or business methods. Application-Managed Entity Managers 	With an application-managed entity manager, on the other hand, the persistence context is not propagated to application components, and the lifecycle of EntityManager instances is managed by the application. Application-managed entity managers are used when applications need to access a persistence context that is not propagated with the JTA transaction across EntityManager instances in a particular persistence unit. In this case, each EntityManager creates a new, isolated persistence context. The EntityManager and its associated persistence context are created and destroyed explicitly by the application. They are also used when directly injecting EntityManager instances can’t be done because EntityManager instances are not thread-safe. EntityManagerFactory instances are thread-safe.
Container-Managed Entity Managers 	With a container-managed entity manager, an EntityManager instance’s persistence context is automatically propagated by the container to all application components that use the EntityManager instance within a single Java Transaction API (JTA) transaction. JTA transactions usually involve calls across application components. To complete a JTA transaction, these components usually need access to a single persistence context. This occurs when an EntityManager is injected into the application components by means of the javax.persistence.PersistenceContext annotation. The persistence context is automatically propagated with the current JTA transaction, and EntityManager references that are mapped to the same persistence unit provide access to the persistence context within that transaction. By automatically propagating the persistence context, application components don’t need to pass references to EntityManager instances to each other in order to make changes within a single transaction. The Java EE container manages the lifecycle of container-managed entity managers.
Managing Entities 	Entities are managed by the entity manager, which is represented by javax.persistence.EntityManager instances. Each EntityManager instance is associated with a persistence context: a set of managed entity instances that exist in a particular data store. A persistence context defines the scope under which particular entity instances are created, persisted, and removed. The EntityManager interface defines the methods that are used to interact with the persistence context.
Persistence Units 	A persistence unit defines a set of all entity classes that are managed by EntityManager instances in an application. This set of entity classes represents the data contained within a single data store. Are defined by the persistence.xml configuration file.
Hibernate Framework	It simplifies java application to interact with the database. Hibernate is an open source, lightweight, ORM (Object Relational Mapping) tool. It is a programming technique that maps the object to the data stored in the database.
Advantages of Hibernate Framework	 Opensource and Lightweight: 2) Fast performance: The performance of hibernate framework is fast because cache is internally used framework. There are two types of cache framework first level cache and second level cache. First level cache is enabled bydefault.Database Independent query: HQL (Hibernate Query Language) is the object-oriented version of SQL. It generates the database independent queries. So you don't need to write database specific queries. Before Hibernate, If database is changed for the project, we need to change the SQL query as well that leads to the maintenance problem.Automatic table creation: Hibernate framework provides the facility to create the tables of the database automatically. So there is no need to create tables in the database manually.Simplifies complex join: To fetch data form multiple tables is easy framework.Provides query statistics and database status: Hibernate supports Query cache and provide statistics about query and database status.
Hibernate Architecture	The Hibernate architecture includes many objects persistent object, session factory, transaction factory, connection factory, session, transaction etc. There are 4 layers architecture java application layer, hibernate framework layer, backhand api layer and database layer.Let's see the diagram of hibernate architecture:
SessionFactory	1. The SessionFactory is a factory of session and client of ConnectionProvider. 2. It holds second level cache (optional) of data. 3. SessionFactory interface provides factory method to get the object of Session.
Session	1. The session object provides an interface between the application and data stored in the database. 2. Session interface provides methods to insert, update and delete the object. 3. It also provides factory methods for Transaction, Query and Criteria.
Transaction	The transaction object specifies the atomic unit of work. It is optional. The org.hibernate.Transaction interface provides methods for transaction management.
ConnectionProvider	It is a factory of JDBC connections. It abstracts the application from DriverManager or DataSource. It is optional.
TransactionFactory	It is a factory of Transaction. It is optional.
Example to create the Hibernate Application in Eclipse IDE	Create the java project Add jar files for hibernate Create the Persistent class Create the mapping file for Persistent class Create the Configuration file Create the class that retrieves or stores the persistent object Run the application
Whats the difference between persist() and save()?	save() Persists an entity. Will assign an identifier if one doesn't exist. If one does, it's essentially doing an update. Returns the generated ID of the entity. persist() is used on transient objects. It does not return the generated ID.
What will the dialect do?	dialect convert hibernate function to sql query for corresponding db.
What is the use of batch processing?	n/w performance will increase. since only one call is made to the database. batch processing is used to send multiple stmt at once rather than one by one.
What are the core i/f and classes of hibernate	configuration (class) session (i/f) session factory(i/f) query(i/f) criteria(i/f) transaction(i/f)
What are the Persistent class	 refers to a class that is mapped to a database table. It represents an entity in the application domain model that can be stored and retrieved from the database. Persistent classes in Hibernate are typically annotated with the @Entity annotation or mapped using XML configurations. These classes define the structure and behavior of the corresponding database table, including the properties and relationships between entities. Hibernate provides various annotations and mapping options to define the mapping between persistent classes and database tables, such as @Table, @Column, and @ManyToOne, among others.
What is important method in the session	beginTransaction() getTransaction() save(); persist(); update flush clear load,merge,lock,refresh,reconnect,close
Lazy loading VS eager loading	Hibernate adopts the mechanism of lazy loading to load objects from databases. Lazy loading contributes a lot to improve the performance of an application by limiting the amount of objects that will be needed. In contrast to lazy loading, eager loading loads the full objects tree once. Because eager loads multiple related objects with a single SELECT statement instead of using multiple SELECT statements, therefore in some situations, eager loads can also improve the performance of the application by reducing the times of accessing the database.
What does the flush do?	By calling flush() we force hibernate to execute the SQL commands on Database. But do understand that changes are not "committed" yet. So after doing flush and before doing commit, if you access DB directly (say from SQL prompt)and check the modified rows, you will NOT see the changes.
BuildSessionFactory	method is used to create a SessionFactory object, which is a thread-safe and immutable representation of a Hibernate session factory. The SessionFactory is responsible for managing the persistence of objects, handling transactions, and providing a connection to the underlying database. The buildSessionFactory method is typically invoked during the initialization of a Hibernate application to create a single instance of the SessionFactory that can be shared across multiple sessions. The SessionFactory is an expensive object to create, so it is recommended to create it once and reuse it throughout the application.
What are the three type of cache	First-level cache - It is the default cache provided by Hibernate at the session level. It is associated with the session and stores the entities that have been recently accessed or loaded within the current session. Second-level cache - It is a shared cache that is available across multiple sessions and is used to cache entities, queries, and collection data. It improves performance by reducing the number of database queries and enhancing data retrieval speed. Query cache - It is used to cache the result of queries. It stores the result set of a query along with the query parameters, so that if the same query is executed again, the result can be fetched directly from the cache instead of hitting the database.
What are the inheritance available in the hibernate and why What are the types of inheritance models?	Table Per Hierarchy : it create only on table in the db. <subclass name=...> if we give subclass then specify the discriminator Table Per Concrete : it create a seperate tables (these table don't have relation with eachother) <union-subclass name=...> 1.id,name 2.id,name,salary,bonus 3.id,name,payPerHour Table Per Subclass : it create seperate table and have primary key and foreign key relation. <joined-subclass name=...> 1.id,name 2.Eid,salary,bonus 3.Eid,payPerHour
What are three subelements used in the list?	<key> element is used to define the foreign key in this table based on the Question class identifier. <index> element is used to identify the type. List and Map are indexed collection. <element> is used to define the element of the collection. <list name="answers" table="ans100"> <key column="qid"></key> <index column="type"></index> <element column="answer" type="string"></element> </list>
Hibernate Table Per Hierarchy	By this inheritance strategy, we can map the whole hierarchy by single table only. Here, an extra column (also known as discriminator column) is created in the table to identify the class.
Table Per Concrete class	In case of Table Per Concrete class, there will be three tables in the database having no relations to each other. There are two ways to map the table with table per concrete class strategy. By union-subclass element By Self creating the table for each class
Table Per Subclass	In case of Table Per Subclass, subclass mapped tables are related to parent class mapped table by primary key and foreign key relationship.
Three most important mapping	These are the mapping of collections, the mapping of associations between entity classes and Component Mappings.
What is Hibernate?	Hibernate is a pure Java object-relational mapping (ORM) and persistence framework that allows you to map plain old Java objects to relational database tables using (XML) configuration files. Its purpose is to relieve the developer from a significant amount of relational data
What is an ORM?	ORMs take objects in programming languages and translate them into DB tables
What is "persistence"?	Storing your information / data in a form that is durable (one of the ACID properties)
What is connection pooling?	The process of reusing active connections in IIS (Internet Information Services) instead of making new ones as people request items from a database.
What does it mean that Hibernate is modular?	You can write code using hibernate and then switch SQL languages entirely by changing the driver you're using
What are three important interfaces?	SessionFactory, Session, Transaction
What is the SessionFactory interface?	It creates sessions and stores information on HOW to create connections to a database.
TRUE or FALSE: Once SessionFactory is created it's immutable	True
What is the Session interface?	It manages the connection to your database and provides CRUD operations
What is the Transaction interface?	It manages transactions and the cache.
What are Transactions created from?	Session objects
What is the Configuration class?	A class that gathers information from the hibernate.cfg.xml file and uses that information to create a SessionFactory object
What are some settings for the hbm2ddl.auto attribute?	CREATE, VALIDATE, UPDATE, CREATE-DROP, NONE
What does the CREATE setting do?	it drops all existing table and other objects with names you have provided in annotations, then hibernate will create your schema from scratch.
What does the VALIDATE setting do?	Checks to make sure the schema exists as expected before operating
What does the UPDATE setting do?	It will not delete anything, but will add/modify existing schema elements, so that the schema works with hibernate's schema
What does the CREATE-DROP setting do?	Creates your schema then deletes it when application ends
What does the NONE setting do?	Means hibernate won't do anything to your schema automatically
How do we create complex queries?	HQL, Native SQL and Criteria API
Which form of creating complex queries most tightly couples your code to a specific DBMS?	Native SQL
What is HQL?	Hibernate Query Language
What does HQL do?	It creates complex queries using a combination of OOP and Native SQL concepts
What is Criteria API (CriteriaBuilder API)	The Criteria API is a predefined API used to define queries for entities. It creates complex queries fully programmatically, no SQL involved
What are the two ways to define a table?	Column annotations (@column) && Hibernate Mapping file (filename.hbm.xml)
What is JPA?	Java Persistence API - a standardized API that deals with mapping java objects to DBs
Why use JPA over hibernate annotations?	It allows us to decouple our code in case we decide to use a different ORM in the future
What is a common exception found?	LazyInitializationException
What is a reason to see a LazyInitializationException	When you try to access a not initialized relationship to another entity without an active session (closing session before finished).
What are the states of an object?	Transient, Persistent and Detached
True or False: A session has a cache associated with it	True
What is the Transient state?	The entity (object) is new and has NOT been/is NOT associated with any session
What is the Persistent state?	The entity is currently part of a session
What is the Detached state?	The entity was associated with a session HOWEVER the session is now closed
What are the types of caching?	Level 1 (L1) and Level 2(L2) caching
What is an L1 cache?	L1 is set up by default and are specific to a session. You do NOT have to configure them since they are default
What is an L2 cache?	L2 caches are scoped to the entire SessionFactory so all sessions can access the data.
True or False - You don't need a third party provider for an L2 cache	False - JBossCache and SwarmCache are examples of third party providers
update() vs merge() - which method is used to prevent a "lost update"	update()
What does get() do?	Go to the DB and retrieve records object and return null if they don't exist
What does load() do?	Return a PROXY object for you, then the proxy will go to the database when you attempt o access the data. If the record doesn't exist it will throw an exception
What does save() return?	A SERIALIZABLE object that represents the unique ID of the object
What does persist() return?	void
What are four concurrency issues with Hibernate?	Lost update, dirty read, unrepeatable read and phantom reasd
What is a dirty read?	When on thread reads and writes data then gives another incorrect data. Suppose, A changed a row but had an exception and did not commit the changes. B reads the uncommitted data
What is a lost update?	Update done to a data item by one transaction is lost as it is overwritten by the update done by another transaction.
What is an unrepeatable read?	When one transaction reads the same data twice while another transaction updates that data in between the first and second read of the first transaction
What is a phantom read?	When one transaction executes a query twice and it gets a different number of rows in the result set each time.
What are the four isolation levels?	Read Uncommitted, Read Committed, Repeatable Read, Serializable
What is the default level?	Read Committed
Under which levels will Dirt reads occur?	Read Uncommitted
Under which levels will non-repeatable reads occur?	Read Uncommitted, Read Committed
Under which levels will Phantom reads occur?	Read Uncommitted, Read Committed and Repeatable Read
What is Hibernate Framework?	Object-relational mapping or ORM is the programming technique to map application domain model objects to the relational database tables. Hibernate framework provide option to map plain old java objects to traditional database tables with the use of JPA annotations as well as XML based configuration. Similarly hibernate configurations are flexible and can be done from XML configuration file as well as programmatically.
What is Java Persistence API (JPA)?	Java Persistence API (JPA) provides specification for managing the relational data in applications. JPA specifications is defined with annotations in javax.persistence package. Using JPA annotation helps us in writing implementation independent code.
What are the important benefits of using Hibernate Framework?	- eliminates all the boiler-plate code that comes with JDBC and takes care of managing resources - provides support for XML as well as JPA annotations - provides HQL: a fully object-oriented query lg that understands concepts like inheritance, polymorphism and association. - is an open source project that is used worldwide => the learning curve is small and there are tons of online documentations and help is easily available in forums. - it is easy to integrate with other Java EE frameworks (Spring Framework provides built-in support for integrating hibernate with Spring applications.) - supports lazy initialization using proxy objects and perform actual database queries only when it's required. - its cache helps us in getting better performance. - for database vendor specific feature, hibernate is suitable because we can also execute native sql queries.
Name some important interfaces of Hibernate framework?	Session, SessionFactory, Configuration, Transaction, Query, and Criteria interface - SessionFactory is an immutable thread-safe cache of compiled mappings for a single database. We need to initialize SessionFactory once and then we can cache and reuse it. SessionFactory instance is used to get the Session objects for database operations. - Session is a single-threaded, short-lived object representing a conversation between the application and the persistent store. It wraps JDBC java.sql.Connection and works as a factory for org.hibernate.Transaction. We should open session only when it's required and close it as soon as we are done using it. Session object is the interface between java application code and hibernate framework and provide methods for CRUD operations. - Transaction is a single-threaded, short-lived object used by the application to specify atomic units of work. It abstracts the application from the underlying JDBC or JTA transaction. A Session might span multiple Transactions in some cases.
What is hibernate configuration file?	Hibernate configuration file contains database specific configurations and used to initialize SessionFactory. We provide database credentials or JNDI resource information in the hibernate configuration xml file. Some other important parts of hibernate configuration file is Dialect information, so that hibernate knows the database type and mapping file or class details.
What is hibernate mapping file?	Hibernate mapping file is used to define the entity bean fields and database table column mappings. We know that JPA annotations can be used for mapping but sometimes XML mapping file comes handy when we are using third party classes and we can't use annotations.
Name some important annotations used for Hibernate mapping? (at least 5)	- javax.persistence.Entity: Used with model classes to specify that they are entity beans. - javax.persistence.Table: Used with entity beans to define the corresponding table name in database. - javax.persistence.Access: Used to define the access type, either field or property. Default value is field and if you want hibernate to use getter/setter methods then you need to set it to property. - javax.persistence.Id: Used to define the primary key in the entity bean. - javax.persistence.Column: Used to define the column name in database table. - javax.persistence.OneToOne: Used to define the one-to-one mapping between two entity beans. We have other similar annotations as OneToMany, ManyToOne and ManyToMany - org.hibernate.annotations.Cascade: Used to define the cascading between two entity beans, used with mappings. It works in conjunction with org.hibernate.annotations.CascadeType
Hibernate SessionFactory is thread safe?	Internal state of SessionFactory is immutable, so it's thread safe. Multiple threads can access it simultaneously to get Session instances.
What is Hibernate Session and how to get it?	Hibernate Session is the interface between java application layer and hibernate. This is the core interface used to perform database operations. Lifecycle of a session is bound by the beginning and end of a transaction. Session provide methods to perform create, read, update and delete operations for a persistent object. We can execute HQL queries, SQL native queries and create criteria using Session object.
Hibernate Session is thread safe?	Hibernate Session object is not thread safe, every thread should get it's own session instance and close it after it's work is finished.
What is difference between openSession and getCurrentSession?	Hibernate SessionFactory getCurrentSession() method returns the session bound to the context. But for this to work, we need to configure it configuration file. Since this session object belongs to the hibernate context, we don't need to close it. Once the session factory is closed, this session object gets closed. <property name="hibernate.current_session_context_class">thread</property> Hibernate SessionFactory openSession() method always opens a new session. We should close this session object once we are done with all the database operations. We should open a new session for each request in multi-threaded environment.
What is difference between Hibernate Session get() and load() method?	get() loads the data as soon as it's called whereas load() returns a proxy object and loads data only when it's actually required, so load() is better because it support lazy loading. load() - faster - lazy loading - used when it is sure that the record exists - throws an exception if the record is not found - Load method does not hit the database get() - slower - used when it is not sure if the record exists - returns null if the record is not found - always hits the database
What is hibernate caching? Explain Hibernate first level cache?	As the name suggests, hibernate caches query data to make our application faster. Hibernate Cache can be very useful in gaining fast application performance if used correctly. The idea behind cache is to reduce the number of database queries, hence reducing the throughput time of the application. Hibernate first level cache is associated with the Session object. Hibernate first level cache is enabled by default and there is no way to disable it. However hibernate provides methods through which we can delete selected objects from the cache or clear the cache completely. Any object cached in a session will not be visible to other sessions and when the session is closed, all the cached objects will also be lost.
What are different states of an entity bean?	An entity bean instance can exist is one of the three states. Transient: When an object is never persisted or associated with any session, it's in transient state. Transient instances may be made persistent by calling save(), persist() or saveOrUpdate(). Persistent instances may be made transient by calling delete(). Persistent: When an object is associated with a unique session, it's in persistent state. Any instance returned by a get() or load() method is persistent. Detached: When an object is previously persistent but not associated with any session, it's in detached state. Detached instances may be made persistent by calling update(), saveOrUpdate(), lock() or replicate(). The state of a transient or detached instance may also be made persistent as a new persistent instance by calling merge().
What is the use of Hibernate Session merge() call?	Hibernate merge can be used to update existing values, however this method create a copy from the passed entity object and return it. The returned object is part of persistent context and tracked for any changes, passed object is not tracked.
What is the difference between persist() and merge()?	persist(entity) should be used with totally new entities, to add them to DB (if entity already exists in DB there will be EntityExistsException throw). merge(entity) should be used, to put entity back to persistence context if the entity was detached and was changed.
What is difference between Hibernate save(), saveOrUpdate() and persist() methods?	Hibernate save can be used to save entity to database. Problem with save() is that it can be invoked without a transaction and if we have mapping entities, then only the primary object gets saved causing data inconsistencies. Also save returns the generated id immediately. Hibernate persist is similar to save with transaction. I feel it's better than save because we can't use it outside the boundary of transaction, so all the object mappings are preserved. Also persist doesn't return the generated id immediately, so data persistence happens when needed. Hibernate saveOrUpdate results into insert or update queries based on the provided data. If the data is present in the database, update query is executed. We can use saveOrUpdate() without transaction also, but again you will face the issues with mapped objects not getting saved if session is not flushed.
What will happen if we don't have no-args constructor in Entity bean?	Hibernate uses Reflection API to create instance of Entity beans, usually when you call get() or load() methods. The method Class.newInstance() is used for this and it requires no-args constructor. So if you won't have no-args constructor in entity beans, hibernate will fail to instantiate it and you will get HibernateException.
What is difference between sorted collection and ordered collection, which one is better?	When we use Collection API sorting algorithms to sort a collection, it's called sorted list. For small collections, it's not much of an overhead but for larger collections it can lead to slow performance and OutOfMemory errors. Also the entity beans should implement Comparable or Comparator interface for it to work, read more at java object list sorting. If we are using Hibernate framework to load collection data from database, we can use it's Criteria API to use "order by" clause to get ordered list. Below code snippet shows you how to get it. List<Employee> empList = session.createCriteria(Employee.class) .addOrder(Order.desc("id")).list(); Ordered list is better than sorted list because the actual sorting is done at database level, that is fast and doesn't cause memory issues.
What are the collection types?	There are five collection types used for one-to-many relationship mappings. Bag Set List Array Map
What is the main difference between the Set and Bag collections?	A <bag> is an unordered collection, which can contain duplicated elements. That means if you persist a bag with some order of elements, you cannot expect the same order retains when the collection is retrieved. There is not a "bag" concept in Java collections framework, so we just use a java.util.List corresponds to a <bag>. A <set> is similar to <bag> except that it can only store unique objects. That means no duplicate elements can be contained in a set. When you add the same element to a set for second time, it will replace the old one. A set is unordered by default but we can ask it to be sorted. The corresponding type of a in Java is java.util.Set.
How to implement Joins?	There are various ways to implement joins. Using associations such as one-to-one, one-to-many etc. Using JOIN in the HQL query. There is another form "join fetch" to load associated data simultaneously, no lazy loading. We can fire native sql query and use join keyword.
Why we should not make Entity Class final?	Hibernate use proxy classes for lazy loading of data, only when it's needed. This is done by extending the entity bean, if the entity bean will be final then lazy loading will not be possible, hence low performance.
What is HQL and what are it's benefits?	Hibernate Framework comes with a powerful object-oriented query language - Hibernate Query Language (HQL). It's very similar to SQL except that we use Objects instead of table names, that makes it more close to object oriented programming. Hibernate query language is case-insensitive except for java class and variable names. So SeLeCT is the same as sELEct is the same as SELECT, but com.journaldev.model.Employee is not same as com.journaldev.model.EMPLOYEE. The HQL queries are cached but we should avoid it as much as possible, otherwise we will have to take care of associations. However it's a better choice than native sql query because of Object-Oriented approach. Read more at HQL Example.
What is Query Cache?	is a caching mechanism that improves performance by caching the results of queries executed against the database. It allows Hibernate to store the results of a query in memory so that subsequent executions of the same query can be retrieved from the cache instead of querying the database again. This can greatly reduce the overhead of executing repetitive queries, resulting in improved application performance. The Query Cache is configurable and can be enabled at the query level using the setCacheable(true) method or at the entity level using annotations or XML configuration.
Can we execute native sql query?	Hibernate provide option to execute native SQL queries through the use of SQLQuery object. For normal scenarios, it is however not the recommended approach because we loose benefits related to hibernate association and hibernate first level caching.
What is the benefit of native sql query support?	Native SQL Query comes handy when we want to execute database specific queries that are not supported by Hibernate API such as query hints or the CONNECT keyword in Oracle Database.
What is Named SQL Query?	Hibernate provides Named Query that we can define at a central location and use them anywhere in the code. We can created named queries for both HQL and Native SQL. Hibernate Named Queries can be defined mapping files or through the use of JPA annotations @NamedQuery and @NamedNativeQuery.
What are the benefits of Named SQL Query?	Hibernate Named Query helps us in grouping queries at a central location rather than letting them scattered all over the code. Hibernate Named Query syntax is checked when the hibernate session factory is created, thus making the application fail fast in case of any error in the named queries. Hibernate Named Query is global, means once defined it can be used throughout the application. However one of the major disadvantage of Named query is that it's hard to debug, because we need to find out the location where it's defined.
What is the benefit of Hibernate Criteria API?	Hibernate provides Criteria API that is more object oriented for querying the database and getting results. We can't use Criteria to run update or delete queries or any DDL statements. It's only used to fetch the results from the database using more object oriented approach. Some of the common usage of Criteria API are: Criteria API provides Projection that we can use for aggregate functions such as sum(), min(), max() etc. Criteria API can be used with ProjectionList to fetch selected columns only. Criteria API can be used for join queries by joining multiple tables, useful methods are createAlias(), setFetchMode() and setProjection() Criteria API can be used for fetching results with conditions, useful methods are add() where we can add Restrictions. Criteria API provides addOrder() method that we can use for ordering the results.
How to log hibernate generated sql queries in log files?	We can set below property for hibernate configuration to log SQL queries. <property name="hibernate.show_sql">true</property> However we should use it only in Development or Testing environment and turn it off in production environment.
What is Hibernate Proxy and how does it help in lazy loading?	Hibernate uses proxy object to support lazy loading. Basically when you load data from tables, hibernate doesn't load all the mapped objects. As soon as you reference a child or lookup object via getter methods, if the linked entity is not in the session cache, then the proxy code will go to the database and load the linked object. It uses javassist to effectively and dynamically generate sub-classed implementations of your entity objects.
How transaction management works?	Transaction management is very easy because most of the operations are not permitted outside of a transaction. So after getting the session from SessionFactory, we can call session beginTransaction() to start the transaction. This method returns the Transaction reference that we can use later on to either commit or rollback the transaction. Overall hibernate transaction management is better than JDBC transaction management because we don't need to rely on exceptions for rollback. Any exception thrown by session methods automatically rollback the transaction.
What is cascading and what are different types of cascading?	When we have relationship between entities, then we need to define how the different operations will affect the other entity. This is done by cascading and there are different types of it. None: No Cascading, it's not a type but when we don't define any cascading then no operations in parent affects the child. ALL: Cascades save, delete, update, evict, lock, replicate, merge, persist. Basically everything SAVE_UPDATE: Cascades save and update, available only. DELETE: Corresponds to the Hibernate native DELETE action, only. DETATCH, MERGE, PERSIST, REFRESH and REMOVE - for similar operations LOCK: Corresponds to the Hibernate native LOCK action. REPLICATE: Corresponds to the Hibernate native REPLICATE action.
How to integrate log4j logging application?	Hibernate 4 uses JBoss logging rather than slf4j used in earlier versions. For log4j configuration, we need to follow below steps. Add log4j dependencies for maven project, if not maven then add corresponding jar files. Create log4j.xml configuration file or log4j.properties file and keep it in the classpath. You can keep file name whatever you want because we will load it in next step. For standalone projects, use static block to configure log4j using DOMConfigurator or PropertyConfigurator. For web applications, you can use ServletContextListener to configure it. That's it, our setup is ready. Create org.apache.log4j.Logger instance in the java classes and start logging.
How to use application server JNDI DataSource with Hibernate framework?	For web applications, it's always best to allow servlet container to manage the connection pool. That's why we define JNDI resource for DataSource and we can use it in the web application. It's very easy to use, all we need is to remove all the database specific properties and use below property to provide the JNDI DataSource name. <property name="hibernate.connection.datasource">java:comp/env/jdbc/MyLocalDB</property>
How to integrate Hibernate and Spring frameworks?	Add hibernate-entitymanager, hibernate-core and spring-orm dependencies. Create Model classes and corresponding DAO implementations for database operations. Note that DAO classes will use SessionFactory that will be injected by Spring Bean configuration. If you are using Hibernate 3, you need to configure org.springframework.orm.hibernate3.LocalSessionFactoryBean or org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean Bean configuration file. For Hibernate 4, there is single class org.springframework.orm.hibernate4.LocalSessionFactoryBean that should be configured. Note that we don't need to use Hibernate Transaction Management, we can leave it to Spring declarative transaction management using @Transactional annotation.
What is HibernateTemplate class?	When Spring and Hibernate integration started, Spring ORM provided two helper classes - HibernateDaoSupport and HibernateTemplate. The reason to use them was to get the Session from Hibernate and get the benefit of Spring transaction management. However from Hibernate 3.0.1, we can use SessionFactory getCurrentSession() method to get the current session and use it to get the spring transaction management benefits. If you go through above examples, you will see how easy it is and that's why we should not use these classes anymore. One other benefit of HibernateTemplate was exception translation but that can be achieved easily by using @Repository annotation with service classes, shown in above spring mvc example. This is a trick question to judge your knowledge and whether you are aware of recent developments or not.
What is N+1 SELECT query issue? And what is the solution?	There exists a one-to-many relationship inside an object. A naive O/R implementation would SELECT all primary objects and then do N additional SELECTs for getting the secondary information of each primary object. As you see, the N+1 problem can happen if the first query populates the primary object and the second query populates all the child objects for each of the unique primary objects returned. Resolve N+1 SELECTs problem: (i) HQL fetch join "from MobileVendor mobileVendor join fetch mobileVendor.phoneModel PhoneModels" Corresponding SQL would be (assuming tables as follows: t_mobile_vendor for MobileVendor and t_phone_model for PhoneModel) SELECT * FROM t_mobile_vendor vendor LEFT OUTER JOIN t_phone_model model ON model.vendor_id=vendor.vendor_id (ii) Criteria query Criteria criteria = session.createCriteria(MobileVendor.class); criteria.setFetchMode("phoneModels", FetchMode.EAGER); In both cases, our query returns a list of MobileVendor objects with the phoneModels initialized. Only one query needs to be run to return all the PhoneModel and MobileVendor information required.
How to integrate log4j logging application?	Hibernate 4 uses JBoss logging rather than slf4j used in earlier versions. For log4j configuration, we need to follow below steps. Add log4j dependencies for maven project, if not maven then add corresponding jar files. Create log4j.xml configuration file or log4j.properties file and keep it in the classpath. You can keep file name whatever you want because we will load it in next step. For standalone projects, use static block to configure log4j using DOMConfigurator or PropertyConfigurator. For web applications, you can use ServletContextListener to configure it. That's it, our setup is ready. Create org.apache.log4j.Logger instance in the java classes and start logging.
What are POJOs and what's their significance?	POJOs( Plain Old Java Objects) are java beans with proper getter and setter methods for each and every properties. Use of POJOs instead of simple java classes results in an efficient and well constructed code.
How can we get hibernate statistics?	We can get hibernate statistics using getStatistics() method of SessionFactory class as shown below: SessionFactory.getStatistics()
How can we reduce database write action times?	Hibernate provides dirty checking feature which can be used to reduce database write times. Dirty checking feature of hibernate updates only those fields which require a change while keeps others unchanged.
What's the usage of callback interfaces?	Callback interfaces of hibernate are useful in receiving event notifications from objects. when an object is loaded or deleted, an event is generated and notification is sent using callback interfaces.
What are the four ORM levels?	- Pure relational (stored procedure) - Light objects mapping (JDBC) - Medium objects mapping - Full object mapping (includes inheritance, polymorphism, composition)
What does ORM consist of?	- It should have an API for performing basic CRUD (Create, Read, Update, Delete) operations on objects of persistent classes - Should have a language or an API for specifying queries that refer to the classes and the properties of classes - An ability for specifying mapping metadata - It should have a technique for ORM implementation to interact with transactional objects to perform dirty checking, lazy association fetching, and other optimization functions
What is a pure relational ORM?	The entire application, including the user interface, is designed around the relational model and SQL-based relational operations.
What is a meant by light object mapping?	The entities are represented as classes that are mapped manually to the relational tables. The code is hidden from the business logic using specific design patterns. This approach is successful for applications with a less number of entities, or applications with common, metadata-driven data models. This approach is most known to all.
What is a meant by medium object mapping?	The application is designed around an object model. The SQL code is generated at build time. And the associations between objects are supported by the persistence mechanism, and queries are specified using an object-oriented expression language. This is best suited for medium-sized applications with some complex transactions. Used when the mapping exceeds 25 different database products at a time.
What is meant by full object mapping?	Full object mapping supports sophisticated object modeling: composition, inheritance, polymorphism and persistence. The persistence layer implements transparent persistence; persistent classes do not inherit any special base class or have to implement a special interface. Efficient fetching strategies and caching strategies are implemented transparently to the application.
What are the benefits of ORM and Hibernate?	*Productivity* - Hibernate reduces the burden of developer by providing much of the functionality and lets the developer concentrate on business logic. *Maintainability* - As hibernate provides most of the functionality, the LOC for the application will be reduced and it is easy to maintain. By automated object/relational persistence it even reduces the LOC. *Performance* - Hand-coded persistence provided greater performance than automated one. But this is not true all the times. But, it provides more optimization that works all the time there by increasing the performance. If it is automated persistence then it still increases the performance. **Vendor independence - Irrespective of the different types of databases that are there, hibernate provides a much easier way to develop a cross platform application.
What are the essential properties of a transaction?	ACID: - *Atomicity* - a transaction either is successfully executed or it never happened - *Consistency* - ensures that the transaction will bring the db from one valid state to another - *Isolation* - a transaction is treated as if it is the only one performing CRUD operations in the db - *Durability* - ensured that the data is not lost during system crashes
What is the difference between the first and second level caches?	First level cache it is the default cache and it is formed by the session object. This cache is only available in a single session. Second level cache is optional and it is formed by the session factory object. This cache is available to multiple sessions.
What Is a First-Level Cache?	As most other fully-equipped ORM frameworks, Hibernate has the concept of first-level cache. It is a session scoped cache which ensures that each entity instance is loaded only once in the persistent context. Once the session is closed, first-level cache is terminated as well. This is actually desirable, as it allows for concurrent sessions to work with entity instances in isolation from each other.
What Is a Second-Level Cache?	Its is a SessionFactory-scoped cache. When an entity instance is looked up by its id (either by application logic or by Hibernate internally, e.g. when it loads associations to that entity from other entities), and if second-level caching is enabled for that entity, the following happens: - If an instance is already present in L1 cache, it is returned from there - If an instance is not found in L1 cache, and the corresponding instance state is cached in the L2 cache, then the data is fetched from there and an instance is assembled and returned - Otherwise, the necessary data are loaded from the database and an instance is assembled and returned Once the instance is stored in the persistence context (L1 cache), it is returned from there in all subsequent calls within the same session until the session is closed or the instance is manually evicted from the persistence context. Also, the loaded instance state is stored in L2 cache if it was not there already.
Name some second level caching:	EhCache, JBoss
How do you configure an L2 cache?	Step 1: Include the property tag in the hibernate.cfg.xml file <property name="hibernate.cache.provider_class"> org.hibernate.cache.EhCacheProvider </property> Step 2: Create an cache properties xml file or use annotations in the persistent class
What is the difference in the hibernate config file between the mapped and annotation driven class?	Mapping file: <mapping resource ="myTable.hbm.xml"/> Annotated POJO: <mapping class="myTable"/>
General flow of Hibernate communication with the RDBMS?	1. Load the config file and create config object. 2. Create session factory from config object 3. Get one session from the factory 4. Create HQL Query 5. Execute query
How do you define sequence generated primary key?	By using the <generator> tag or @GeneratedValue
Ways to express joins in HQL	There are 4 ways of expressing inner and outer joins: 1. Implicit association join 2. Ordinary join in the FROM clause 3. Fetch join in the FROM clause 4. theta-style join in the WHERE clause
What is connection pooling?	A cache of database connections maintained so that the connections can be reused for when requests to the database are required.
How do you setup and use hibernate?	Create Java application, mavenize it, add hibernate dependencies. The most important thing is the hibernate.cfg.xml file. You must add session-factory tag and add properties for connection driver, url, username, password, the hibernate dialect, ddl schema, mapping resource or mapping class.
2 ways of initializing the factory	new AnnotationConfiguration.configure.buildSessionFactory() new Configuration().configure().buildSessionFactory()
What is the difference between the update and merge methods?	Update means to edit something, it should be used if a session does not contain an already persistent state with same id Should be used inside the session only Merge means to combine something, it should be used if you do not know the state of the session
What is ORM?	ORM: stands for object/relational mapping. ORM is the automated persistence of objects in a Java application to the tables in a relational database.
What does ORM consists of?	An ORM solution consists of: API for performing basic CRUD operations API to express queries referring to classes Facilities to specify metadata Optimization facilities: dirty checking, lazy associations fetching
What are the ORM levels?	The ORM levels are: Pure relational (stored procedure) Light object mapping (JDBC) Medium object mapping Full object Mapping (composition, inheritance, polymorphism, persistence by reach-ability)
What is Hibernate?	Hibernate is a pure Java object-relational mapping (ORM) and persistence framework that allows you to map plain Java objects to relational database tables using XML configuration files.
List advantages of ORM tools like Hibernate	ORM tools like hibernate shields developers from messy SQL. Improved productivity and maintainability ○ Less Java code to write ○ No SQL to write Improved performance ○ Sophisticated caching ○ Lazy or eager loading
What are the core interfaces of the Hibernate framework?	Using these interfaces, you can store and retrieve persistent objects and control transactions. Session interface SessionFactory interface Configuration interface Transaction interface Query and Criteria interfaces
What are the types of Hibernate instance states ?	Three types of instance states: Transient - After instantiation but not associated with any data. Persistent - associated with data. After CRUD method (save, update, delete). Detached - no longer associated with the data. After session is closed.
What are the essential properties of a transaction?	Atomic: the transaction must execute completely or not at all. Consistency: the integrity of the underlying data stays in tact. Isolated: go without interference from other transactions. Durability: data is not lost during system crashes.
What are the Transaction Isolation Levels?	The transaction isolation level indicates the degree to which two transactions interact with each other over the same data. Read Uncommitted Read Committed Repeatable Read Serializable
What is the difference between the first and second level caches?	First level cache Default Transaction scoped. Formed by the session object. Single session availability. Guarantees object identity inside a transaction. Second level cache Optional Formed by the SessionFactory object. Multiple session availability.
Name some second level (L2) cache providers for Hibernate.	EHCache OSCache SwarmCache JBossCache
How do you configure an L2 cache?	Choose an L2 cache vendor..cfg.xml, include a cache provider tag: <property name="hibernate.cache.provider_class"> org.hibernate.cache.EhCacheProvider </property> Set the cache properties in the cache provider's xml or use annotations in the persistent class.
List some common JPA annotations used?	@Entity This required annotation above the class declaration maps the class to a table with the same name. @Id This required annotation above an instance variable makes it a primary key. @Table and @Column each have many attributes both optional.
What is the difference in the hibernate.cfg.xml for the mapped (hbm) and annotation driven class?	Mapping file implementation: <mapping resource="myTable.hbm.xml"/> Annotated POJO implementation: <mapping class="myTable"/>
What is the need for Hibernate xml mapping file?	Hibernate mapping file tells Hibernate which tables and columns to use to load and store objects.
What are the important tags of hibernate.cfg.xml	
What role does the Session interface play?	It allows you to create query objects to retrieve persistent objects. Session interface role: Wraps a JDBC connection. Factory for Transaction. Holds a L1 cache of persistent objects.
What role does the SessionFactory interface play?	The application obtains Session instances from a SessionFactory. The SessionFactory caches generate SQL statements and other mapping metadata that Hibernate uses at runtime. Ex: SessionFactory sessionFactory = configuration.buildSessionFactory();
What is the general flow of Hibernate communication with the RDBMS?	Load the Hibernate configuration file and create configuration object. It will automatically load all hbm mapping files Create session factory from configuration object Get one session from this session factory Create HQL Query Execute query to get list containing Java objects
What is Hibernate Query Language (HQL)?	Hibernate offers a query language that embodies a very powerful and flexible mechanism to query, store, update, and retrieve objects from a database. This language, the Hibernate query Language (HQL), is an object-oriented extension to SQL.
How do you map Java Objects with Database tables?	First we need to write Java domain objects (beans with setter and getter). Write hbm.xml, where we map java class to table and database columns to Java class variables. Example : <hibernate-mapping> <class name="com.test.User" table="user"> <property column="USER_NAME" length="255" </class> </hibernate-mapping>
What's the difference between load() and get()?	load() Only use the load() method if you are sure that the object exists. load() method will throw an exception if the unique id is not found in the database. load() just returns a proxy by default and database won't be hit until the proxy is first invoked. get() If you are not sure that the object exists, then use one of the get() methods. get() method will return null if the unique id is not found in the database. get() will hit the database immediately.
What is the difference between merge and update ?	update() Use update() if you are sure that the session does not contain an already persistent instance with the same identifier merge() merge() if you want to merge your modifications at any time without consideration of the state of the session.
How do you define sequence generated primary key?	Using <generator> tag. Example: <id column="USER_ID" name="id" type="java.lang.Long"> <generator class="sequence"> <param name="table">SEQUENCE_NAME</param> <generator> </id>
Define cascade and inverse option in one-many mapping?	cascade: Enable operations to cascade to child entities. inverse: Mark this collection as the "inverse" end of a bidirectional association. Ex: cascade="all|none|save-update|delete|all-delete-orphan" inverse="true|false" Essentially "inverse" indicates which end of a relationship should be ignored, so when persisting a parent who has a collection of children, should you ask the parent for its list of children, or ask the children who the parents are?
What is a Named SQL Query?	Named SQL queries: are defined in the mapping xml document and called wherever required. Example: <sql-query name = "empdetails"> <return alias="emp" class="com.test.Employee"/> SELECT emp.EMP_ID AS {emp.empid}, emp.EMP_ADDRESS AS {emp.address}, emp.EMP_NAME AS {emp.name} FROM Employee EMP WHERE emp.NAME LIKE :name </sql-query> Invoke Named Query : List people = session.getNamedQuery("empdetails") .setString("TomBrady", name) .setMaxResults(50)
How do you invoke Stored Procedures?	Stored procedures: are defined in the mapping xml document and called wherever required. Ex: <sql-query name="selectAllEmployees_SP" callable="true"> <return alias="emp" class="employee"> <return-property name="empid" column="EMP_ID"/> <return-property name="name" column="EMP_NAME"/> <return-property name="address" column="EMP_ADDRESS"/> </return> </sql-query>
Explain Criteria API	Criteria is a simplified API for retrieving entities by composing Criterion objects. Advantage: Easy to add a variable number of conditions to be placed on the result set. Example : List employees = session.createCriteria(Employee.class) .add(Restrictions.like("name", "a%") ) .add(Restrictions.like("address", "Boston")) .addOrder(Order.asc("name") ) .list();
How do you switch between different relational databases?	For an application managed datasource:.cfg.xml change the driver properties (URL, username, and password) to the new database. Use the appropriate connector jar for the new database in the project classpath. For a server managed datasource: In the hibernate.cfg.xml change the JNDI name to the one for the new database. In either case:.cfg.xml change the property tag: name = dialect to the new database dialect. No changes to the java code are required!
If you want to see the Hibernate generated SQL statements on console, what should we do?	In Hibernate configuration file, set: <property name="show_sql">true</property>
Explain the differences between sorted and ordered collection	A sorted collection: is sorting occurring in the memory of JVM which is running Hibernate, after the data being read from database. Use if collection is small. Order collection: is sorting by specifying the order-by clause for sorting this collection when retrieved. Use if collection is large.
What are the ways to express joins in HQL?	HQL provides four ways of expressing (inner and outer) joins: An implicit association join An ordinary join in the FROM clause A fetch join in the FROM clause. A theta-style join in the WHERE clause.
What is Hibernate proxy?	The proxy attribute enables lazy initialization of persistent instances of the class. Hibernate will initially return CGLIB proxies which implement the named interface. The actual persistent object will be loaded when a method of the proxy is invoked.
What is the use of dynamic-insert and dynamic-update attributes in a class mapping?	dynamic-update (defaults to false): Specifies that UPDATE SQL should be generated at runtime and contain only those columns whose values have changed. dynamic-insert (defaults to false): Specifies that INSERT SQL should be generated at runtime and contain only the columns whose values are not null.
Explain the fetching strategy	The fetching strategy is a strategy Hibernate will use for retrieving associated objects if the application needs to navigate the association. Fetch strategies may be declared in the O/R mapping metadata, or over-ridden by a particular HQL or Criteria query.
What is automatic dirty checking?	Automatic dirty checking is a feature that updates the database when we modify the state of an object inside a transaction. Advantage: saves us the effort of explicitly asking Hibernate to update the database after a modification.
What is transactional write-behind?	Hibernate uses a sophisticated algorithm to determine an efficient ordering that avoids database foreign key constraint violations but is still sufficiently predictable to the user. This feature is called transactional write-behind.
What are Callback interfaces?	Callback interfaces allow the application to receive a notification when something happens to an object. They're useful for implementing certain kinds of generic functionality.
What are the types of inheritance models?	There are three types of inheritance models: Table per class hierarchy Table per subclass Table per concrete class
What is the advantage of Hibernate over jdbc?	JDBC a developer has to write code to map an object model's data representation to a relational data model and its corresponding database schema. Hibernate is flexible and powerful ORM solution to map Java classes to database tables. Hibernate itself takes care of this mapping using XML files so developer does not need to write code for this. With JDBC, the automatic mapping of Java objects with database tables and vice versa conversion is to be taken care of by the developer manually with lines of code. Hibernate provides transparent persistence and developer does not need to write code explicitly to map database tables tuples to application objects during interaction with RDBMS. JDBC supports only native Structured Query Language (SQL). Developer has to find out the efficient way to access database, i.e. to select effective query from a number of queries to perform same task. Hibernate provides a powerful query language Hibernate Query Language (independent from type of database) that is expressed in a familiar SQL like syntax and includes full support for polymorphic queries. Hibernate also supports native SQL statements. It also selects an effective way to perform a database manipulation task for an application. JDBC applications have to handle persistent data (database tables) having database specific code in large amount. The code written to map table data to application objects and vice versa is actually to map table fields to object properties. As table changed or database changed then it's essential to change object structure as well as to change code written to map table-to-object/object-to-table. Hibernate provides this mapping itself. The actual mapping between tables and application objects is done in XML files. If there is change in Database or in any table then the only need to change XML file properties. With JDBC, it is developer's responsibility to handle JDBC result set and convert it to Java objects through code to use this persistent data in application. So with JDBC, mapping between Java objects and database tables is done manually. Hibernate reduces lines of code by maintaining object-table mapping itself and returns result to application in form of Java objects. It relieves programmer from manual handling of persistent data, hence reducing the development time and maintenance cost. With JDBC, caching is maintained by hand-coding. Hibernate, with Transparent Persistence, cache is set to application work space. Relational tuples are moved to this cache as a result of query. It improves performance if client application reads same data many times for same write. Automatic Transparent Persistence allows the developer to concentrate more on business logic rather than this application code. In JDBC there is no check that always every user has updated data. This check has to be added by the developer. Hibernate enables developer to define version type field to application, due to this defined field Hibernate updates version field of database table every time relational tuple is updated in form of Java class object to that table. So if two users retrieve same tuple and then modify it and one user save this modified tuple to database, version is automatically updated for this tuple by Hibernate. When other user tries to save updated tuple to database then it does not allow saving it because this user does not have updated data.
An object in transient state is linked to the database	false An object in Persistent state is linked to the database. An object is transient if it has just been instantiated using the new operator, and it is not associated with a Hibernate Session.
Criteria API can be used to store data in the database	false Criteria is a technique of data retrieval.
How can we have hibernate write the generated sql to the console	property name = show_sql.cfg.xml
How can you define a sequence generated primary key	using the generator tag in hbm or the GeneratedValue annotation
HQL is the object oriented version of sql and it works with entity class names rather than table names	true
The atomic property of a database transaction means	Multiple statements executed as one unit of work will pass or fail together.
The basic interface for all Hibernate applications  The instances are light weighted and can be created and destroyed without expensive process.	
The consistent property of a database transaction means	Any transaction will leave the data in a consistent state and rollback if the transaction fails
The durable property of a database transaction means	Committed data will remain persisted regardless of power loss, system crash, or other fatal errors
The isolated property of a database transaction means	Concurrent transactions provide the same results that would be found if transactions were executed one-by-one
What annotation can you use to create sequences?	@GeneratedValue
What important information is not stored in the hibernate.cfg.xml file?	mapping annotations
What is the difference between level 1 (L1) and level 2 (L2) caching?	a. L1 cache is default, while L2 cache is optional b. L1 cache is session-scoped, while L2 cache is formed by the SessionFactory c. L2 cache uses ehcache, Apache Ignite, and other plugins for configuration
Criteria interface?	provides a way to create and execute object-oriented criteria queries to retrieve objects. The Hibernate Criteria Query Language (HCQL) is used to fetch records based on specific criteria. The Criteria interface provides methods to apply criteria such as retrieving all the records of a table whose salary is greater than a certain amount. A reference to the Criteria interface can be obtained by calling the createCriteria() method on a session and passing the object of a POJO class 2. The Criteria API allows developers to build up a criteria query object programmatically, where they can apply different kinds of filtration rules and logical conditions.
Explain Hibernate	Hibernate ORM is an object relational mapping tool that provides a framework for mapping a java object to a relational database. Hibernate provides data query and retrieval facilities.
Explain the states of an object	Transient: means that an object was instantiated, but is not yet associated with a Hibernate session. Persistent: means that an object is in the Hibernate session, and any changes made to that object will reflect in the database. Detached: means that an object was persistent, but the session was closed. The detached instance and be reattached to a new session at a later point in time.
Explain how hibernate keeps track of the states of an object	For a transient object to become persistent, you need to call the Entity Manager method. Once persisted, the object is associated with a hibernate session, aka persistence context. Once the Hibernate Session is closed, all managed objects become detached.
Explain the differences of get and load	get is eager. you pull the data immediately. load is lazy and returns a proxy, until the data is requested.
Explain the differences between criteria and query	Criteria queries enable the user to write queries without using raw SQL. It provides an object-oriented way to express queries and is mostly preferred for dynamic queries where it is easier to add some ordering dynamically or leave some parts out depending on some parameter12. However, Criteria can’t be used to run update or delete queries or any DDL statements. On the other hand, HQL (Hibernate Query Language) is used for static and complex queries because it’s much easier to understand/read. HQL is a bit more powerful than Criteria, for different join types
Explain the advantages of hibernate	orm sql dialect independent. Hibernate is a flexible and powerful orm solution to map java classes to database tables. Hibernate uses hql Hibernate uses a cache, and native sql does not.
Explain the disavantages of hibernate	speed. hql is slower than sql because Hibernate may not generate the most efficient statements.
Explain where the annotations come from/ the source of annotations	Hibernate uses JPA annotations.
How do you configure Hibernate	creates session factories from hibernate.cfg.xml create configuration object and pass in filename create a session factory from configuration create a session from the factory create transactions and queries from session
Explain Hibernate Session Factory	singleton that creates sessions
Explain Hibernate session	represents DB connection: save, get, update, delete, beginTransaction, createQuery, createCriteria
Explain Filters	List bears = session.CreateFilter(dao.getBears(), "where this.name=?").setParameter("yogi").list();
Explain Named Queries	 are a common JPA feature used for defining static queries in entity classes. They allow you to define queries directly in the entity class using the @NamedQuery or @NamedQueries annotations. These queries can then be referenced by their name and executed later using the EntityManager or Query API. Named Queries provide a way to organize and manage complex queries within the entity class itself, promoting code readability and maintainability. They are especially useful for frequently used queries or queries involving multiple entities
Compare get vs load	get: gets obj right away load: if session closes before you use the obj, it doesnt exist.
Compare save vs persist	save immediately inserts save returns primary key of inserted obj save happens regardless of transaction persist returns void First difference between save and persist is there return type. Similar to save method persist also INSERT records into database but return type of persist is void while return type of save is Serializable object.
What is Hibernate Framework?	"Object-relational mapping or ORM is the programming technique to map application domain model objects to the relational database tables. Hibernate is java based ORM tool that provides framework for mapping application domain objects to the relational database tables and vice versa. Hibernate provides reference implementation of Java Persistence API, that makes it a great choice as ORM tool with benefits of loose coupling. We can use Hibernate persistence API for CRUD operations. Hibernate framework provide option to map plain old java objects to traditional database tables with the use of JPA annotations as well as XML based configuration. Similarly hibernate configurations are flexible and can be done from XML configuration file as well as programmatically."
What are the important benefits of using Hibernate Framework?	"Some of the important benefits of using hibernate framework are: Hibernate eliminates all the boiler-plate code that comes with JDBC and takes care of managing resources, so we can focus on business logic. Hibernate framework provides support for XML as well as JPA annotations, that makes our code implementation independent. Hibernate provides a powerful query language (HQL) that is similar to SQL. However, HQL is fully object-oriented and understands concepts like inheritance, polymorphism and association. Hibernate is an open source project from Red Hat Community and used worldwide. This makes it a better choice than others because learning curve is small and there are tons of online documentations and help is easily available in forums. Hibernate is easy to integrate with other Java EE frameworks, it's so popular that Spring Framework provides built-in support for integrating hibernate with Spring applications. Hibernate supports lazy initialization using proxy objects and perform actual database queries only when it's required. Hibernate cache helps us in getting better performance. For database vendor specific feature, hibernate is suitable because we can also execute native sql queries"
Explain Hibernate architecture?	that provides an abstraction layer for database access, allowing developers to work with objects instead of writing database-specific SQL queries. The Hibernate architecture includes many objects such as persistent object, session factory, transaction factory, connection factory, session, transaction etc. The Hibernate architecture is categorized in four layers: Java application layer, Hibernate framework layer, Backhand API layer and Database layer
What are the advantages of Hibernate over JDBC?	Some of the important advantages of Hibernate framework over JDBC are: Hibernate removes a lot of boiler-plate code that comes with JDBC API, the code looks more cleaner and readable. Hibernate supports inheritance, associations and collections. These features are not present with JDBC API. Hibernate implicitly provides transaction management, in fact most of the queries can't be executed outside transaction. In JDBC API, we need to write code for transaction management using commit and rollback. JDBC API throws SQLException that is a checked exception, so we need to write a lot of try-catch block code. Most of the times it's redundant in every JDBC call and used for transaction management. Hibernate wraps JDBC exceptions and throw JDBCException or HibernateException un-checked exception, so we don't need to write code to handle it. Hibernate built-in transaction management removes the usage of try-catch blocks. Hibernate Query Language (HQL) is more object oriented and close to java programming language. For JDBC, we need to write native sql queries. Hibernate supports caching that is better for performance, JDBC queries are not cached hence performance is low. Hibernate provide option through which we can create database tables too, for JDBC tables must exist in the database. Hibernate configuration helps us in using JDBC like connection as well as JNDI DataSource for connection pool. This is very important feature in enterprise application and completely missing in JDBC API. Hibernate supports JPA annotations, so code is independent of implementation and easily replaceable with other ORM tools. JDBC code is very tightly coupled with the application.
Name some important interfaces of Hibernate framework?	"SessionFactory (org.hibernate.SessionFactory): SessionFactory is an immutable thread-safe cache of compiled mappings for a single database. We need to initialize SessionFactory once and then we can cache and reuse it. SessionFactory instance is used to get the Session objects for database operations. Session (org.hibernate.Session): Session is a single-threaded, short-lived object representing a conversation between the application and the persistent store. It wraps JDBC java.sql.Connection and works as a factory for org.hibernate.Transaction. We should open session only when it's required and close it as soon as we are done using it. Session object is the interface between java application code and hibernate framework and provide methods for CRUD operations. Transaction (org.hibernate.Transaction): Transaction is a single-threaded, short-lived object used by the application to specify atomic units of work. It abstracts the application from the underlying JDBC or JTA transaction. A org.hibernate.Session might span multiple org.hibernate.Transaction in some cases."
What is hibernate configuration file?	"hibernate.cfg.xml Hibernate configuration file contains database specific configurations and used to initialize SessionFactory. We provide database credentials or JNDI resource information in the hibernate configuration xml file. Some other important parts of hibernate configuration file is Dialect information, so that hibernate knows the database type and mapping file or class details."
What is hibernate mapping file?	Hibernate mapping file is used to define the entity bean fields and database table column mappings. We know that JPA annotations can be used for mapping but sometimes XML mapping file comes handy when we are using third party classes and we can't use annotations.
Name some important annotations used for Hibernate mapping?	"javax.persistence.Entity: Used with model classes to specify that they are entity beans. javax.persistence.Table: Used with entity beans to define the corresponding table name in database. javax.persistence.Access: Used to define the access type, either field or property. Default value is field and if you want hibernate to use getter/setter methods then you need to set it to property. javax.persistence.Id: Used to define the primary key in the entity bean. javax.persistence.EmbeddedId: Used to define composite primary key in the entity bean. javax.persistence.Column: Used to define the column name in database table. javax.persistence.GeneratedValue: Used to define the strategy to be used for generation of primary key. Used in conjunction with javax.persistence.GenerationType enum. javax.persistence.OneToOne: Used to define the one-to-one mapping between two entity beans. We have other similar annotations as OneToMany, ManyToOne and ManyToMany org.hibernate.annotations.Cascade: Used to define the cascading between two entity beans, used with mappings. It works in conjunction with org.hibernate.annotations.CascadeType javax.persistence.PrimaryKeyJoinColumn: Used to define the property for foreign key. Used with org.hibernate.annotations.GenericGenerator and org.hibernate.annotations.Parameter"
Hibernate SessionFactory is thread safe?	Internal state of SessionFactory is immutable, so it's thread safe. Multiple threads can access it simultaneously to get Session instances.
Hibernate Session get() vs load() difference	From the output it's clear that get() returns the object by fetching it from database or from hibernate cache whereas load() just returns the reference of an object that might not actually exists, it loads the data from database or cache only when you access other properties of the object.
What is Hibernate Session and how to get it?	Hibernate Session is thread safe? #># "Hibernate Session object is not thread safe, every thread should get it's own session instance and close it after it's work is finished. What is difference bet" What is difference between openSession and getCurrentSession? #># "Hibernate SessionFactory getCurrentSession() method returns the session bound to the context. But for this to work, we need to configure it configuration file. Since this session object belongs to the hibernate context, we don't need to close it. Once the session factory is closed, this session object gets closed.<property name=""hibernate.current_session_context_class"">thread</property>Hibernate SessionFactory openSession() method always opens a new session. We should close this session object once we are done with all the database operations. We should open a new session for each request in multi-threaded environment. There is another method openStatelessSession() that returns stateless session, for more details with examples please read Hibernate openSession vs getCurrentSession." What is difference between Hibernate Session get() and load() method? #># "Hibernate session comes with different methods to load data from database. get and load are most used methods, at first look they seems similar but there are some differences between them. get() loads the data as soon as it's called whereas load() returns a proxy object and loads data only when it's actually required, so load() is better because it support lazy loading. Since load() throws exception when data is not found, we should use it only when we know data exists. We should use get() when we want to make sure data exists in the database. For clarification regarding the differences, please read Hibernate get vs load." What is hibernate caching? Explain Hibernate first level cache? #># "As the name suggests, hibernate caches query data to make our application faster. Hibernate Cache can be very useful in gaining fast application performance if used correctly. The idea behind cache is to reduce the number of database queries, hence reducing the throughput time of the application. Hibernate first level cache is associated with the Session object. Hibernate first level cache is enabled by default and there is no way to disable it. However hibernate provides methods through which we can delete selected objects from the cache or clear the cache completely. Any object cached in a session will not be visible to other sessions and when the session is closed, all the cached objects will also be lost." What are different states of an entity bean? #># "An entity bean instance can exist is one of the three states. Transient: When an object is never persisted or associated with any session, it's in transient state. Transient instances may be made persistent by calling save(), persist() or saveOrUpdate(). Persistent instances may be made transient by calling delete(). Persistent: When an object is associated with a unique session, it's in persistent state. Any instance returned by a get() or load() method is persistent. Detached: When an object is previously persistent but not associated with any session, it's in detached state. Detached instances may be made persistent by calling update(), saveOrUpdate(), lock() or replicate(). The state of a transient or detached instance may also be made persistent as a new persistent instance by calling merge()." What is difference between Hibernate save(), saveOrUpdate() and persist() methods? #># "Hibernate save can be used to save entity to database. Problem with save() is that it can be invoked without a transaction and if we have mapping entities, then only the primary object gets saved causing data inconsistencies. Also save returns the generated id immediately. Hibernate persist is similar to save with transaction. I feel it's better than save because we can't use it outside the boundary of transaction, so all the object mappings are preserved. Also persist doesn't return the generated id immediately, so data persistence happens when needed. Hibernate saveOrUpdate results into insert or update queries based on the provided data. If the data is present in the database, update query is executed. We can use saveOrUpdate() without transaction also, but again you will face the issues with mapped objects not getting saved if session is not flushed. For example usage of these methods, read Hibernate save vs persist." What will happen if we don't have no-args constructor in Entity bean? #># Hibernate uses Reflection API to create instance of Entity beans, usually when you call get() or load() methods. The method Class.newInstance() is used for this and it requires no-args constructor. So if you won't have no-args constructor in entity beans, hibernate will fail to instantiate it and you will get HibernateException. What is difference between sorted collection and ordered collection, which one is better? #># "When we use Collection API sorting algorithms to sort a collection, it's called sorted list. For small collections, it's not much of an overhead but for larger collections it can lead to slow performance and OutOfMemory errors. Also the entity beans should implement Comparable or Comparator interface for it to work, read more at java object list sorting. If we are using Hibernate framework to load collection data from database, we can use it's Criteria API to use "order by" clause to get ordered list. Below code snippet shows you how to get it. List<Employee> empList = session.createCriteria(Employee.class) .addOrder(Order.desc(""id"")).list(); Ordered list is better than sorted list because the actual sorting is done at database level, that is fast and doesn't cause memory issues."
What is Hibernate Framework?	Object-relational mapping or ORM is the programming technique to map application domain model objects to the relational database tables. Hibernate is java based ORM tool that provides framework for mapping application domain objects to the relational database tables and vice versa.Hibernate provides reference implementation of Java Persistence API, that makes it a great choice as ORM tool with benefits of loose coupling. We can use Hibernate persistence API for CRUD operations. Hibernate framework provide option to map plain old java objects to traditional database tables with the use of JPA annotations as well as XML based configuration.Similarly hibernate configurations are flexible and can be done from XML configuration file as well as programmatically.""
What are the important benefits of using Hibernate Framework?	Some of the important benefits of using hibernate framework are:Hibernate eliminates all the boiler-plate code that comes with JDBC and takes care of managing resources, so we can focus on business logic.Hibernate framework provides support for XML as well as JPA annotations, that makes our code implementation independent.Hibernate provides a powerful query language (HQL) that is similar to SQL. However, HQL is fully object-oriented and understands concepts like inheritance, polymorphism and association.Hibernate is an open source project from Red Hat Community and used worldwide. This makes it a better choice than others because learning curve is small and there are tons of online documentations and help is easily available in forums.Hibernate is easy to integrate with other Java EE frameworks, it's so popular that Spring Framework provides built-in support for integrating hibernate with Spring applications.Hibernate supports lazy initialization using proxy objects and perform actual database queries only when it's required.Hibernate cache helps us in getting better performance.For database vendor specific feature, hibernate is suitable because we can also execute native sql queries"
What is hibernate configuration file?	Hibernate configuration file contains database specific configurations and used to initialize SessionFactory. We provide database credentials or JNDI resource information in the hibernate configuration xml file. Some other important parts of hibernate configuration file is Dialect information, so that hibernate knows the database type and mapping file or class details.
What is hibernate mapping file?	Hibernate mapping file is used to define the entity bean fields and database table column mappings. We know that JPA annotations can be used for mapping but sometimes XML mapping file comes handy when we are using third party classes and we can't use annotations. "
Name some important annotations used for Hibernate mapping?	Hibernate supports JPA annotations and it has some other annotations in org.hibernate.annotations package. Some of the important JPA and hibernate annotations used are: javax.persistence.Entity: Used with model classes to specify that they are entity beans. javax.persistence.Table: Used with entity beans to define the corresponding table name in database. javax.persistence.Access: Used to define the access type, either field or property. Default value is field and if you want hibernate to use getter/setter methods then you need to set it to property. javax.persistence.Id: Used to define the primary key in the entity bean. javax.persistence.EmbeddedId: Used to define composite primary key in the entity bean. javax.persistence.Column: Used to define the column name in database table. javax.persistence.GeneratedValue: Used to define the strategy to be used for generation of primary key. Used in conjunction with javax.persistence.GenerationType enum. javax.persistence.OneToOne: Used to define the one-to-one mapping between two entity beans. We have other similar annotations as OneToMany, ManyToOne and ManyToMany org.hibernate.annotations.Cascade: Used to define the cascading between two entity beans, used with mappings. It works in conjunction with org.hibernate.annotations.CascadeType javax.persistence.PrimaryKeyJoinColumn: Used to define the property for foreign key.
What is Hibernate SessionFactory and how to configure it?	SessionFactory is the factory class used to get the Session objects. SessionFactory is responsible to read the hibernate configuration parameters and connect to the database and provide Session objects. Usually an application has a single SessionFactory instance and threads servicing client requests obtain Session instances from this factory.The internal state of a SessionFactory is immutable. Once it is created this internal state is set. This internal state includes all of the metadata about Object/Relational Mapping.SessionFactory also provide methods to get the Class metadata and Statistics instance to get the stats of query executions, second level cache details etc. "
Hibernate SessionFactory is thread safe?	Internal state of SessionFactory is immutable, so it's thread safe. Multiple threads can access it simultaneously to get Session instances. "
What is Hibernate Session and how to get it?	Hibernate Session is the interface between java application layer and hibernate. This is the core interface used to perform database operations. Lifecycle of a session is bound by the beginning and end of a transaction.Session provide methods to perform create, read, update and delete operations for a persistent object. We can execute HQL queries, SQL native queries and create criteria using Session object. "
Hibernate Session is thread safe?	Hibernate Session object is not thread safe, every thread should get it's own session instance and close it after it's work is finished. "
What is difference between openSession and getCurrentSession?	Hibernate SessionFactory getCurrentSession() method returns the session bound to the context. But for this to work, we need to configure it configuration file. Since this session object belongs to the hibernate context, we don't need to close it. Once the session factory is closed, this session object gets closed. <property name=""hibernate.current_session_context_class""> thread </property> Hibernate SessionFactory openSession() method always opens a new session. We should close this session object once we are done with all the database operations. We should open a new session for each request in multi-threaded environment.
What are the differences between get and load methods?	Hibernate session comes with different methods to load data from database. get and load are most used methods, at first look they seems similar but there are some differences between them. get() loads the data as soon as it's called whereas load() returns a proxy object and loads data only when it's actually required, so load() is better because it support lazy loading. Since load() throws exception when data is not found, we should use it only when we know data exists. We should use get() when we want to make sure data exists in the database.For clarification regarding the differences, please read Hibernate get vs load.
What is hibernate caching? Explain Hibernate first level cache?	As the name suggests, hibernate caches query data to make our application faster. Hibernate Cache can be very useful in gaining fast application performance if used correctly. The idea behind cache is to reduce the number of database queries, hence reducing the throughput time of the application.Hibernate first level cache is associated with the Session object. Hibernate first level cache is enabled by default and there is no way to disable it. However hibernate provides methods through which we can delete selected objects from the cache or clear the cache completely.Any object cached in a session will not be visible to other sessions and when the session is closed, all the cached objects will also be lost.""
What are different states of an entity bean?	An entity bean instance can exist is one of the three states. Transient: When an object is never persisted or associated with any session, it's in transient state. Transient instances may be made persistent by calling save(), persist() or saveOrUpdate(). Persistent instances may be made transient by calling delete(). Persistent: When an object is associated with a unique session, it's in persistent state. Any instance returned by a get() or load() method is persistent. Detached: When an object is previously persistent but not associated with any session, it's in detached state. Detached instances may be made persistent by calling update(), saveOrUpdate(), lock() or replicate(). The state of a transient or detached instance may also be made persistent as a new persistent instance by calling merge().
What is use of Hibernate Session merge() call?	Hibernate merge can be used to update existing values, however this method create a copy from the passed entity object and return it. The returned object is part of persistent context and tracked for any changes, passed object is not tracked. "
What is difference between Hibernate save(), saveOrUpdate() and persist() methods?	Hibernate save can be used to save entity to database. Problem with save() is that it can be invoked without a transaction and if we have mapping entities, then only the primary object gets saved causing data inconsistencies. Also save returns the generated id immediately.Hibernate persist is similar to save with transaction. I feel it's better than save because we can't use it outside the boundary of transaction, so all the object mappings are preserved. Also persist doesn't return the generated id immediately, so data persistence happens when needed.Hibernate saveOrUpdate results into insert or update queries based on the provided data. If the data is present in the database, update query is executed. We can use saveOrUpdate() without transaction also, but again you will face the issues with mapped objects not getting saved if session is not flushed. For example usage of these methods, read Hibernate save vs persist. "
What will happen if we don't have no-args constructor in Entity bean?	Hibernate uses Reflection API to create instance of Entity beans, usually when you call get() or load() methods. The method Class.newInstance() is used for this and it requires no-args constructor. So if you won't have no-args constructor in entity beans, hibernate will fail to instantiate it and you will get HibernateException.
What are the collection types?	There are five collection types used for: ArrayType BagType CustomCollectionType IdentifierBagType ListType MapType SetType
How to implement Joins?	There are various ways to implement joins. Using associations such as one-to-one, one-to-many etc. Using JOIN in the HQL query. There is another form "join fetch" to load associated data simultaneously, no lazy loading. We can fire native sql query and use join keyword."
Why we should not make Entity Class final?	Hibernate use proxy classes for lazy loading of data, only when it's needed. This is done by extending the entity bean, if the entity bean will be final then lazy loading will not be possible, hence low performance. "
What is HQL and what are it's benefits?	Hibernate Framework comes with a powerful object-oriented query language - Hibernate Query Language (HQL). It's very similar to SQL except that we use Objects instead of table names, that makes it more close to object oriented programming.Hibernate query language is case-insensitive except for java class and variable names. So SeLeCT is the same as sELEct is the same as SELECT, but com.journaldev.model.Employee is not same as com.journaldev.model.EMPLOYEE.""
What is Query Cache?	Hibernate implements a cache region for queries resultset that integrates closely with the hibernate second-level cache.This is an optional feature and requires additional steps in code. This is only useful for queries that are run frequently with the same parameters. First of all we need to configure below property configuration file.<property name=""hibernate.cache.use_query_cache"">true</property>And in code, we need to use setCacheable(true) method of Query, quick example looks like below.CopyQuery query = session.createQuery(""from Employee"");query.setCacheable(true);query.setCacheRegion(""ALL_EMP"");"
Can we execute native sql query?	Hibernate provide option to execute native SQL queries through the use of SQLQuery object.
What is the benefit of native sql query support?	Native SQL Query comes handy when we want to execute database specific queries that are not supported by Hibernate API such as query hints or the CONNECT keyword in Oracle Database. "
What is Named SQL Query?	Hibernate provides Named Query that we can define at a central location and use them anywhere in the code. We can created named queries for both HQL and Native SQL.Hibernate Named Queries can be defined mapping files or through the use of JPA annotations @NamedQuery and @NamedNativeQuery. ""
What are the benefits of Named SQL Query?	Hibernate Named Query helps us in grouping queries at a central location rather than letting them scattered all over the code.Hibernate Named Query syntax is checked when the hibernate session factory is created, thus making the application fail fast in case of any error in the named queries.Hibernate Named Query is global, means once defined it can be used throughout the application.However one of the major disadvantage of Named query is that it's hard to debug, because we need to find out the location where it's defined.
What is the benefit of Hibernate Criteria API?	Hibernate provides Criteria API that is more object oriented for querying the database and getting results. We can't use Criteria to run update or delete queries or any DDL statements. It's only used to fetch the results from the database using more object oriented approach.Some of the common usage of Criteria API are: Criteria API provides Projection that we can use for aggregate functions such as sum(), min(), max() etc. Criteria API can be used with ProjectionList to fetch selected columns only. Criteria API can be used for join queries by joining multiple tables, useful methods are createAlias(), setFetchMode() and setProjection() Criteria API can be used for fetching results with conditions, useful methods are add() where we can add Restrictions. Criteria API provides addOrder() method that we can use for ordering the results.""
How to log hibernate generated sql queries in log files?	We can set below property for hibernate configuration to log SQL queries. <property name=""hibernate.show_sql"">true</property>However we should use it only in Development or Testing environment and turn it off in production environment. "
What is Hibernate Proxy and how it helps in lazy loading?	Hibernate uses proxy object to support lazy loading. Basically when you load data from tables, hibernate doesn't load all the mapped objects. As soon as you reference a child or lookup object via getter methods, if the linked entity is not in the session cache, then the proxy code will go to the database and load the linked object. It uses javassist to effectively and dynamically generate sub-classed implementations of your entity objects.
How to implement relationships?	We can easily implement one-to-one, one-to-many and many-to-many relationships. It can be done using JPA annotations as well as XML based configurations.
How transaction management works?	Transaction management is very easy because most of the operations are not permitted outside of a transaction. So after getting the session from SessionFactory, we can call session beginTransaction() to start the transaction. This method returns the Transaction reference that we can use later on to either commit or rollback the transaction.Overall hibernate transaction management is better than JDBC transaction management because we don't need to rely on exceptions for rollback. Any exception thrown by session methods automatically rollback the transaction. "
What is cascading and what are different types of cascading?	When we have relationship between entities, then we need to define how the different operations will affect the other entity. This is done by cascading and there are different types of it."
How to integrate Hibernate and Spring frameworks?	Following steps are required to integrate Spring and Hibernate frameworks together. Add hibernate-entitymanager, hibernate-core and spring-orm dependencies. Create Model classes and corresponding DAO implementations for database operations. Note that DAO classes will use SessionFactory that will be injected by Spring Bean configuration. If you are using Hibernate 3, you need to configure org.springframework.orm.hibernate3.LocalSessionFactoryBean or org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean Bean configuration file. For Hibernate 4, there is single class org.springframework.orm.hibernate4.LocalSessionFactoryBean that should be configured. Note that we don't need to use Hibernate Transaction Management, we can leave it to Spring declarative transaction management using @Transactional annotation.
How to integrate Hibernate with Servlet or Struts2 web applications?	Hibernate integration with Servlet or Struts2 needs to be done using ServletContextListener,"
Which design patterns are used framework?	Some of the design patterns used Framework are: Domain Model Pattern - An object model of the domain that incorporates both behavior and data. Data Mapper - A layer of Mappers that moves data between objects and a database while keeping them independent of each other and the mapper itself. Proxy Pattern for lazy loading Factory pattern in SessionFactory""
What are best practices to follow with Hibernate framework?	Some of the best practices to follow are: Always check the primary key field access, if it's generated at the database layer then you should not have a setter for this. By default hibernate set the field values directly, without using setters. So if you want hibernate to use setters, then make sure proper access is defined as @Access(value=AccessType.PROPERTY). If access type is property, make sure annotations are used with getter methods and not setter methods. Avoid mixing of using annotations on both filed and getter methods. Use native sql query only when it can't be done using HQL, such as using database specific feature. If you have to sort the collection, use ordered list rather than sorting it using Collection API. Use named queries wisely, keep it at a single place for easy debugging. Use them for commonly used queries only. For entity specific query, you can keep them in the entity bean itself. For web applications, always try to use JNDI DataSource rather than configuring to create connection. Avoid Many-to-Many relationships, it can be easily implemented using bidirectional One-to-Many and Many-to-One relationships. For collections, try to use Lists, maps and sets. Avoid array because you don't get benefit of lazy loading. Do not treat exceptions as recoverable, roll back the Transaction and close the Session. If you do not do this, Hibernate cannot guarantee that in-memory state accurately represents the persistent state. Prefer DAO pattern for exposing the different methods that can be used with entity bean Prefer lazy fetching for associations""
What is Hibernate Validator Framework?	Data validation is integral part of any application. You will find data validation at presentation layer with the use of Javascript, then at the server side code before processing it. Also data validation occurs before persisting it, to make sure it follows the correct format.Validation is a cross cutting task, so we should try to keep it apart from our business logic. That's why JSR303 and JSR349 provides specification for validating a bean by using annotations. Hibernate Validator provides the reference implementation of both these bean validation specs."
What is JPA and its key components?	Mapping between database tables and java objects called ORM (Object Relational Mapping). JPA (Java Persistence API) provides and ORM facility for managing relational tables in Java applications. It is a specification and few implementations are like Hibernate, JDO, EJB, Toplink. By using JPA can be fetched data, insert, update etc.
What is the difference between persistence.xml and hibernate.cfg.xml?	When using JPA need persistence.xml and while using Hibernate API need hibernate.cfg.xml. When using JPA or Hibernate not needed both xmls, need the xml configuration file according to JPA or Hibernate.
What is an EntityManager?	"Entity manager javax.persistence.EntityManager provides the operations from and to the database, e.g. find objects, persists them, remove objects from the database, etc. Entities which are managed by an EntityManager will automatically propagate these changes to the database (if this happens within a commit statement). These objects are known as persistent object. If the Entity Manager is closed (via close()) then the managed entities are in a detached state. These are known as the detached objects. If you want synchronize them again with the database, the a Entity Manager provides the merge() method. Once merged, the object(s) becomes perstent objects again. The EntityManager is the API of the persistence context, and an EntityManager can be injected directly in to a DAO without requiring a JPA Template. The Spring Container is capable of acting as a JPA container and of injecting the EntityManager by honoring the @PersistenceContext (both as field-level and a method-level annotation)."
What is an Entity?	"A class which should be persisted in a database it must be annotated with javax.persistence.Entity. Such a class is called Entity. An instances of the class will be a row in the person table. So, the columns in the person table will be mapped to the Person java object annotated as @Entity. While insert, update or fetch record to or from the database we use entity as mapping with relational tables."
Why to use JPA?	"JPA is the standard, and standards are good! Using JPA does not tie you to Hibernate. JPA gives you most of the features of plain old Hibernate, except: No criteria queries in JPA 2.0. Criteria query is a neat feature of Hibernate that constructs query using Java-based combinators instead of alternate query language, getting the benefit of IntelliSense and Eclipse's refactoring tools. JPA doesn't have Hibernate's DeleteOrphan cascade type. Delete Orphan is a useful annotation that directs Hibernate to deletes entities in a collection if the parent is deleted, preventing orphaning. JPA doesn't have an equivalent to Hibernate's ScrollableResults."
What is Embeddable classes?	Entities may use persistent fields, persistent properties, or a combination of both. If the mapping annotations are applied to the entity's instance variables, the entity uses persistent fields. If the mapping annotations are applied to the entity's getter methods for JavaBeans-style properties, the entity uses persistent properties.
What is Persistent Fields?	If the entity class uses persistent fields, the Persistence runtime accesses entity-class instance variables directly. All fields not annotated javax.persistence.Transient or not marked as Java transient will be persisted to the data store. The object/relational mapping annotations must be applied to the instance variables.
What is Persistent Properties?	"If the entity uses persistent properties, the entity must follow the method conventions of JavaBeans components. JavaBeans-style properties use getter and setter methods that are typically named after the entity class's instance variable names. For every persistent property property of type Type of the entity, there is a getter method getProperty and setter method setProperty. If the property is a Boolean, you may use isProperty instead of getProperty. if a Customer entity uses persistent properties and has a private instance variable called firstName, the class defines a getFirstName and setFirstName method for retrieving and setting the state of the firstName instance variable. The method signature for single-valued persistent properties are as follows: Type getProperty() void setProperty(Type type) The object/relational mapping annotations for persistent properties must be applied to the getter methods. Mapping annotations cannot be applied to fields or properties annotated @Transient or marked transient."
Explain Life Cycle of a JPA Entity.	"Key states that an entity might be in: 1) New / Transient: An object is instantiated but not yet associated with an Entity Manager and has no representation in the database.Managed / Persisted.Detached: Detached entity objects are objects in a special state in which they are not managed by any EntityManager but still represent objects in the database. Detached objects are often returned from a persistence tier to the web layer where they can be displayed to the end-user in some form. Changes can be made to a detached dobject, but these changes won\'t be persisted to the database until the entity is reassociated with a persistence context (the entity is merged back to an EntityManager to become managed again).Removed. - The merge method\'s major task is to transfer the state from an unmanaged entity (passed as the argument) to its managed counterpart within the persistence context. - merge deals with both new and detached entities. Merge causes either INSERT or UPDATE operation according to the sub-scenario (on the one hand it is more robust, on the other hand this robustness needn\'t be required.) - persist always causes INSERT SQL operation is executed (i.e. an exception may be thrown if the entity has already been inserted and thus the primary key violation happens.)"
What is JPQL?	JPQL (Java Persistence Query Language) offers an object-oriented syntax for expressing query that is very similar to SQL. The language is interpreted at runtime, which means you cannot use the compiler to verify the correctness and integrity of a query. To adress this limitation, Hibernate includes a Criteria API, which allows queries to be expressed programmatically.
What is PersistenceContext	"A persistence context handles a set of entities which hold data to be persisted in some persistence store (e.g. a database).Entities are managed by javax.persistence.EntityManager instance using persistence context.Each EntityManager instance is associated with a persistence context. Within the persistence context, the entity instances and their lifecycle are managed.Persistence context defines a scope under which particular entity instances are created, persisted, and removed. A persistence context is like a cache which contains a set of persistent entities , So once the transaction is finished, all persistent objects are detached from the EntityManager's persistence context and are no longer managed A Cache is a copy of data, copy meaning pulled from but living outside the database.Flushing a Cache is the act of putting modified data back into the database. A PersistenceContext is essentially a Cache(copy of data from database outside database). It also tends to have it's own non-shared database connection.An EntityManager represents a PersistenceContext (and therefore a Cache).An EntityManagerFactory creates an EntityManager(and therefore a PersistenceContext/Cache)"
What is the difference between LocalContainerEntityManagerFactoryBean and LocalEntityManagerFactoryBean?	JPA specification defines two types of entity managers.
When to use JPA getSingleResult()	getSingleResult() is used in situations like: "I am totally sure that this record exists. I don't want to test for null every time I use this method because I am sure that it will not return it. Otherwise it causes alot of boilerplate and defensive programming. And if the record really does not exist (as opposite to what we've assumed), it is much better to have NoResultException compared to NullPointerException. If the record is not found it throws NoResultException
When the JPA Entities will become detached	"When the transaction (in transaction-scoped persistence context) commits, entities managed by the persistence context become detached. If an application-managed persistence context is closed, all managed entities become detached. Using clear method using detach method rollback In extended persistence context when a stateful bean is removed, all managed entities become detached."
Why we need JPAVendorAdapter	"EntityManagerFactory manages the lifecycle of the entities.Persistence Provider is the one which specifies the details about the database and connection details of the underlying database either by persistence-context.xml or by injecting instances of EntityManager using @PersistenceContext annotation. JPAVendorAdapter helps to define the persistence context which is likely to be used. Persistence-context.xml ... If we want to inject instances of EntityManager using @PersistenceContext annotation, we have to enable annotation bean processor configuration 1<bean class=""org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"" />Usually this line is optional because a default PersistenceAnnotationBeanPostProcessor will be registered by the and XML tags."
getSingleResult() return detached or Managed Object	objects returned from .getResultList() are managed.When you made changes on the managed objects, you do not worry about merging as those changes will be picked up by the EntityManager automatically.The managed objects will become detached when the EntityManager that is used to load that object is close(), clear() or detach(). Detached objects are not manged anymore and you should do merging to let the EntityManager pick up the changes.
What is the Java Persistence API?	The Java Persistence API (JPA) is a specification that provides a POJO persistence model for object-relational mapping. It was developed by the EJB 3.0 software expert group as part of JSR 220, but its use is not limited to EJB software components. It can also be used directly by web applications and application clients, and even outside the Java EE platform, in Java SE applications. JPA allows developers to map, store, update and retrieve data from relational databases to Java objects and vice versa. JPA can be used in both Java-EE and Java-SE applications. JPA is a specification and several implementations are available, including popular implementations such as Hibernate, EclipseLink and Apache OpenJPA
What is the object-relational mapping?	The object-relational mapping is a mechanism which is used to develop and maintain a relationship between an object and the relational database by mapping an object state into the database column. It converts attributes of programming code into columns of the table. It is capable of handling various database operations easily such as insertion, updation, deletion, etc."
What are the advantages of JPA?	The advantages of JPA are given below. The burden of interacting with the database reduces significantly by using JPA. The user programming becomes easy by concealing the O/R mapping and database access processing. The cost of creating the definition file is reduced by using annotations. We can merge the applications used with other JPA providers Using different implementations can add the features to the standard Implementation which can later be the part of JPA specification."
What are the embeddable classes?	Embeddable classes represent the state of an entity but do not have a persistent identity of their own. The objects of such classes share the identity of the entity classes that owns it. An Entity may have single-valued or multivalued embeddable class attributes."
List some ORM frameworks.	Following are the various frameworks that function on ORM mechanism: - Hibernate TopLink ORMLite iBATIS JPOX"
What is the JPQL?	JPQL is the Java Persistence query language defined in JPA specification. It is used to construct the queries."
What are the steps to persist an entity object?	The following steps are performed to persist an entity object. Create an entity manager factory object. The EntityManagerFactory interface present in java.persistence package is used to provide an entity manager. EntityManagerFactory emf=Persistence.createEntityManagerFactory(""Student_details""); Obtain an entity manager from the factory. EntityManager em=emf.createEntityManager(); Initialize an entity manager. em.getTransaction().begin(); Persist the data into the relational database. em.persist(s1); Closing the transaction em.getTransaction().commit(); Release the factory resources. emf.close(); em.close(); "
What are the steps to insert an entity?	We can easily insert the data into the database through the entity. The EntityManager provides persist() method to add records.
What are the steps to find an entity?	To find an entity, EntityManger interface provides find() method that searches an element by the primary key
What are the steps to update an entity?	JPA allows us to change the records in the database by updating an entity. The following steps are to be performed to update the entity. Get the object from db Start a transaction Modify the object commit transaction
What are the steps to delete an entity?	To delete a record from the database, EntityManager interface provides remove() method. The remove() method uses the primary key to delete the particular record."
What are the different directions of entity mapping?	The direction of a mapping can be either unidirectional or bidirectional. In unidirectional mapping, only one entity can be mapped to another entity, whereas in bidirectional mapping each entity can be mapped or referred to another entity."
What are the different types of entity mapping?	Following are the types of object-relational mapping: - One-to-one mapping: The one-to-one mapping represents a single-valued association where an instance of one entity is associated with an instance of another entity. In this type of association, one instance of source entity can be mapped with at most one instance of the target entity. One-To-Many mapping: The One-To-Many mapping comes into the category of collection-valued association where an entity is associated with a collection of other entities. In this type of association, the instance of one entity can be mapped with any number of instances of another entity. Many-to-one mapping The Many-To-One mapping represents a single-valued association where a collection of entities can be associated with the similar entity. In the relational database, more than one row of an entity can refer to the same row of another entity. Many-to-many mapping The Many-To-Many mapping represents a collection-valued association where any number of entities can be associated with a collection of other entities. In the relational database, more than one row of one entity can refer to more than one row of another entity."
What is an orphan removal in mappings?	If a target entity in one-to-one or one-to-many mapping is removed from the mapping, then remove operation can be cascaded to the target entity. Such target entities are known as orphans, and the orphanRemoval attribute can be used to specify that orphaned entities should be removed."
Explain persistence life cycle of an object?	In persistence life cycle, the object lies in the following states: - Transient - The object is called to be in the transient state when it is just declared by using the new keyword. When an object remains in the transient state, it doesn't contain any identifier(primary key) in the database. Persistence - In this state, an object is associated with the session and either saved to a database or retrieved from the database. When an object remains in the persistence state, It contains a row of the database and consists of an identifier value. We can make an object persistent by associating it with the hibernate session. Detached - The object enters into a detached state when the hibernate session is closed. The changes made to the detached objects are not saved to the database.
What are the different types of identifier generation?	Following are the types of id generation strategy required to specify with @GeneratedValue annotation: - Automatic Id generation - In this case, the application doesn't care about the kind of id generation and hand over this task to the provider. If any value is not specified explicitly, the generation type defaults to auto. Id generation using a table - The identifiers can also be generated using a database table. Id generation using a database sequence - Databases support an internal mechanism for id generation called sequences. To customize the database sequence name, we can use the JPA @SequenceGenerator annotation. Id generation using a database identity - In this approach, whenever a row is inserted into the table, a unique identifier is assigned to the identity column that can be used to generate the identifiers for the objects."
What is an entity?	The entity is a group of states associated together in a single unit. An entity behaves as an object and becomes a major constituent of the object-oriented paradigm. In other words, we can say that an entity is an application-defined object in the Java Persistence Library. Each entity is associated with the metadata which represents its information in the form of XML or annotation"
What are the properties of an entity?	ollowing are the properties of an entity that an object must have: - Persistability: An object is called persistent if it is stored in the database and can be accessed anytime. Persistent Identity: In Java, each entity is unique and represents an object identity. Similarly, when the object identity is stored in a database, then it is represented as persistence identity. This object identity is equivalent to the primary key in the database. Transactionality: In Java, each entity is unique and represents an object identity. Similarly, when the object identity is stored in a database, then it is represented as persistence identity. This object identity is equivalent to the primary key in the database. Granularity: Entities should not be primitives, primitive wrappers or built-in objects with single dimensional state.""
What is the role of Entity Manager in JPA?	An entity manager is responsible for the following operations. The entity manager implements the API and encapsulates all of them within a single interface. The entity manager is used to read, delete and write an entity. An object referenced by an entity is managed by entity manager.""
What are the constraints on an entity class?	An entity class must fulfill the following requirements: The class must have a no-argument constructor. The class can't be final. The class must be annotated with @Entity annotation. The class must implement a Serializable interface if value passes an empty instance as a detached object."
What is the purpose of Java collections in JPA?	In JPA, Java collections are used to persist the object of wrapper classes and String.
What type of objects can be stored in the JPA collections mapping?	Following are the type of objects that JPA allows to store: - List - Set - Map
To store multivalued entity associations and a collection of objects, following types of Java collections is used:	List Set Map"
What is the purpose of cascading operations in JPA?	If we apply any task to one entity then using cascading operations, we make it applicable to its related entities also.
What are the types of cascade supported by JPA?	Following is the list of cascade type: - PERSIST: In this cascade operation, if the parent entity is persisted then all its related entity will also be persisted. MERGE: In this cascade operation, if the parent entity is merged, then all its related entity will also be merged. DETACH: In this cascade operation, if the parent entity is detached, then all its related entity will also be detached. REFRESH: In this cascade operation, if the parent entity is refreshed, then all its related entity will also be refreshed. REMOVE: In this cascade operation, if the parent entity is removed, then all its related entity will also be removed. ALL In this case, all the above cascade operations can be applied to the entities related to the parent entity.""
What are the features of JPQL?	Some of the essential features of JPQL are: - It is simple and robust. It is a platform-independent query language. JPQL queries can be declared statically into metadata or can also be dynamically built in code. It can be used with any database such as MySQL, Oracle."
What is the Criteria API?	The Criteria API is a specification that provides type-safe and portable criteria queries written using Java programming language APIs. It is one of the most common ways of constructing queries for entities and their persistent state. It is just an alternative method for defining JPA queries. Criteria API defines a platform-independent criteria queries, written in Java programming language. It was introduced in JPA 2.0. The main purpose behind this is to provide a type-safe way to express a query.