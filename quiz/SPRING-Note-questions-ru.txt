Что такое IoС?	(Inversion if Control) Подход, который позволяет конфигурировать и управлять объектами Java с помощью рефлексии. Фреймворк сам внедряет зависимости с помощью IoC-контейнера. Контейнер отвечает за жизненный цикл объекта: 1) Создание объектов 2) Вызов методов инициализации 3) Конфигурирование объектов, путем связывания их между собой Объекты создаваемые контейнером называются beans. Конфигурация контейнера осуществляется путем внедрения аннотаций или XML-файла.
Что такое DI?	(Dependency Injection) Способ реализации IoC в Spring. Это шаблон проектирования, в котором контейнер передает экземпляры объектов по их типу другим объектам с помощью конструктора или метода класса (setter), что позволяет писать слабосвязный код.
Что такое IoC-контейнер?	В Spring представлен интерфейсом ApplicationContext - обертка над BeanFactory. Предоставляет дополнительные возможности, например AOP и транзакции. Интерфейс BeanFactory предоставляет фабрику для бинов, которая и является IoC-контейнером приложения. Управляет жизненным циклом объекта.
ApplicationContext и BeanFactory	ApplicationContext - это наследник BeanFactory и полностью реализует его функционал, добавляя больше enterprise-функций. Может работать с бинами всех скоупов. BeanFactory - это контейнер, который создает, настраивает и управляет Bean-компонентами. Эти бины взаимодействуют друг с другом, имеют зависимости между собой. Может работать с бинами singleton и prototype. Используется, когда ресурсы ограничены (мобильные устройства). Если сильных ограничений в ресурсах нет, лучше использовать ApplicationContext. ApplicationContext загружает все бины при запуске BeanFactory по требованию.
Отличия ApplicationContext от BeanFactory	
Аннотация @Bean	Используется для того, чтобы указать что метод создает, настраивает, инициализирует новый объект, управляемый IoC-контейнером. Можно использовать в классах с аннотацией @Configuration и @Component (и наследниках). Имеет следующие свойства: 1) destroyMethod / initMethod - переопределение методов инициализации и удаления бина 2) name - имя бина 3) value - алиас для name()
Аннотация @Component	Используется для указания класса в качестве компонента Spring. Класс будет сконфигурирован как Spring бин.
Отличия @Bean от @Component	@Bean - ставится над методом, реализованного сторонней библиотекой класса. @Component - ставится над своим классом.
Аннотации @Service и @Repository	@Repository - используется для работы с данными (поиск, получение, хранение). Может использоваться для реализации шаблона DAO. @Service - указывает, что класс является сервисом для реализации бизнес-логики. @Repository, @Service, @Controller и @Configuration - наследники @Component, также их называют стереотипными аннотациями.
Задача @Repository	Отлавливать определенные исключения персистентности (возможность хранить объекты постоянно) и пробрасывать их как одно непроверяемое исключение Spring Framework. Для этого в контекст должен быть добавлен класс PersistenceExceptionTranslationPostProccessor
Аннотация @Autowired	Автоматическое внедрение подходящего бина: 1) Контейнер определяет тип объекта для внедрения 2) Контейнер ищет соответствующий тип бина в контексте 3) Если есть несколько кандидатов, и один из них помечен аннотацией @Primary, то внедряется он.Если используется @Qualifier, ему отдается приоритет.В противном случае контейнер внедрит бин по его имени или ID.Если ничего выше не сработало - выбросится Exception. Контейнер обрабатывает DI с помощью AutowiredAnnotationBeanPostProcessor. Есть 1 параметр required = true(по умолчанию)/false - указывает, обязательно ли делать DI.
Аннотация @Resource	(Аннотация Java) Пытается получить зависимость в таком порядке: 1) По имени 2) По типу 3) По описанию (Qualifier) Имя извлекается из имени аннотируемого сеттера или поля, либо берется из параметра name.
Отличия @Resource от @Autowired	 Ищет бин сначала по имени, а потом по типу 2) Не нужна дополнительная аннотация для указания имени конкретного бина 3) Не позволяет отметить бин, как необязательный.При переходе на другой Framework, не нужно менять аннотацию
Аннотация @Inject	(Аннотация Java) Входит в пакет javax.inject, для использования необходимо добавить зависимость. Аналог @Autowired - пытается получить зависимость в таком порядке: 1) По типу 2) По описанию 3) По имени В ней нет параметров, поэтому при использовании бина по Id, используем @Named @Inject @Named("someName") private method1()
Аннотация @Lookup	Если нам необходимо внедрить Prototype bean в Singleton bean необходимо использовать специальный метод с аннотацией @Lookup. Внедрение происходит не при инициализации контейнера, а позднее - каждый раз когда вызывается метод. Контейнер Spring под капотом создаст подкласс и переопределит этот метод и будет выдавать каждый раз новый экземпляр Prototype бина. Даже если метод возвращает null, метод все равно будет переопределен контейнером.
Можно ли вставить бин в static поле? Почему?	Spring не позволяет внедрять бины напрямую в статическое поле. Это связано с тем, что когда загрузчик классов загружает статические значения, контекст Spring еще не загружен. Для решения этой проблемы - необходимо создать нестатический setter метод с аннотацией @Autowired
Аннотация @Qualifier	Применяется если кандидатов для автоматического связывания несколько, позволяет указать имя конкретного бина, который следует внедрить. Может быть применена: 1) Полю класса 2) Аргументу метода 3) Аргументу конструктора
Аннотация @Primary	Применяется если кандидатов для автоматического связывания несколько, позволяет отдавать предпочтение бину помеченному этой аннотацией. Нельзя задать имя бина, определяет значение по умолчанию. Если присутствуют аннотации @Qualifier и @Primary, то аннотация @Qualifier будет иметь приоритет.
Как заинжектить примитив?	Для этого можно использовать аннотацию @Value. Где можно ее ставить: 1) Над полем 2) Над конструктором 3) Над методом @Value("${some.key}") public String stringWithDefaultValue; Такие значения можно получать например из property-файлов, бинов и тд. (Кроме того, для внедрения значений мы можем использовать язык SpEL (Spring Expression Language))
Аннотация @Conditional	Предоставляет возможность на основе нашего алгоритма (условия) включать или выключать определение бина или всей конфигурации. В качестве параметра указывается класс (ы), реализующий интерфейс Condition, с единственным методом matches(), возвращающий boolean (в этот методе прописываем нужное нам условие). Условие проверяются перед BeanDefenition компонента. Нельзя допускать, чтобы при проверке условий мы взаимодействовали с бинами, которых еще нет. Если класс @Configuration помечен @Conditional, то на все методы @Bean, аннотации @Import, @ComponentScan будут распространяться эти условия.
Аннотация @Profile	Позволяет нам относить наши бины к разным профилям (логическим группам), например, Dev, Test, Prod. Мы можем активировать разные профили в разных средах, чтобы загрузить только те бины, которые нам нужны.Ее можно применять на уровне класса или метода.Принимает в качестве аргумента имя одного или нескольких профилей.Ее можно ставить на @Configuration и @Component классы (Фактически реализована на @Conditional)
Аннотация @ComponentScan	Используется для указания пакетов, которые мы хотим сканировать на наличие компонентов, из которых нужно сделать бины. Используется вместе с аннотацией @Configuration. Без аргументов сканирует текущий пакет. Если указать с атрибутом exludeFilters, то это позволит использовать фильтр и исключать ненужные классы из процесса сканирования.
Жизненный цикл бинов	 Парсирование конфигурации и создание BeanDefinition 2) Настройка созданных BeanDifinition 3) Создание кастомных FactoryBean (только для XML-конфигурации) 4) Создание экземпляров бинов 5) Настройка созданных бинов 6) Бины готовы к использованию 7) Закрытие контекста
Способы конфигурации контекста	 XML-конфигурация 2) Через аннотации с указанием пакета сканирования 3) Через аннотацию с указанием класса (или массива классов) 4) Groovy конфигурация
Парсирование конфигурации и создание BeanDefinition	Объект BeanDefinition - это набор метаданных будущего бина, макет, по которому нужно будет создавать бин. BeanDefinition содержит следующие метаданные: 1) Имя класса с указанием пакета 2) Элементы поведенческой конфигурации бина (scope, обратные вызовы ЖЦ и тд.) 3) Зависимости 4) Другие параметры конфигурации для установки в новом бине (размер пула, кол-во соединений и тд.) При конфигурации через аннотации используется класс AnnotationConfigApplicationContext. Регистрируются все классы с @Configuration, затем регистрируется BeanDefinitionRegistryPostProcessor, который при помощи класса ConfigurationClassParser парсирует JavaConfig, загружает описания бинов, создает граф зависимостей между бинами и создает: Map<String, BeanDefinition> bD = new ConcurrentHashMap<>(256); в которой хранятся все описания бинов, обнаруженных в ходе парсинга конфигурации.
Настройка созданных BeanDefinition	После первого этапа у нас имеется коллекция Map, в которой хранятся BeanDefinition-ы. Для того чтобы повлиять на бины до их создания, существует специальный интерфейс BeanFactoryPostProcessor, реализовав который мы получаем доступ к BeanDefinition и можем их и изменять. В нем один метод postProcessBeanFactory(ConfigurableListableBeanFactory). Данная фабрика содержит много полезных методов, например, getBeanDefinitionNames, через который можем получить имена всех бинов, а уже потом по конкретному имени получить BeanDefinition. Часто используется для того, чтобы заинжектить значение из property-файла до создания экземпляра бина.
Создание кастомных FactoryBean	(XML-конфигурация) FactoryBean - это generic интерфейс, которому можно делегировать процесс создания бинов. Для тех кто использует JavaConfig, этот интерфейс абсолютно бесполезен.
Создание экземпляров бинов	Сначала BeanFactory достает из коллекции Map объекты BeanDefinition, из которых создает BeanPostProcessor-ы необходимые для настройки обычных бинов. Потом создаются экземпляры бинов через BeanFactory на основе ранее созданных BeanDefinition. Класс и имплементирующий BeanPostProcessor, обязательно должен быть бином, поэтому мы его помечаем аннотацией @Component. Если SCOPE_PROTOTYPE - бин будет проходить через все BeanPostProcessor-ы, что ударит по производительности.
Настройка созданных бинов	На данном этапе бины уже созданы, мы можем их лишь донастроить. Интерфейс BeanPostProcessor позволяет вклиниться в процесс настройки наших бинов, до того как они попадут в контейнер. ApplicationContext автоматически обнаруживает любые бины с реализацией BeanPostProcessor и помечает их как "post-processors". Интерефейс несет в себе 2 метода - postProcessBeforeInitialization(Object bean, String beanName) и postProcessAfterInitialization. Перый вызывается до init-метода, второй после.
Что такое прокси в Spring?	Это класс-декорация над бином. Например, мы хотим добавить логику нашему бину, но джава-код уже скомпилирован, поэтому нам нужно на лету сгенерировать новый класс. Есть 2 варианта создания этого класса: 1) Должен наследоваться от оригинального класса и предопределить его методы, добавляя нужную логику 2) Должен имплементировать те же самые интерфейсы, что и первый класс (Dynamic Proxy)
Бины готовы к использованию	Их можно получить с помощью метода ApplicationContext#getBean()
Закрытие контекста	 Когда контекст закрывается (метод сlose() из ApplicationContext), бин уничтожается.Если в бине есть метод аннотированный @PreDestroy, то перед уничтожением вызовется это метод 3) Если бин имплементирует DisposibleBean, то Spring вызовет метод destroy() - не рекомендуется к использованию, устаревший 4) Если в аннотации @Bean определен метод destroyMethod, то будет вызван и он.
Аннотация @PostConstruct	Spring вызывает методы, аннотированные этой аннотацией только один раз, сразу после инициализации свойств компонента. Метод, с этой аннотацией: 1) Может иметь любой тип доступа 2) Может иметь любой тип возвращаемого значения (хотя это игнорируется спрингом) 3) Не должен принимать аргументы 4) Может быть static, но преимуществ от этого мало Как пример его можно использовать для заполнением БД значениями по умолчанию
Аннотация @PreDestroy	Spring вызывает методы, аннотированные этой аннотацией только один раз, перед тем, как Spring удаляет наш компонент из контекста. Такие методы не могут быть static! Целью этого метода, является освобождение ресурсов или выполнение любых задач очистки до уничтожения бина. Например закрытие соединения с БД. С Java 11, необходимо добавить дополнительную зависимость для использования @PostConstruct и @PreDestroy javax.annotation
Scopes бинов	Spring Framework поддерживает 6 scopes: 1) Singleton - default scope. Будет создан только один бин.Prototype - новый бин каждый раз при запросе.Request - новый экземпляр для каждого HTTP-запроса 4) Session - один экземпляр для HTTP-сессии 5) Application - один на жизненный цикл "ServletContext" 6) Websocket - один для сеанса WebSocket 7) не активированный по умолчанию Custom thread scope - его можно активировать. Один на каждый поток. С 3 по 6 доступны только в веб-приложениях. Мы так же можем создать свой собственный Scope. В Spring 5 не стало Global session scope
Что такое АОП?	Аспектно-ориентированное программирование - это повышение модульности за счет разделения междисциплинарных задач. Это достигается путем добавления дополнительного поведения объекта к существующему коду, без изменения самого кода. Подход заключается в "динамическом прокси"
Аннотация @Transactional	Нужна для работы с транзакциями с использованием AOP-прокси Параметры: 1) REQUIRED - по умолчанию, при входе в метод будет использована уже существующая транзакция или создана новая.REQUIRES_NEW - всегда создается новая транзакция при входе в метод. Ранее созданные транзакции приостанавливаются до окончания метода.NESTED - корректно работает только с БД, которые умеют savepoints. При входе в метод в уже существующую транзакцию добавляет savepoint, который будет либо сохранен либо откачен. Все изменения подтвердятся только с подтверждением всей транзакции. Если транзакции нет - будет создана новая.MANDATORY - всегда используется существующая транзакция, exception если транзакции нет.SUPPORTS - будет использовать текущую транзакцию, если она есть, без транзакции если ее нет 6) NOT_SUPPORTED - при входе в метод текущая транзакция, если она есть, будет приостановлена и будет выполняться без транзакции.NEVER - запрещает использовать в контексте транзакции. При наличии транзакции exception.
Остальные атрибуты @Transactional	 rollbackFor = Exception.class - если метод выбрасывает указанно исключение, контейнер всегда откатывает текущую транзакцию 2) noRollbackFor = Exception.class - указание того, что любое исключение, кроме указанного должно приводить к откату 3) rollbackForClassName и noRollbackForClassName - для задания имен исключений в строковом виде 4) readOnly - разрешает только операции чтения 5) timeOut - по умолчанию используется таймаут, установленный для базовой транзакционной системы. Установка времени максимального простоя транзакции перед откатом неотвечающих транзакций.isolation - уровень изолированности транзакций.
Как включить транзакции в Spring?	Для включения возможности управления транзакциями нужно разместить аннотацию @EnableTransactionManagment у класса конфигурации. Она означает что классы, помеченные @Transactional, должны быть обернуты аспектом транзакций. Отвечает за регистрацию компонентов, таких как TransactionInterceptor и советы прокси. Если мы использует Boot и имеем зависимости spring-data-* или spring-tx, то управление транзакциями будет включено автоматически. Слой логики Service - лучшее место для @Transactional
Что происходит при вызове метода save() при включённых транзакциях?	 Вводные данные 2) TransactionInterceptor 3) TransactionManager 4) EntityManagerProxy 5) Отрабатывает DAO-метод save() 6) TransactionInterceptor
Вводные данные	a) класс TransactionInterceptor, у которого вызывается метод invoke(). Внутри вызывается метод класса родителя b) TransactionManager решает создавать ли новый EntityManager и/или транзакцию c) EntityManager proxy перехватывает обращение к полю EntityManager и делегирует выполнение конкретному EntityManager в рантайме.
TransactionInterceptor	Отрабатывает код до метода save(), в котором будет определено, выполнить ли метод в пределах существующей транзакции или должна стартовать новая отдельная. Сам TransactionInterceptor не содержит логики, делегирует TransactionManager.
TransactionManager	Должен предоставить ответ на 2 вопроса: a) Должен ли создаваться новый EntityManager? b) Должна ли стартовать новая транзакция? Решение принимается, основываясь на следующих фактах: a) выполняется ли хоть одна транзакция в текущий момент или нет b) атрибута "propagation" в @Transactional Если TransactionManager решил создавать новую транзакцию, тогда: a) Создается новый EntityManager b) EntityManager "привязывается" к текущему потоку c) "Получается" соединение из пула соединений БД d) Соединение привязывается к текущему потоку
EntityManagerProxy	Когда метод save() слоя Service вызывает save() слоя DAO, не происходит вызова метода persist() напрямую у EntityManager. Вместо этого proxy достает текущий EntityManager для нашего потока и у него уже вызывается метод persist().
TransactionInterceptor	Отрабатывает код после работы метода save(), а именно принято решение по коммиту/откату транзакции. Кроме того, если мы в рамках одного метода сервиса обращаемся не только к методу save(), а к разным методам Service и DAO, то все они будут работать в рамках одной транзакции.
Аннотации @Controller и @RestController	@Controller - обрабатывает HTTP-запросы и часто используется с аннотацией @RequestMapping. Это дочерняя аннотация @Component и позволяет автоматически определять классы при сканировании пакетов. @RestController - была введена в Spring 4 для упрощения создания RESTful веб-сервисов. Она объединяет в себе @Controller и @ResponseBody. @ResponseBody сообщает контроллеру, что возвращаемый объект автоматически стерилизуется в JSON или XML и передается обратно в объект HttpResponse. Класс ResponseEntity используется для формирования ответа HTTP с пользовательскими параметрами. Чтобы вернуть свой код ответа: return ResponseEntity.status(213);
Что такое ViewResolver?	Способ работы с представлениями в Spring. Сопоставляет имена представлений, возвращаемых методами контроллеров, с фактическими представлениями в html-файлах. По умолчанию реализаций интерфейса ViewResolver является класс InternalResourceViewResolver
Чем отличается Model, ModelMap и ModelAndView?	Model - это интерфейс, предоставляет коллекцию пар ключ-значение Map<String, Object>. Содержимое Model используется для отображения данных во View. Объекты-значения из модели могут содержать бизнес-логику. ModelMap - класс, наследуется от LinckedHashMap, тоже используется для передачи значений для визуализации представлений. Дает нам возможность передавать коллекцию значений и обрабатывать эти значения, как если бы они были внутри Map. ModelAndView - контейнер для ModelMap, объект View и HttpStatus. Это позволяет контроллеру возвращать все значения как одно.
Паттерн FrontController	Обеспечивает единую точку входа для всех входящих запросов. Все запросы обрабатываются одним обработчиком - DispatcherServlet с маппингом "/". Этот обработчик может выполнять аутентификацию, авторизацию, регистрацию или отслеживание запроса, а затем распределяет их между контроллерами, обрабатывающими разные URL. Веб-приложение может определять любое кол-во DispatcherServlet-ов.Один из контекстов будет корневым, а все остальные будут дочерними 2) Дочерние контексты имеют доступ к бинам определенным в корневом контексте, но не наоборот 3) Дочерний контекст может переопределить бины из корневого контекста WebApplicationContext - расширяет ApplicationContext ContextLoaderListener - создает корневой контекст приложения
Паттерн MVC	Это шаблон проектирования, делящий программу на 3 вида компонентов. Model - отвечает за хранение данных View - вывод данных на фронте Controller - обмен данными model с view Spring MVC - это Фреймворк, основанный на Servlet API, с использованием Front Controller и MVC.
Основные интерфейсы MVC	 DispatcherServlet - главный контроллер, получает запросы и распределяет их между другими контроллерами. @RequestMapping указывает, какие именно запросы будут обрабатываться в конкретном контроллере.HandlerMapping - выбор класса или метода на основе внутреннего или внешнего состояния, для обработки входящего запроса.Controller - оперирует моделями и отвечает за обмен данными model с View.ViewResolver - выбор, какое именно View должно быть показано на основе имени, полученного с контроллера.View - фронт 6) HandlerAdapter - помогает DispatcherSerlvlet вызывать и выполнять метод для обработки входящего запроса 7) ContextLoaderListener - связывание жизненного цикла ApplicationContext и ServletContext
Последовательность событий MVC	 После получения HTTP-запроса DispatcherServlet обращается к интерфейсу HandlerMapping, который определяет Контроллер 2) Контроллер принимает запрос и вызывает соответствующий метод. Вызванный метод формирует данные Model и возвращает их в DispatcherServlet вместе с именем View (как правило имя html-файла) 3) При помощи интерфейса ViewResolver DispatcherServlet определяет, какое View нужно использовать на основании имени, полученного от контроллера. a) если это REST-запрос на сырые данные (JSON/XML), то DispatcherServlet сам его отправляет, минуя ViewResolver; b) если обычный запрос, то DispatcherServlet отправляет данные Model в виде атрибутов во View - шаблонизаторы Thymeleaf, FreeMarker и т.д., которые сами отправляют ответ. Как видим, все действия происходят через один DispatcherServlet.
Filter	Это интерфейс из пакета javax.servlet, имплементации которого выполняют задачи фильтрации либо по пути запроса к ресурсу (сервлету, либо по статическому контенту), либо по пути ответа от ресурса, либо в обоих направлениях. Фильтры выполняют фильтрацию в методе doFilter. Каждый фильтр имеет доступ к объекту FilterConfig, из которого он может получить параметры инициализации, и ссылку на ServletContext. Фильтры настраиваются в дескрипторе развертывания веб-приложения. В веб-приложении мы можем написать несколько фильтров, которые вместе называются цепочкой фильтров. Веб-сервер решает, какой фильтр вызывать первым, в соответствии с порядком регистрации фильтров.
Interceptor 	похож на фильтр, который используется для перехвата запросов и их обработки. Spring MVC позволяет перехватывать веб-запросы для предварительной и последующей обработки с помощью обработчиков-перехватчиков. Все классы перехватчиков должны либо реализовывать интерфейс HandlerInterceptor, либо расширять класс HandlerInterceptorAdapter.
Listener	Это класс, имплементирующий интерфейс ServletContextListener с аннотацией @WebListener. Listener ждет когда произойдет указанное событие, затем «перехватывает» событие и запускает собственное событие. Он инициализируется только один раз при запуске веб-приложения и уничтожается при остановке веб-приложения. Все ServletContextListeners уведомляются об инициализации контекста до инициализации любых фильтров или сервлетов в вебприложении и об уничтожении контекста после того, как все сервлеты и фильтры уничтожены.
Как работает Spring Security? (вкратце)	 SecurityContextHolder, чтобы обеспечить доступ к SecurityContext.SecurityContext, содержит объект Authentication и в случае необходимости информацию системы безопасности, связанную с запросом.Authentication представляет принципала с точки зрения Spring Security.GrantedAuthority отражает разрешения выданные доверителю в масштабе всего приложения.UserDetails предоставляет необходимую информацию для построения объекта Authentication из DAO объектов приложения или других источника данных системы безопасности.UserDetailsService, чтобы создать UserDetails, когда передано имя пользователя в виде String (или идентификатор сертификата или что-то подобное).
Как работает Spring Security?	Самым фундаментальным явлется SecurityContextHolder. В нем мы храним информацию о текущем контексте безопасности приложения, который включает в себя подробную информацию о пользователе, работающем с приложением. По умолчанию SecurityContextHolder использует MODE_THREADLOCAL для хранения такой информации, что означает, что контекст безопасности всегда доступен для методов исполняющихся в том же самом потоке, даже если контекст безопасности явно не передается в качестве аргумента этих методов: SecurityContextHolder.getContext().getAuthentication().getPrincipal(); UserDetails выступает в качестве принципала. MODE_GLOBAL - все потоки Java-машины используют один контекст безопасности. MODE_INHERITABLETHREADLOCAL - потоки порожденные от одного защищенного потока, наличие аналогичной безопасности. Интерфейс UserDetailsService - подход к загрузке информации о пользователе в Spring Security. Единственный метод этого интерфейса принимает имя пользователя в виде String и возвращает UserDetails. В случае успешной аутентификации, UserDetails используется для создания Authentication объекта, который хранится в SecurityContextHolder. Ещё одним важным методом Authentication явлется getAuthorities() - предоставляет массив объектов GrantedAuthority(роли). Credentials - под ними понимаются пароль пользователя, но им может быть и отпечаток пальца, фото сетчатки и т.п.
Процесс аутентификации	1. UsernamePasswordAuthenticationFilter получают имя пользователя и пароль и создает экземпляр класса UsernamePasswordAuthenticationToken (экземпляр интерфейса Authentication). 2. Токен передается экземпляру AuthenticationManager для проверки. 3. AuthenticationManager возвращает полностью заполненный экземпляр Authentication в случае успешной аутентификации. 4. Устанавливается контекст безопасности путем вызова SecurityContextHolder.getContext().setAuthentication(...), куда передается вернувшийся экземпляр Authentication. 5. При успешной аутентификации можно использовать successHandler
Что такое SpringBoot?	Это модуль Spring-а, который предоставляет функцию RAD для среды Spring (Rapid Application Development - Быстрая разработка приложений). Он обеспечивает более простой и быстрый способ настройки и запуска как обычных, так и веб-приложений. Он просматривает наши пути к классам и настроенные нами бины, делает разумные предположения о том, чего нам не хватает, и добавляет эти элементы.
Ключевые особенности и преимущества Spring Boot	1. Простота управления зависимостями (spring-boot-starter-* в pom.xml). Starter-пакеты представляют собой набор удобных дескрипторов зависимостей, которые можно включить в свое приложение. Это позволяет получить универсальное решение для всех технологий, связанных со Spring, избавляя программиста от лишнего поиска необходимых зависимостей. 2. Автоматическая конфигурация. Автоматическая конфигурация включается аннотацией @EnableAutoConfiguration. (входит в состав аннотации @SpringBootApplication) 3. Встроенная поддержка сервера приложений/контейнера сервлетов (Tomcat, Jetty). Каждое Spring Boot web-приложение включает встроенный web-сервер. Не нужно беспокоиться о настройке контейнера сервлетов и развертывания приложения в нем. Теперь приложение может запускаться само как исполняемый .jar-файл с использованием встроенного сервера. 4. Готовые к работе функции, такие как метрики, проверки работоспособности, security и внешняя конфигурация. 5. Инструмент CLI (command-line interface) для разработки и тестирования приложения Spring Boot. 6. Минимизация boilerplate кода (код, который должен быть включен во многих местах практически без изменений), конфигурации XML и аннотаций.
Как происходит автоконфигурация в Spring Boot?	1. Отмечаем main класс аннотацией @SpringBootApplication (аннотация инкапсулирует в себе: @SpringBootConfiguration, @ComponentScan, @EnableAutoConfiguration), таким образом наличие @SpringBootApplication включает сканирование компонентов, автоконфигурацию и показывает разным компонентам Spring (например, интеграционным тестам), что это Spring Boot приложение. 2. @EnableAutoConfiguration импортирует класс EnableAutoConfigurationImportSelector. Этот класс не объявляет бины сам, а использует фабрики. 3. Класс EnableAutoConfigurationImportSelector импортирует ВСЕ (более 150) перечисленные в META-INF/spring.factories конфигурации, чтобы предоставить нужные бины в контекст приложения. 4. Каждая из этих конфигураций пытается сконфигурировать различные аспекты приложения (web, JPA, AMQP и т.д.), регистрируя нужные бины. Логика при регистрации бинов управляется набором @ConditionalOn* аннотаций. 5. Созданный в итоге AnnotationConfigEmbeddedWebApplicationContext ищет в том же DI контейнере фабрику для запуска embedded servlet container. 6. Servlet container запускается, приложение готово к работе
Нововведения Spring 5	 Используется JDK 8+ (Optional, CompletableFuture, Time API, java.util.function, default methods)  Поддержка Java 9 (Automatic-Module-Name in 5.0, module-info in 6.0+, ASM 6)  Поддержка HTTP/2 (TLS, Push), NIO/NIO.2  Поддержка Kotlin  Реактивность (веб-инфраструктура с реактивным стеком, «Spring WebFlux»)  Null-safety аннотации(@Nullable), новая документация  Совместимость с Java EE 8 (Servlet 4.0, Bean Validation 2.0, JPA 2.2, JSON Binding API 1.0)  Поддержка JUnit 5 + Testing Improvements (conditional and concurrent)  Удалена поддержка: Portlet, Velocity, JasperReports, XMLBeans, JDO, Guava
Что такое ORM? Что такое JPA? Что такое Hibernate?	ORM - Object Relational Mapping - это концепция преобразования данных из реляционных БД в объектно-ориентированный язык и наоборот.
Что такое EntityManager? Какие функции он выполняет?	Интерфейс JPA, который описывает API для операций над Entity (сущность), а также для получения данных из других сущностей JPA. EntityManager не потокобезопасен! Основные операции: 1. над Entity - merge - обновление - remove - удалить - refresh - обновление данных - detach - удаление из управления JPA - lock - блокировать от изменений в других потоках 2. Получение данных (createQuery, createNamedQuery, contains) 3. Получение других сущностей JPA (getTransaction, getEntityManagerFactory) 4. Работа с EntityGraph 5. Общие операции над EntityManager (close, clear, isOpen, getProperties, setProperty)
Каким условиям должен удовлетворять класс чтобы являться Entity?	Entity - объект бизнес-логики, основная программная сущность. 1. анотация Entity или отметка в XML 2. public или protected конструктор без аргументов 3. не вложенный 4. не enum, не интерфейс 5. не финальный 6. без финальных полей и методов, участвующих в маппинге 7. При передаче экземпляра по значению нужна реализация serializable 8. Поля доступны только методам самого Entity 9. Наличие PRIMARY KEY
Может ли абстрактный класс быть Entity?	Может, но его нельзя инициализировать.
Что такое встраиваемый (Embeddable) класс? Какие требования JPA устанавливает к встраиваемым (Embeddable) классам?	Это класс, который является частью Entity и не используется сам по себе. - Entity-класс может содержать такие встроенные классы, коллекции, - Может использоваться как значения и ключи в map - Принадлежит одному объекту Entity и не может служить для передачи данных - Служит для вынесения общих атрибутов для нескольких Entity - Должны удовлетворять правилам Entity, кроме Primary Key - вместо аннотации @Entity используется @Embedeble, и @Embedded в поле Entity-класса или в XML - Может содержать другой встраиваемый класс - Может содержать связи с другими Entity если он не является первичным ключом
Что такое Mapped Superclass?	Класс, от которого наследуется Entity, определяет ряд свойств и методов для сущностей наследников. - может содержать аннотации JPA - Не является Entity и не реализует правила Entity - Не используется в EntityManager или Query - Помечен аннотацией @MappedSuperclass или в XML
Какие три типы стратегии наследования мапинга (Inheritance Mapping Strategies) описаны в JPA?	Стратегии наследования: 1. Одна таблица (SINGLE_TABLE) на всю иерархию. В эту таблицу помещаются все классы и наследники и потомки, их тип указывается в специальном столбце, уникальные поля для наследников помещаются в отдельную колонку. 2. "Соединения" (JOINED) каждый класс имеет собственную таблицу, в которой содержаться только уникальные поля и первичный ключ. Общие унаследованные поля содержаться в таблице класса-предка. Требует ресурсы на Join. 3. Таблица для каждого класса (TABLE_PER_CLASS) - каждый класс имеет свою таблицу. Из минусов - плохая поддержка полиморфизма, для выборки всех наследников потребуется Union для множества таблиц.
Как мапятся Enumы?	@Enumerated (EnumType.STRING) - в БД хранятся имена Enum @Enumerated(EnumType.ORDINAL) - хранятся порядковые номера Смапить через методы с аннотациями @PostLoad и @PrePersist. В @EntityListener указывается класс реализующий эти методы. Само поле с enum помечается @Transient, а значение в БД будет помещаться из вспомогательного поля. Через реализацию AttributeConverter и аннотацию @Converter, где Enum будет переводиться в некое значение. Для поля с Enum предусмотрена аннотация @Convert
Как мапятся даты (до java 8 и после)?	До - @Temporal в которой указывается тип даты, после - автоматически
Как "смапить" коллекцию примитивов?	Для коллекций с сущностями используется связь @OneToMany / @ManyToOne. В случае коллекции примитивов и прочих не Entity используется @Element collection, которая создаёт в БД отдельную таблицу с записями коллекции. При добавлении записи в коллекцию таблица очищается и заполняется заново из-за отсутствия ID. Решается с помощью @OrderColumn.
Какие есть виды связей?	@OneToMany - один экземпляр связан со многими других @ManyToOne - множество экземпляров связана с одним @ManyToMany - множество экземпляров ко множеству @OneToOne - один экземпляр к одному Bidirectional - связь указывается у обоих классов Undirectional - связь только с одной стороны
Что такое владелец связи?	Это сущность внутри которой содержится внешний ключ на связанную сущность. При односторонней связи владелец связи автоматически - класс в котором она указана.
Что такое каскады?	Это правила для автоматического применения действий к связанным сущностям, при их применении к целевой: ALL - все персистентные события будут переданы дочернему объекту PERSIST - операции save() и persist() передаются по каскаду дочерним объектам MERGE - когда объединяется владелец - связанные Entity тоже объединяются REMOVE - удаляет все Entity связанные с удаляемой DETACH - отключает связанные Entity при ручном отключении REFRESH - повторно считывают значения данного экземпляра и связанных сущностей при вызове refresh()
Какие два типа fetch стратегии в JPA вы знаете?	LAZY - возможность загружать данные только при первом вызове. По умолчанию для @OneToMany @ManyToMany EAGER - данные загружаются сразу. Автоматически применен к @OneToOne @ManyToOne @Basic
Какие четыре статуса жизненного цикла Entity объекта (Entity Instance's Life Cycle) вы можете перечислить?	transient (new) - созданная с помощью new() сущность, которая не имеет связи с БД и PRIMARY KEY managed - создан, сохранен, имеет PRIMARY KEY, управляется JPA detached - создан но не управляется JPA, сущность отделена от контекста и нет управляющего экземпляра Session removed - объект создан, управляется JPA но при коммите станет detached
Как влияет операция persist на Entity объекты каждого из четырех статусов?	transient (new) -> managed, сохранится в БД при коммите или при flush managed - игнорируется, может быть применена по каскаду к зависимым классам detached - exception removed -> managed в рамках транзакции
Как влияет операция remove на Entity объекты каждого из четырех статусов?	transient (new) - игнорируется, может быть применена по каскаду managed -> removed, при коммите данные будут удалены, также по каскаду detached - exception removed - игнорируется
Как влияет операция merge на Entity объекты каждого из четырех статусов?	transient (new) - создается новый managed entity в который будут скопированы данные из прошлого объекта managed - игнорируется, применяется по каскаду detached - копируются в существующий managed entity с тем же первичным ключом или создается новый managed entity removed - exception
Как влияет операция refresh на Entity объекты каждого из четырех статусов?	managed - восстановление изменений из БД + по каскаду для остальных - exception
Как влияет операция detach на Entity объекты каждого из четырех статусов?	managed, removed -> detached остальные - игнор
Для чего нужна аннотация Basic?	Указывает на простейший тип маппинга данных на колонку таблицы базы данных, указывается по умолчанию, но в параметрах можно указать fetch и optional (может ли поле быть null) применяется к: - String, BigInteger, BigDecimal - Date, Calendar, sql.Date, sql.Time, sql.Timestamp -byte[] (Byte[]), char[] (Character[]) - enum - типы, реализующие Serializable
Для чего нужна аннотация Column?	Сопоставляет поле класса и колонку в таблице, используется для генерации схемы БД, атрибуты определяют поведение в столбце - атрибуты применяются к столбцам БД - nullable указывает может ли столбец быть null - позволяет указать имя столбца, разрешить или запретить удалять и добавлять данные в колонку, длину строковых типов
Для чего нужна аннотация Access?	Определяет тип доступа для JPA к Entity, суперклассу, embeddable или к отдельным атрибутам, имеющие геттеры/сеттеры. Типы доступа: Field - как к полям класса Property - доступ как к свойствам класса Если аннотации Access нету, то тип доступа определяется с помощью места, в котором находиться @Id, над полем - FIELD, над геттером PROPERTY. Аннотация наследуется.
Для чего нужна аннотация Cacheable?	Определяет, может ли сущность храниться в кеше второго уровня. Первый уровень кэша - кэш сессии, кэш второго уровня привязан к EntityManagerFactory. -можно дополнить вариантами кэша-
Для чего нужны аннотации @Embedded и @Embeddable?	@Embeddable - помечает встраиваемый класс @Embedded - помечает поле в Entity, которое является встраиваемым классом
Как смапить составной ключ?	Есть два пути: 1. Создать отдельный класс, имплементирующий serializable и объявить в нем поля, которые будут частями составного ключа. Далее использовать аннотацию @IdClass(имя_класса_с_ID.Class) для Entity класса, и объявить в нем поля помеченные @Id с такими же именами, что и в обычном классе. 2. Во втором случае мы создаем отдельный класс с аннотацией @Embeddeble, реализующий serializable, объявляем в нем поля составного ключа, у него не должно быть зависимостей от других сущностей, но должны быть определены hashcode() и equals(). Затем встраиваем этот класс как поле в Enitity, и прописываем аннотацию @EmbeddebleId
Для чего нужна аннотация ID? Какие @GeneratedValue вы знаете?	Для определения первичного ключа, состоящего из одного поля. Применима для: - примитивов и оберток - строк - BigDecimal и BigInteger - Date (sql и util) Для автоматической генерации ключа используется @GeneratedValue, варианты: AUTO(default) - стратегия будет выбрана автоматически исходя из конкретной БД, учитывая диалект и из типа поля ID. Как правило это Sequence. IDENTITY - автоматически увеличивающейся столбец БД и позволяет генерировать значение для каждой операции вставки. Наиболее простой в использовании, но проигрывает по производительности, в частности потому что инсерт происходит до персиста, и мешает методам оптимизации. SEQUENCE - рекомендуемая стратегия, использует SELECT для генерации ID, но это не влияет на производительность TABLE - редкая стратегия, использующая моделирование последовательности в таблице в БД. Такой подход требует последовательное выполнение транзакций, что не очень удобно и замедляет работу.
Расскажите про аннотации @JoinColumn и @JoinTable? Где и для чего они используются?	@JoinColumn указывает на столбец, содержащий foreign key. Независимо от места указания аннотации столбец появиться у владельца связи. @JoinColumns используется для составного ключа. @JoinTable указывает на третью сводную таблицу, которая обеспечивает связь между двумя таблицами.
Для чего нужны аннотации @OrderBy и @OrderColumn, чем они отличаются?	@OrderBy - аннотация, которая позволяет определить порядок, в котором будут располагаться элементы коллекции при вызове из БД. Важно понимать, что при выведении элементов из кэша порядок не будет обеспечен, так как аннотация по сути добавляет к SQL запросу ключевое слово Order By. Для сортировки по сущности необходимо указать их поле, по которому будет происходить сортировка. По умолчанию упорядочивается по первичному ключу. @OrderColumn - создает столбец с индексами порядка элементов, поддерживает постоянный порядок в списке. Главное их отличие, что первая аннотация работает во время выполнения запроса, а вторая при любой операции вставки, обновлении, удалении.
Для чего нужна аннотация Transient?	@Transient - указывает на поле, которое не будет сохраняться в БД. К ним также относятся static и final поля сущностей. Остальные поля считаются Persistant.
Какие шесть видов блокировок (lock) описаны в спецификации JPA (или какие есть значения у enum LockModeType в JPA)?	NONE - без блокировки OPTIMISTIC - оптимистичное блокирование OPTIMISTIC_FORCE_INCREMENT - оптимистичное блокирование, при каждом коммите значение версии инкрементируется принудительно PESSIMISTIC_READ - данные блокируются в момент чтения, и никто не сможет их изменить в момент транзакции, но будет иметь возможность читать эти данные. PESSIMISTIC_WRITE - в момент транзакции никто не сможет читать и писать заблокированные данные. PESSIMSTIC_FORCE_INCREMENT - ведет себя как PESSIMISTIC_WRITE, но в конце транзакции увеличивает @Version, даже если сущность не изменилась. Оптимистичное блокирование предполагает, что параллельные транзакции редко обращаются к одним и тем же данным. После завершения транзакций проводиться проверка @Version, изменялась ли версия кем либо еще, если да - то выбрасывается @OptimisticLockException Пессимистичное блокирование предполагает что параллельные транзакции часто обращаются к одним и тем же данным, для предотвращения ошибок транзакция блокирует доступ к данным с которыми она работает, для записи или для записи и чтения. Ставятся методом lock() у EntityManager.
2. second-level cache	- кэширует данные от одной фабрики сессий. Провайдер не обязан реализовывать работу с ним. Доступен сразу в нескольких сессиях. Требует настройки. 3. Кэш запросов QueryCache для работы с которым требуется настроить XML файл и для конкретного запроса определить такую возможность
Как работать с кешем 2 уровня?	Кэш второго уровня привязан к EntityManagerFactory. Загрузка из него происходит только в том случае, если нужный объект не был найден в кэше первого уровня. Hibernate использует Java JCahse, Ehcache и Infinispan. Для того чтобы использовать кэширование второго уровня необходимо его настроить, во первых сделать объекты доступным для кэширования и использовать @Cashable. Затем следует прописать в аннотации @Cashe стратегию кэширования: ALL - все могут кэшироваться NONE - отключено для всех ENABLE_SLECTIVE - только для Cashable(true) DISABLE_SELECTIVE - для всех, кроме Cashable(false) UNSPECIFIED - провайдер использует значение по умолчанию. Затем необходимо выбрать стратегию параллельного доступа. Для работы с кэшем второго уровня используются методы: save(), update(), saveOrUpdate(), load(), get(), list(), iterate(), scroll() flush() используется для синхронизации кэша с базой данных.
Что такое JPQL/HQL и чем он отличается от SQL?	JPQL - Java Persistance Query Language HQL - Hibernate Query Language - языки запросов. Они оба похожи на SQL а между собой еще больше. Главное их отличие от SQL в том что - sql оперирует именами таблиц их столбцами а HQL/JPQL именами сущностей и их полями, атрибутами. По этому эти языки запросов являются объектно-ориентированными. Также в JPQL есть автоматический полиморфизм.
Что такое Criteria API и для чего он используется?	Это актуальный API используемый для выборки сущностей из БД в объектно-ориентированном стиле. Применяется для более удобного: - извлечения данных из определенных колонок - для join запросов с несколькими таблицами - получения выборки результатов по условию - применения сортировки к результату - использования агрегатных функций Из преимуществ: + ошибки обнаруживаются во время компиляции + динамически формировать запросы в Runtime Из недостатков - влияет на производительность - сложно отловить ошибку в запросе
Расскажите про проблему N+1 Select и путях ее решения.	Это проблема оптимизации запросов к БД, возникает когда вместо одного запроса к БД данные получаются за N-ое кол-во дополнительных запросов, таким образом выходит N+1.Решается с помощью: 1. Join Fetch - используется для простых запросов до 3 уровней вложенности. 2. EntityGraph - для большого кол-ва данных 3. FetchMode.SUBSELECT - толькко для коллекций, один запрос для корневых сущностей е еще один для ленивых полей-коллекций, для получения связанных коллекций. 4. Batch fetching - только для hibernate, указывается над полем с ленивой загрузкой или над коллекцией с ленивой загрузкой. 5. HibernateSpecificMapping и SqlResultSetMapping - подходит для нативных запросов.
Что такое EntityGraph? Как и для чего их использовать?	Механизм динамического изменения fetchType для аннотированных NamedEntityGraph Entity.fetchgraph меняет все атрибут перечисленные в EntityGraph на EAGER а все остальные на LAZY loadgraph меняет только перечисленные атрибуты на EAGER, а все остальные не трогает.
Какие два вида кэшей (cache) вы знаете в JPA и для чего они нужны?	1. first-level cashe - кеширует данные одной транзакции, является обязательным (это и есть PersistenceContext). - используется для сокращения кол-ва запросов в БД, путем их накопления внутри себя - связан с сессией, параллельные сессии не видят объекты из чужих кэшей - при повторном запросе данных из БД данные загружаются из кэша - удаляется из кэша методом evict() - очищается с помощью clear()
JPA	Java Persistence API - это стандартная для Java спецификация описывающая ОРМ. Не имеет реализаций внутри себя а только определяет правила как должны работать провайдеры (Hibernate, EclipseLink), которые реализуют JPA. Hibernate - библиотека, которая реализует JPA и ORM, содержит важные интерфейсы, из их числа: Session - обеспечивает физическое соединение с БД, предлагает DLM операции для экземпляров сущностей SessionFactory - фабрика для объектов Session Transaction - объект, используемый для атомарных операций Query - выполняет запросы к БД на SQL и HQL
Что такое инверсия контроля (IoC) и внедрение зависимостей (DI)? Как эти принципы реализованы в Spring?	Inversion of Control - подход, который позволяет конфигурировать и управлять объектами Java с помощью рефлексии. Вместо ручного внедрения зависимостей, фреймворк забирает ответственность за это посредством IoC-контейнера. Контейнер отвечает за управление жизненным циклом объекта: создание объектов, вызов методов инициализации и конфигурирование объектов путём связывания их между собой. Объекты, создаваемые контейнером, называются beans. Конфигурирование контейнера осуществляется путём внедрения аннотаций, но также, есть возможность, по старинке, загрузить XML-файлы, содержащие определение bean'ов и предоставляющие информацию, необходимую для создания bean'ов. Dependency Injection — является одним из способов реализации принципа IoC в Spring. Это шаблон проектирования, в котором контейнер передает экземпляры объектов по их типу другим объектам с помощью конструктора или метода класса(setter), что позволяет писать слабосвязный код.
Что такое IoC контейнер?	Inversion of Control - подход, который позволяет конфигурировать и управлять объектами Java с помощью рефлексии. Вместо ручного внедрения зависимостей, фреймворк забирает ответственность за это посредством IoC-контейнера. Контейнер отвечает за управление жизненным циклом объекта: создание объектов, вызов методов инициализации и конфигурирование объектов путём связывания их между собой. Объекты, создаваемые контейнером, называются beans. Конфигурирование контейнера осуществляется путём внедрения аннотаций, но также, есть возможность, по старинке, загрузить XML-файлы, содержащие определение bean'ов и предоставляющие информацию, необходимую для создания bean'ов. Dependency Injection — является одним из способов реализации принципа IoC в Spring. Это шаблон проектирования, в котором контейнер передает экземпляры объектов по их типу другим объектам с помощью конструктора или метода класса(setter), что позволяет писать слабосвязный код.
Расскажите про ApplicationContext и BeanFactory, чем отличаются? В каких случаях что стоит использовать?	ApplicationContext является наследником BeanFactory и полностью реализует его функционал, добавляя больше специфических enterprise-функций. Может работать с бинами всех скоупов. BeanFactory - это фактический контейнер, который создает, настраивает и управляет рядом bean-компонентов. Эти бины обычно взаимодействуют друг с другом и, таким образом, имеют зависимости между собой. Эти зависимости отражены в данных конфигурации, используемых BeanFactory. Может работать с бинами singleton и prototype. BeanFactory обычно используется тогда, когда ресурсы ограничены (мобильные устройства), так как он легче по сравнению с ApplicationContext. Поэтому, если ресурсы не сильно ограничены, то лучше использовать ApplicationContext. ApplicationContext загружает все бины при запуске, а BeanFactory по требованию.
Расскажите про аннотацию @Bean?	Аннотация @Bean используется для указания того, что метод создает, настраивает и инициализирует новый объект, управляемый IoC-контейнером. Такие методы можно использовать как в классах с аннотацией @Configuration, так и в классах с аннотацией @Component(или её наследниках). Имеет следующие свойства: destroyMethod, initMethod — варианты переопределения методов инициализации и удаления бина, указав их имена в аннотации. name — имя бина. По умолчанию именем бина является имя метода. value — алиас для name()
Расскажите про аннотацию @Component?	@Component - используется для указания класса в качестве компонента spring. Такой класс будет сконфигурирован как spring Bean.
Чем отличаются аннотации @Bean и @Component?	@Bean - ставится над методом и позволяет добавить bean, уже реализованного сторонней библиотекой класса, в контейнер, а @Component используется для указания класса, написанного программистом.
Расскажите про аннотации @Service и @Repository. Чем они отличаются?	@Repository - указывает, что класс используется для работы с поиском, получением и хранением данных. Аннотация может использоваться для реализации шаблона DАО. @Service - указывает, что класс является сервисом для реализации бизнес-логики. @Repository, @Service, @Controller и @Configuration являются алиасами @Component, их также называют стереотипными аннотациями. Задача @Repository заключается в том, чтобы отлавливать определенные исключения персистентности и пробрасывать их как одно непроверенное исключение Spring Framework. Для этого в контекст должен быть добавлен класс PersistenceExceptionTranslationPostProcessor.
Расскажите про аннотацию @Autowired	@Autowired - автоматическое внедрение подходящего бина: 1) Контейнер определяет тип объекта для внедрения 2) Контейнер ищет соответствующий тип бина в контексте(он же контейнер) 3) Если есть несколько кандидатов, и один из них помечен как @Primary, то внедряется он 4) Если используется @Qualifier, то контейнер будет использовать информацию из @Qualifier, чтобы понять, какой компонент внедрять 5) В противном случае контейнер внедрит бин, основываясь на его имени или ID 6) Если ни один из способов не сработал, то будет выброшено исключение Контейнер обрабатывает DI с помощью AutowiredAnnotationBeanPostProcessor. В связи с этим, аннотация не может быть использована ни в одном BeanFactoryPP или BeanPP. В аннотации есть один параметр required = true/fals - указывает, обязательно ли делать DI. По умолчанию true. Либо можно не выбрасывать исключение, а оставить поле c null, если нужный бин не был найден - false. При циклической зависимости, когда объекты ссылаются друг на друга, нельзя ставить над конструктором.
Расскажите про аннотацию @Resource	@Resource(аннотация java) пытается получить зависимость: по имени, по типу, затем по описанию (Qualifier). Имя извлекается из имени аннотируемого сеттера или поля, либо берется из параметра name. @Resource //По умолчанию поиск бина с именем "context" private ApplicationContext context; @Resource(name="greetingService") //Поиск бина с именем "greetingService" public void setGreetingService(GreetingService service) { this.greetingService = service; } Разница с @Autowired: ❖ ищет бин сначала по имени, а потом по типу; ❖ не нужна дополнительная аннотация для указания имени конкретного бина; ❖ @Autowired позволяет отметить место вставки бина как необязательное @Autowired(required = false); ❖ при замене Spring Framework на другой фреймворк, менять аннотацию @Resource не нужно.
Расскажите про аннотацию @Inject	@Inject входит в пакет javax.inject и, чтобы её использовать, нужно добавить зависимость: <dependency> <groupId>javax.inject</groupId> <artifactId>javax.inject</artifactId> <version>1</version> </dependency> @Inject (аннотация java) аналог @Autowired (аннотация spring) в первую очередь пытается подключить зависимость по типу, затем по описанию и только потом по имени. В ней нет параметров. Поэтому при использовании конкретного имени (Id) бина используем @Named: @Inject @Named("yetAnotherFieldInjectDependency") private ArbitraryDependency yetAnotherFieldInjectDependency;
Расскажите про аннотацию @Lookup	Обычно бины в приложении Spring являтся синглтонами, и для внедрения зависимостей мы используем конструктор или сеттер. Но бывает и другая ситуация: имеется бин Car - синглтон (singleton bean), и ему требуется каждый раз новый экземпляр бина Passenger. То есть Car - синглтон, а Passenger - так называемый прототипный бин (prototype bean). Жизненные циклы бинов разные. Бин Car создается контейнером только раз, а бин Passenger создается каждый раз новый - допустим, это происходит каждый раз при вызове какого-то метода бина Car. Вот здесь то и пригодится внедрение бина с помощью Lookup метода. Оно происходит не при инициализации контейнера, а позднее: каждый раз, когда вызывается метод. Суть в том, что вы создаете метод-заглушку в бине Car и помечаете его специальным образом - аннотацией @Lookup. Этот метод должен возвращать бин Passenger, каждый раз новый. Контейнер Spring под капотом создаст подкласс и переопределит этот метод и будет вам выдавать новый экземпляр бина Passenger при каждом вызове аннотированного метода. Даже если в вашей заглушке он возвращает null (а так и надо делать, все равно этот метод будет переопределен).
Можно ли вставить бин в статическое поле? Почему?	Spring не позволяет внедрять бины напрямую в статические поля. Это связано с тем, что когда загрузчик классов загружает статические значения, контекст Spring ещё не загружен. Чтобы исправить это, создайте нестатический сеттер-метод с @Autowired: private static OrderItemService orderItemService; @Autowired public void setOrderItemService(OrderItemService orderItemService) { TestDataInit.orderItemService = orderItemService; }
Расскажите про аннотации @Primary и @Qualifier	@Qualifier применяется если кандидатов для автоматического связывания несколько, она позволяет указать в качестве аргумента имя конкретного бина, который следует внедрить. Она может быть применена к отдельному полю класса, к отдельному аргументу метода или конструктора:@Primary тоже используется, чтобы отдавать предпочтение бину, когда есть несколько бинов одного типа, но в ней нельзя задать имя бина, она определяет значение по умолчанию, в то время как @Qualifier более специфичен.Если присутствуют аннотации @Qualifier и @Primary, то аннотация @Qualifier будет иметь приоритет.
Как заинжектить примитив?	Для этого можно использовать аннотацию @Value. Можно ставить над полем, конструктором, методом. Такие значения можно получать из property файлов, из бинов, и т.п. @Value("${some.key}") public String stringWithDefaultValue; В эту переменную будет внедрена строка, например из property или из view. Кроме того, для внедрения значений мы можем использовать язык SpEL (Spring Expression Language)
Как заинжектить коллекцию?	Если внедряемый объект массив, коллекция, или map с дженериком, то используя аннотацию @Autowired, Spring внедрит все бины подходящие по типу в этот массив(или другую структуру данных). В случае с map ключом будет имя бина. Используя аннотацию @Qualifier можно настроить тип искомого бина. Бины могут быть упорядочены, когда они вставляются в списки (не Set или Map) или массивы. Поддерживаются как аннотация @Order, так и интерфейс Ordered.
Расскажите про аннотацию @Conditional	Spring предоставляет возможность на основе вашего алгоритма включить или выключить определение бина или всей конфигурации через @Conditional, в качестве параметра которой указывается класс, реализующий интерфейс Condition, с единственным методом matches(ConditionContext var1, AnnotatedTypeMetadata var2), возвращающий boolean. Для создания более сложных условий можно использовать классы AnyNestedCondition, AllNestedConditions и NoneNestedConditions. Аннотация @Conditional указывает, что компонент имеет право на регистрацию в контексте только тогда, когда все условия соответствуют. Условия проверяются непосредственно перед тем, как должен быть зарегистрирован BeanDefinition компонента, и они могут помешать регистрации данного BeanDefinition. Поэтому нельзя допускать, чтобы при проверке условий мы взаимодействовали с бинами, которых еще не существует, с их BeanDefinition-ами можно. Для того, чтобы проверить несколько условий, можно передать в @Conditional несколько классов с условиями: @Conditional(HibernateCondition.class, OurConditionClass.class) Если класс @Configuration помечен как @Conditional, то на все методы @Bean, аннотации @Import и аннотации @ComponentScan, связанные с этим классом, также будут распространяться указанные условия.
Расскажите про аннотацию @Profile	Профили - это ключевая особенность Spring Framework, позволяющая нам относить наши бины к разным профилям (логическим группам), например, dev, test, prod. Мы можем активировать разные профили в разных средах, чтобы загрузить только те бины, которые нам нужны. Используя аннотацию @Profile, мы относим бин к конкретному профилю. Её можно применять на уровне класса или метода. Аннотация @Profile принимает в качестве аргумента имя одного или нескольких профилей. Она фактически реализована с помощью гораздо более гибкой аннотации @Conditional. Ее можно ставить на @Configuration и Component классы.
Расскажите про жизненный цикл бина, аннотации @PostConstruct и @PreDestroy()	Beans - центральный объект заботы Spring Framework. За кулисами фреймворка с ними происходит множество процессов. Во многие из них можно вмешаться, добавив собственную логику в разные этапы жизненного цикла. Через следующие этапы проходит каждый отдельно взятый бин:1. Инстанцирование объекта. Техническое начало жизни бина, работа конструктора его класса;2. Установка свойств из конфигурации бина, внедрение зависимостей;3. Нотификация aware-интерфейсов. BeanNameAware, BeanFactoryAware и другие. Мы уже писали о таких интерфейсах ранее. Технически, выполняется системными подтипами BeanPostProcessor, и совпадает с шагом 4;4. Пре-инициализация - метод postProcessBeforeInitialization() интерфейса BeanPostProcessor;5. Инициализация. Разные способы применяются в таком порядке:• Метод бина с аннотацией @PostConstruct из стандарта JSR-250 (рекомендуемый способ);• Метод afterPropertiesSet() бина под интерфейсом InitializingBean;• Init-метод. Для отдельного бина его имя устанавливается в параметре определения initMethod. В xml-конфигурации можно установить для всех бинов сразу, с помощью default-init-method;6. Пост-инициализация - метод postProcessAfterInitialization() интерфейса BeanPostProcessor. Когда IoC-контейнер завершает свою работу, мы можем кастомизировать этап штатного уничтожения бина. Как со всеми способами финализации в Java, при жестком выключении (kill -9) гарантии вызова этого этапа нет. Три альтернативных способа «деинициализации» вызываются в том же порядке, что симметричные им методы инициализации:1. Метод с аннотацией @PreDestroy;2. Метод с именем, которое указано в свойстве destroyMethod определния бина (или в глобальном default-destroy-method);3. Метод destroy() интерфейса DisposableBean.Не следует путать жизненный цикл отдельного бина с жизненным циклом контекста и этапами подготовки фабрик бинов. О них мы поговорим в будущих публикациях.
Расскажите про скоупы бинов? Какой скоуп используется по умолчанию? Что изменилось в Spring 5?	Существует 2 области видимости по умолчанию. Singleton - область видимости по умолчанию. В контейнере будет создан только один бин, и все запросы на него будут возвращать один и тот же бин. Prototype - приводит к созданию нового бина каждый раз, когда он запрашивается. Для бинов со scope "prototype" Spring не вызывает метод destroy(), так как не берет на себя контроль полного жизненного цикла этого бина. Spring не хранит такие бины в своём контексте ( контейнере), а отдаёт их клиенту и больше о них не заботится (в отличие от синглтон-бинов). И 4 области видимости в веб-приложении. Request - Область видимости — 1 HTTP запрос. На каждый запрос создается новый бин Session - Область видимости — 1 сессия. На каждую сессию создается новый бин Application - Область видимости — жизненный цикл ServletContext WebSocket - Область видимости — жизненный цикл WebSocket Жизненный цикл web csope полный. В пятой версии Spring Framework не стало Global session scope. И появились Application и WebSocket
Расскажите про аннотацию @ComponentScan	Первый шаг для описания конфигурации Spring это добавление аннотаций — @Component или наследников. Однако, Spring должен знаеть где искать их. В @ComponentScan вы указываете пакеты, которые должны сканироваться. Можно указать массив строк. Spring будет искать бины и в их подпакетах. Мы можем расширить это поведение с помощью includeFilters и excludeFilters параметров в аннотации. Для ComponentScan.Filter доступно пять типов фильтров: ANNOTATION ASSIGNABLE_TYPE ASPECTJ REGEX CUSTOM Нужно для того, что например, имея какой-то ненужный класс в не нашей библиотеке, мы можем создать для него фильтр, чтобы его бин не инициализировался.
Как спринг работает с транзакциями? Расскажите про аннотацию @Transactional.	Коротко: Spring создает прокси для всех классов, помеченных @Transactional (либо если любой из методов класса помечен этой аннотацией), что позволяет вводить транзакционную логику до и после вызываемого метода. При вызове такого метода происходит следующее:- proxy, который создал Spring, создаёт persistence context (или соединение с базой),- открывает в нём транзакцию и сохраняет всё это в контексте нити исполнения (натурально, в ThreadLocal).- По мере надобности всё сохранённое достаётся и внедряется в бины.Таким образом, если в вашем коде есть несколько параллельных нитей, у вас будет и несколько параллельных транзакций, которые будут взаимодействовать друг с другом согласно уровням изоляции.Что произойдёт, если один метод с @Transactional вызовет другой метод с @Transactional?Если это происходит в рамках одного сервиса, то второй транзакционный метод будет считаться частью первого, так как вызван у него изнутри, а так как спринг не знает о внутреннем вызове, то не создаст прокси для второго метода.Что произойдёт, если один метод БЕЗ @Transactional вызовет другой метод с @Transactional?Так как spring не знает о внутреннем вызове, то не создаст прокси для второго метода.Будет ли транзакция откачена, если будет брошено исключение, которое указано в контракте метода?Если в контракте описано это исключение, то она не откатится. Unchecked исключения в транзакционном методе можно ловить, а можно и не ловить. Значения атрибута propagation у аннотации:REQUIRED — применяется по умолчанию. При входе в @Transactional метод будет использована уже существующая транзакция или создана новая транзакция, если никакой ещё нет REQUIRES_NEW — новая транзакция всегда создаётся при входе метод, ранее созданные транзакции приостанавливаются до момента возврата из метода. NESTED — корректно работает только с базами данных, которые умеют savepoints. При входе в метод в уже существующей транзакции создаётся savepoint, который по результатам выполнения метода будет либо сохранён, либо откачен. Все изменения, внесённые методом, подтвердятся только поздее, с подтверждением всей транзакции. Если текущей транзакции не существует, будет создана новая.MANDATORY — всегда используется существующая транзакция и кидается исключение, если текущей транзакции нет.SUPPORTS — метод с этим правилом будет использовать текущую транзакцию, если она есть, либо будет исполнятся без транзакции, если её нет.NOT_SUPPORTED — при входе в метод текущая транзакция, если она есть, будет приостановлена и метод будет выполняться без транзакции.NEVER — явно запрещает исполнение в контексте транзакции. Если при входе в метод будет существовать транзакция, будет выброшено исключение.Остальные атрибуты:rollbackFor = Exception.class - если какой-либо метод выбрасывает указанное исключение, контейнер всегда откатывает текущую транзакцию. По умолчанию отлавливает RuntimeExceptionnoRollbackFor = Exception.class - указание того, что любое исключение, кроме заданных, должно приводить к откату транзакции.rollbackForClassName и noRollbackForClassName - для задания имен исключений в строковом виде.readOnly - разрешает только операции чтения.В свойстве transactionManager хранится ссылка на менеджер транзакций, определенный в конфигурации Spring.timeOut - По умолчанию используется таймаут, установленный по умолчанию для базовой транзакционной системы. Сообщает менеджеру tx о продолжительности времени, чтобы дождаться простоя tx, прежде чем принять решение об откате не отвечающих транзакций.isolation - уровень изолированности транзакцийПодробно:Для работы с транзакциями Spring Framework использует AOP-прокси:Для включения возможности управления транзакциями нужно разместить аннотацию @EnableTransactionManagement у класса конфигурации @Configuration.Она означает, что классы, помеченные @Transactional, должны быть обернуты аспектом транзакций. Отвечает за регистрацию необходимых компонентов Spring, таких как TransactionInterceptor и советы прокси. Регистрируемые компоненты помещают перехватчик в стек вызовов при вызове методов @Transactional. Если мы используем Spring Boot и имеем зависимости spring-data-* или spring-tx, то управление транзакциями будет включено по умолчанию.Пропагейшн работает только если метод вызывает другой метод в другом сервисе. Если метод вызывает другой метод в этом же сервисе, то используется this и вызов проходит мимо прокси. Это ограничение можно обойти при помощи self-injection.Слой логики(Service) - лучшее место для @Transactional.Помечая @Transactional класс @Service, то все его методы станут транзакционными. Так, при вызове, например, метода save() произойдет примерно следующее:1. Вначале мы имеем:❖ класс TransactionInterceptor, у которого вызывается метод invoke(...), внутри которого вызывается метод класса-родителя TransactionAspectSupport: invokeWithinTransaction(...), в рамках которого происходит магия транзакций.❖ TransactionManager: решает, создавать ли новый EntityManager и/или транзакцию.❖ EntityManager proxy: EntityManager - это интерфейс, и то, что внедряется в бин в слое DAO на самом деле не является реализацией EntityManager. В это поле внедряется EntityManager proxy, который будет перехватывать обращение к полю EntityManager и делегировать выполнение конкретному EntityManager в рантайме. Обычно EntityManager proxy представлен классом SharedEntityManagerInvocationHandler.2. Transaction InterceptorВ TransactionInterceptor отработает код до работы метода save(), в котором будет определено, выполнить ли метод save() в пределах уже существующей транзакции БД или должна стартовать новая отдельная транзакция. TransactionInterceptor сам не содержит логики по принятию решения, решение начать новую транзакцию, если это нужно, делегируется TransactionManager. Грубо говоря, на данном этапе наш метод будет обёрнут в try-catch и будет добавлена логика до его вызова и после:try {transaction.begin(); // логика доservice.save(); transaction.commit(); // логика после} catch(Exception ex) {transaction.rollback();throw ex;}3. TransactionManagerМенеджер транзакций должен предоставить ответ на два вопроса:❖ Должен ли создаться новый EntityManager?❖ Должна ли стартовать новая транзакция БД?Решение принимается, основываясь на следующих фактах:❖ выполняется ли хоть одна транзакция в текущий момент или нет;❖ атрибута «propagation» в @Transactional.Если TransactionManager решил создать новую транзакцию, тогда:❖ Создается новый EntityManager;❖ EntityManager «привязывается» к текущему потоку (Thread);❖ «Получается» соединение из пула соединений БД; ❖ Соединение «привязывается» к текущему потоку.И EntityManager и это соединение привязываются к текущему потоку, используя переменные ThreadLocal.4. EntityManager proxyКогда метод save() слоя Service делает вызов метода save() слоя DAO, внутри которого вызывается, например, entityManager.persist(), то не происходит вызов метода persist() напрямую у EntityManager, записанного в поле класса DAO. Вместо этого метод вызывает EntityManager proxy, который достает текущий EntityManager для нашего потока, и у него вызывается метод persist().5. Отрабатывает DAO-метод save().6. TransactionInterceptorОтработает код после работы метода save(), а именно будет принято решение по коммиту/откату транзакции.Кроме того, если мы в рамках одного метода сервиса обращаемся не только к методу save(), а к разным методам Service и DAO, то все они буду работать в рамках одной транзакции, которая оборачивает этот метод сервиса.Вся работа происходит через прокси-объекты разных классов. Представим, что у нас в классе сервиса только один метод с аннотацией @Transactional, а остальные нет. Если мы вызовем метод с @Transactional, из которого вызовем метод без @Transactional, то оба будут отработаны в рамках прокси и будут обернуты в нашу транзакционную логику. Однако, если мы вызовем метод без @Transactional, из которого вызовем метод с @Transactional, то они уже не будут работать в рамках прокси и не будут обернуты в нашу транзакционную логику.
Расскажите про аннотации @Controller и @RestController. Чем они отличаются? Как вернуть ответ со своим статусом (например 213)?	@Controller - специальный тип класса, обрабатывает HTTP-запросы и часто используется с аннотацией @RequestMapping. @RestController ставится на класс-контроллер вместо @Controller. Она указывает, что этот класс оперирует не моделями, а данными. Она состоит из аннотаций @Controller и @ResponseBody. Была введена в Spring 4.0 для упрощения создания RESTful веб-сервисов. @ResponseBody сообщает контроллеру, что возвращаемый объект автоматически сериализуется (используя Jackson message converter) в json или xml и передается обратно в объект HttpResponse. ResponseEntity используется для формирования кастомизированного HTTP-ответа с пользовательскими параметрами (заголовки, код статуса и тело ответа). Во всех остальных случаях достаточно использовать @ResponseBody. Если мы хотим использовать ResponseEntity, то просто должны вернуть его из метода, Spring позаботится обо всем остальном. return ResponseEntity.status(213);
Что такое ViewResolver?	ViewResolver - распознаватель представлений - это способ работы с представлениями(html-файлы), который поддерживает их распознавание на основе имени, возвращаемого контроллером. Spring Framework поставляется с большим количеством реализаций ViewResolver. Например, класс UrlBasedViewResolver поддерживает прямое преобразование логических имен в URL. InternalResourceViewResolver — реализация ViewResolver по умолчанию, которая позволяет находить представления, которые возвращает контроллер для последующего перехода к ним. Ищет по заданному пути, префиксу, суффиксу и имени. Любым реализациям ViewResolver желательно поддерживать интернационализацию, то есть множество языков. Существует также несколько реализаций для интеграции с различными технологиями представлений, такими как FreeMarker (FreeMarkerViewResolver), Velocity (VelocityViewResolver) и JasperReports (JasperReportsViewResolver)
Чем отличаются Model, ModelMap и ModelAndView?	Model - интерфейс, представляет коллекцию пар ключ-значение Map<String, Object>. Содержимое модели используется для отображения данных во View. Например, если View выводит информацию об объекте Customer, то она может ссылаться к ключам модели, например customerName, customerPhone, и получать значения для этих ключей. Объекты-значения из модели также могут содержать бизнес-логику. ModelMap - класс, наследуется от LinkedHashMap, тоже используется для передачи значений для визуализации представления. Преимущество ModelMap заключается в том, что он дает нам возможность передавать коллекцию значений и обрабатывать эти значения, как если бы они были внутри Map. ModelAndView - это просто контейнер для ModelMap, объект View и HttpStatus. Это позволяет контроллеру возвращать все значения как одно. View используется для отображения данных приложения пользователю. Spring MVC поддерживает несколько поставщиков View(они называются шаблонизаторы) — JSP, JSF, Thymeleaf, и т.п. Интерфейс View преобразует объекты в обычные сервлеты.
Расскажите про паттерн Front Controller, как он реализован в Spring?	Front controller - обеспечивает единую точку входа для всех входящих запросов. Все запросы обрабатываются одним обработчиком - DispatcherServlet с маппингом "/". Этот обработчик может выполнить аутентификацию, авторизацию, регистрацию или отслеживание запроса, а затем распределяет их между контроллерами, обрабатывающими разные URL. Это и есть реализация паттерна Front Controller. Веб-приложение может определять любое количество DispatcherServlet-ов. Каждый из них будет работать в своем собственном пространстве имен, загружая свой собственный дочерний WebApplicationContext с вьюшками, контроллерами и т.д. ❖ Один из контекстов будет корневым, а все остальные контексты будут дочерними. ❖ Все дочерние контексты могут получить доступ к бинам, определенным в корневом контексте, но не наоборот. ❖ Каждый дочерний контекст внутри себя может переопределить бины из корневого контекста. WebApplicationContext расширяет ApplicationContext (создаёт и управляет бинами и т.д.), но помимо этого он имеет дополнительный метод getServletContext(), через который у него есть возможность получать доступ к ServletContext-у. ContextLoaderListener создает корневой контекст приложения и будет использоваться всеми дочерними контекстами, созданными всеми DispatcherServlet.
Расскажите про паттерн MVC, как он реализован в Spring?	MVC — это шаблон проектирования, делящий программу на 3 вида компонентов:Model — модель отвечает за хранение данных.View — отвечает за вывод данных на фронтенде.Controller — оперирует моделями и отвечает за обмен данными model с view.Основная цель следования принципам MVC — отделить реализацию бизнес-логики приложения (модели) от ее визуализации (view).Spring MVC - это веб-фреймворк, основанный на Servlet API, с использованием двух шаблонов проектирования - Front controller и MVC.Spring MVC реализует четкое разделение задач, что позволяет нам легко разрабатывать и тестировать наши приложения. Данные задачи разбиты между разными компонентами: Dispatcher Servlet, Controllers, View Resolvers, Views, Models, ModelAndView, Model and Session Attributes, которые полностью независимы друг от друга, и отвечают только за одно направление. Поэтому MVC дает нам довольно большую гибкость. Он основан на интерфейсах (с предоставленными классами реализации), и мы можем настраивать каждую часть фреймворка с помощью пользовательских интерфейсов.Основные интерфейсы для обработки запросов:DispatcherServlet является главным контроллером, который получает запросы и распределяет их между другими контроллерами. @RequestsMapping указывает, какие именно запросы будут обрабатываться в конкретном контроллере. Может быть несколько экземпляров DispatcherServlet, отвечающих за разные задачи (обработка запросов пользовательского интерфейса, REST служб и т.д.). Каждый экземпляр DispatcherServlet имеет собственную конфигурацию WebApplicationContext. HandlerMapping. Выбор класса и его метода, которые должны обработать данный входящий запрос на основе любого внутреннего или внешнего для этого запроса атрибута или состояния. Controller — оперирует моделями и отвечает за обмен данными model с view. ViewResolver. Выбор, какое именно View должно быть показано клиенту на основе имени, полученного от контроллера.View. Отвечает за возвращение ответа клиенту в виде текстов и изображений. Используются встраиваемые шаблонизаторы (Thymeleaf, FreeMarker и т.д.), так как у Spring нет родных. Некоторые запросы могут идти прямо во View, не заходя в Model, другие проходят через все слои.HandlerAdapter. Помогает DispatcherServlet вызвать и выполнить метод для обработки входящего запроса.ContextLoaderListener - слушатель при старте и завершении корневого класса Spring WebApplicationContext. Основным назначением является связывание жизненного цикла ApplicationContext и ServletContext, а также автоматического создания ApplicationContext. Можно использовать этот класс для доступа к бинам из различных контекстов спринг.❖ После получения HTTP-запроса DispatcherServlet обращается к интерфейсу HandlerMapping, который определяет, какой Контроллер (Controller) должен быть вызван, после чего HandlerAdapter, отправляет запрос в нужный метод Контроллера.❖ Контроллер принимает запрос и вызывает соответствующий метод. Вызванный метод формирует данные Model и возвращает их в DispatcherServlet вместе с именем View (как правило имя html-файла).❖ При помощи интерфейса ViewResolver DispatcherServlet определяет, какое View нужно использовать на основании имени, полученного от контроллера.➢ если это REST-запрос на сырые данные (JSON/XML), тоDispatcherServlet сам его отправляет, минуя ViewResolver;➢ если обычный запрос, то DispatcherServlet отправляет данные Model в виде атрибутов во View - шаблонизаторы Thymeleaf, FreeMarker и т.д., которые сами отправляют ответ.Как видим, все действия происходят через один DispatcherServlet.
Что такое АОП? Как реализовано в спринге?	Аспектно-ориентированное программирование (АОП) — это парадигма программирования, целью которой является повышение модульности за счет разделения междисциплинарных задач. Это достигается путем добавления дополнительного поведения к существующему коду без изменения самого кода. АОП предоставляет возможность реализации сквозной логики в одном месте - т.е. логики, которая применяется к множеству частей приложения - и обеспечения автоматического применения этой логики по всему приложению. Аспект в АОП - это модуль или класс, реализующий сквозную функциональность. Аспект изменяет поведение остального кода, применяя совет в точках соединения, определённых некоторым срезом. Совет (advice) - дополнительная логика — код, который должен быть вызван из точки соединения. Точка соединения (join point) — место в выполняемой программе (вызов метода, создание объекта, обращение к переменной), где следует применить совет; Срез (pointcut) — набор точек соединения. Подход Spring к АОП заключается в создании "динамических прокси" для целевых объектов и "привязывании" объектов к конфигурированному совету для выполнения сквозной логики. Есть два варианта создания прокси-класса: 1. либо он должен наследоваться от оригинального класса (CGLIB) и переопределять его методы, добавляя нужную логику; 2. либо он должен имплементировать те же самые интерфейсы, что и первый класс (Dynamic Proxy).
В чем разница между Filters, Listeners and Interceptors?	Filter выполняет задачи фильтрации либо по пути запроса к ресурсу, либо по пути ответа от ресурса, либо в обоих направлениях.Фильтры выполняют фильтрацию в методе doFilter. Каждый фильтр имеет доступ к объекту FilterConfig, из которого он может получить параметры инициализации, и ссылку на ServletContext. Фильтры настраиваются в дескрипторе развертывания веб-приложения.При создании цепочки фильтров, веб-сервер решает, какой фильтр вызывать первым, в соответствии с порядком регистрации фильтров.Когда вызывается метод doFilter(...) первого фильтра, веб-сервер создает объект FilterChain, представляющий цепочку фильтров, и передаёт её в метод.Зависят от контейнера сервлетов. Могут работать с js, cssInterceptor являются аналогом Filter в Spring. Перехватить запрос клиента можно в трех местах: preHandle, postHandle и afterCompletion. Перехватчики работают с HandlerMapping и поэтому должны реализовывать интерфейс HandlerInterceptor или наследоваться от готового класса HandlerInterceptorAdapter, после чего переопределить указанные методы. Чтобы добавить наши перехватчики в конфигурацию Spring, нам нужно переопределить метод addInterceptors () внутри класса, который реализует WebMvcConfigurer. Interceptor основан на механизме Reflection, а фильтр основан на обратном вызове функции.preHandle — метод используется для обработки запросов, которые еще не были переданы в метод контроллера. Должен вернуть true для передачи следующему перехватчику или в handler method. False укажет на обработку запроса самим обработчиком и отсутствию необходимости передавать его дальше. Метод имеет возможность выкидывать исключения и пересылать ошибки к представлению.postHandle — вызывается после handler method, но до обработки DispatcherServlet для передачи представлению. Может использоваться для добавления параметров в объект ModelAndView.afterCompletion — вызывается после отрисовки представления.Listener - это класс, имплементирующий интерфейс ServletContextListener с аннотацией @WebListener. Listener ждет когда произойдет указанное событие, затем «перехватывает» событие и запускает собственное событие. Он инициализируется только один раз при запуске веб-приложения и уничтожается при остановке веб-приложения. Все ServletContextListeners уведомляются об инициализации контекста до инициализации любых фильтров или сервлетов в вебприложении и об уничтожении контекста после того, как все сервлеты и фильтры уничтожены.
Можно ли передать в запросе один и тот же параметр несколько раз? Как?	Да, можно принять все значения, используя массив в методе контроллера: http://localhost:8080/login?name=Ranga&name=Ravi&name=Sathish public String method(@RequestParam(value="name") String[] names){...} http://localhost:8080/api/foos?id=1,2,3 public String getFoos(@RequestParam List<String> id){...}
Как работает Spring Security? Как сконфигурировать? Какие интерфейсы используются?	В кратце, основными блоками Spring Security являются:SecurityContextHolder, чтобы обеспечить доступ к SecurityContext.SecurityContext, содержит объект Authentication и в случае необходимости информацию системы безопасности, связанную с запросом.Authentication представляет принципала с точки зрения Spring Security.GrantedAuthority отражает разрешения выданные доверителю в масштабе всего приложения.UserDetails предоставляет необходимую информацию для построения объекта Authentication из DAO объектов приложения или других источника данных системы безопасности.UserDetailsService, чтобы создать UserDetails, когда передано имя пользователя в виде String (или идентификатор сертификата или что-то подобное).Подробно:Самым фундаментальным явлется SecurityContextHolder. В нем мы храним информацию о текущем контексте безопасности приложения, который включает в себя подробную информацию о пользователе, работающем с приложением. По умолчанию SecurityContextHolder использует MODE_THREADLOCAL для хранения такой информации, что означает, что контекст безопасности всегда доступен для методов исполняющихся в том же самом потоке, даже если контекст безопасности явно не передается в качестве аргумента этих методов:SecurityContextHolder.getContext().getAuthentication().getPrincipal();UserDetails выступает в качестве принципала.MODE_GLOBAL - все потоки Java-машины используют один контекст безопасности.MODE_INHERITABLETHREADLOCAL - потоки порожденные от одного защищенного потока, наличие аналогичной безопасности.Интерфейс UserDetailsService - подход к загрузке информации о пользователе в Spring Security. Единственный метод этого интерфейса принимает имя пользователя в виде String и возвращает UserDetails. Он представляет собой принципала, но в расширенном виде и с учетом специфики приложения.В случае успешной аутентификации, UserDetails используется для создания Authentication объекта, который хранится в SecurityContextHolder.Ещё одним важным методом Authentication явлется getAuthorities() - предоставляет массив объектов GrantedAuthority(роли).Credentials - под ними понимаются пароль пользователя, но им может быть и отпечаток пальца, фото сетчатки и т.п.Процесс аутентификации:1. UsernamePasswordAuthenticationFilter получают имя пользователя и пароль и создает экземпляр класса UsernamePasswordAuthenticationToken (экземпляр интерфейса Authentication).2. Токен передается экземпляру AuthenticationManager для проверки.3. AuthenticationManager возвращает полностью заполненный экземпляр Authentication в случае успешной аутентификации.4. Устанавливается контекст безопасности путем вызова SecurityContextHolder.getContext().setAuthentication(...), куда передается вернувшийся экземпляр Authentication.5. При успешной аутентификации можно использовать successHandler
Что такое SpringBoot? Какие у него преимущества? Как конфигурируется? Подробно.	Spring Boot - это модуль Spring-а, который предоставляет функцию RAD для среды Spring (Rapid Application Development - Быстрая разработка приложений). Он обеспечивает более простой и быстрый способ настройки и запуска как обычных, так и веб-приложений. Он просматривает наши пути к классам и настроенные нами бины, делает разумные предположения о том, чего нам не хватает, и добавляет эти элементы.Ключевые особенности и преимущества Spring Boot:1. Простота управления зависимостями (spring-boot-starter-* в pom.xml).Чтобы ускорить процесс управления зависимостями Spring Boot неявно упаковывает необходимые сторонние зависимости для каждого типа приложения на основе Spring и предоставляет их разработчику в виде так называемых starter-пакетов.Starter-пакеты представляют собой набор удобных дескрипторов зависимостей, которые можно включить в свое приложение. Это позволяет получить универсальное решение для всех технологий, связанных со Spring, избавляя программиста от лишнего поиска необходимых зависимостей, библиотек и решения вопросов, связанных с конфликтом версий различных библиотек.Например, если вы хотите начать использовать Spring Data JPA для доступа к базе данных, просто включите в свой проект зависимость spring-boot-starter-data-jpa.Starter-пакеты можно создавать и свои.2. Автоматическая конфигурация.Автоматическая конфигурация включается аннотацией @EnableAutoConfiguration. (входит в состав аннотации@SpringBootApplication)После выбора необходимых для приложения starter-пакетов Spring Boot попытается автоматически настроить Spring-приложение на основе выбранных jar-зависимостей, доступных в classpath классов, свойств в application.properties и т.п. Например, если добавим springboot-starter-web, то Spring boot автоматически сконфигурирует такие бины как DispatcherServlet, ResourceHandlers, MessageSource итдАвтоматическая конфигурация работает в последнюю очередь, после регистрации пользовательских бинов и всегда отдает им приоритет. Если ваш код уже зарегистрировал бин DataSource — автоконфигурация не будет его переопределять.3. Встроенная поддержка сервера приложений/контейнера сервлетов (Tomcat, Jetty).Каждое Spring Boot web-приложение включает встроенный web-сервер. Не нужно беспокоиться о настройке контейнера сервлетов и развертывания приложения в нем. Теперь приложение может запускаться само как исполняемый .jar-файл с использованием встроенного сервера.4. Готовые к работе функции, такие как метрики, проверки работоспособности, security и внешняя конфигурация.5. Инструмент CLI (command-line interface) для разработки и тестирования приложения Spring Boot.6. Минимизация boilerplate кода (код, который должен быть включен во многих местах практически без изменений), конфигурации XML и аннотаций.Как происходит автоконфигурация в Spring Boot:1. Отмечаем main класс аннотацией @SpringBootApplication (аннотация инкапсулирует в себе: @SpringBootConfiguration, @ComponentScan, @EnableAutoConfiguration), таким образом наличие @SpringBootApplication включает сканирование компонентов, автоконфигурацию и показывает разным компонентам Spring (например, интеграционным тестам), что это Spring Boot приложение.2. @EnableAutoConfiguration импортирует класс EnableAutoConfigurationImportSelector. Этот класс не объявляет бины сам, а использует фабрики.3. Класс EnableAutoConfigurationImportSelector импортирует ВСЕ (более 150) перечисленные в META-INF/spring.factories конфигурации, чтобы предоставить нужные бины в контекст приложения.4. Каждая из этих конфигураций пытается сконфигурировать различные аспекты приложения (web, JPA, AMQP и т.д.), регистрируя нужные бины. Логика при регистрации бинов управляется набором @ConditionalOn* аннотаций. Можно указать, чтобы бин создавался при наличии класса в classpath (@ConditionalOnClass), наличии существующего бина (@ConditionalOnBean), отсуствии бина (@ConditionalOnMissingBean) и т.п. Таким образом наличие конфигурации не значит, что бин будет создан и зачастую конфигурация ничего делать и создавать не будет.5. Созданный в итоге AnnotationConfigEmbeddedWebApplicationContext ищет в том же DI контейнере фабрику для запуска embedded servlet container.6. Servlet container запускается, приложение готово к работе
Расскажите о Spring Framework.	По сути Spring Framework представляет собой просто контейнер внедрения зависимостей, с несколькими удобными слоями (например: доступ к базе данных, прокси, аспектно-ориентированное программирование, RPC, веб-инфраструктура MVC). Это все позволяет вам быстрее и удобнее создавать Java-приложения. Spring Framework (или коротко Spring) — универсальный фреймворк с открытым исходным кодом для Java-платформы.  Несмотря на то, что Spring Framework не обеспечивает какую-либо конкретную модель программирования, он стал широко распространённым в Java-сообществе главным образом как альтернатива и замена модели Enterprise JavaBeans. Spring Framework предоставляет бо́льшую свободу Java-разработчикам в проектировании; кроме того, он предоставляет хорошо документированные и лёгкие в использовании средства решения проблем, возникающих при создании приложений корпоративного масштаба. Обычно Spring описывают как облегченную платформу для построения Java-приложений, но с этим утверждением связаны два интересных момента.  Во-первых, Spring можно использовать для построения любого приложения на языке Java (т.е. автономных, веб приложений, приложений JEE и т.д.), что отличает Spring от многих других платформ, таких как Apache Struts, которая ограничена только веб-приложениями. Во-вторых, характеристика "облегченная" в действительности не имеет никакого отношения к количеству классов или размеру дистрибутива; напротив, она определяет принцип всей философии Spring — минимальное воздействие. Платформа Spring является облегченной в том смысле, что для использования ядра Spring вы должны вносить минимальные (если вообще какие-либо) изменения в код своего приложения, а если в какой-то момент вы решите больше не пользоваться Spring, то и это сделать очень просто. Обратите внимание, что речь идет только о ядре Spring — многие дополнительные компоненты Spring, такие как доступ кданным, требуют более тесной привязки к Spring Framework.
Из каких частей состоит Spring Framework?	Основной контейнер - предоставляет основной функционал Spring. Главным компонентом контейнера является BeanFactory - реализация паттерна Фабрика. BeanFactory позволяет разделить конфигурацию приложения и информацию о зависимостях от кода. Spring context - конфигурационный файл, который предоставляет информация об окружающей среде для Spring. Сюда входят такие enterprise-сервисы, как JNDI, EJB, интернационализация, валиадция и т.п. Spring AOP - отвечает за интеграцию аспектно-ориентированного программирования во фреймворк. Spring AOP обеспечивает сервис управления транзакциями для Spring-приложения. Spring DAO - абстрактный уровень Spring JDBC DAO предоставляет иерархию исключений и множество сообщений об ошибках для разных БД. Эта иерархия упрощает обработку исключений и значительно уменьшает количество кода, которое вам нужно было бы написать для таких операций, как, например, открытие и закрытие соединения. Spring ORM - отвечает за интеграцию Spring и таких популярных ORM-фреймворков, как Hibernate, iBatis и JDO. Spring Web module - классы, которые помогают упростить разработку Web (авторизация, доступ к бинам Spring-а из web). Spring MVC framework - реализация паттерна MVC для построения Web-приложений.
Какие некоторые из важных особенностей и преимуществ Spring Framework?	Spring Framework обеспечивает решения многих задач, с которыми сталкиваются Java-разработчики и организации, которые хотят создать информационную систему, основанную на платформе Java. Из-за широкой функциональности трудно определить наиболее значимые структурные элементы, из которых он состоит. Spring Framework не всецело связан с платформой Java Enterprise, несмотря на его масштабную интеграцию с ней, что является важной причиной его популярности. Spring Framework, вероятно, наиболее известен как источник расширений (features), нужных для эффективной разработки сложных бизнес-приложений вне тяжеловесных программных моделей, которые исторически были доминирующими в промышленности. Ещё одно его достоинство в том, что он ввел ранее неиспользуемые функциональные возможности в сегодняшние господствующие методы разработки, даже вне платформы Java. Этот фреймворк предлагает последовательную модель и делает её применимой к большинству типов приложений, которые уже созданы на основе платформы Java. Считается, что Spring Framework реализует модель разработки, основанную на лучших стандартах индустрии, и делает её доступной во многих областях Java. Таким образом к достоинствам Spring можно отнести: Относительная легкость в изучении и применении фреймворка в разработке и поддержке приложения. Внедрение зависимостей (DI) и инверсия управления (IoC) позволяют писать независимые друг от друга компоненты, что дает преимущества в командной разработке, переносимости модулей и т.д.. Spring IoC контейнер управляет жизненным циклом Spring Bean и настраивается наподобие JNDI lookup (поиска). Проект Spring содержит в себе множество подпроектов, которые затрагивают важные части создания софта, такие как вебсервисы, веб программирование, работа с базамterm-11и данных, загрузка файлов, обработка ошибок и многое другое. Всё это настраивается в едином формате и упрощает поддержку приложения.
Что такое IoC?	Инверсия управления (Inversion of Control, IoC) — важный принцип объектно-ориентированного программирования, используемый для уменьшения зацепления (связанности) в коде. Также архитектурное решение интеграции, упрощающее расширение возможностей системы, при котором поток управления программы контролируется фреймворком. В обычной программе программист сам решает, в какой последовательности делать вызовы процедур. Но если используется фреймворк, программист может разместить свой код в определенных точках выполнения (используя callback или другие механизмы), затем запустить «главную функцию» фреймворка, которая обеспечит все выполнение и вызовет код программиста тогда, когда это будет необходимо. Как следствие, происходит утеря контроля над выполнением кода — это и называется инверсией управления (фреймворк управляет кодом программиста, а не программист управляет фреймворком). Одной из реализаций инверсии управления в применении к управлению зависимостями является внедрение зависимостей (dependency injection).
Что такое DI?	Внедрение зависимости (Dependency injection, DI) — процесс предоставления внешней зависимости программному компоненту. Является специфичной формой «инверсии управления» Inversion of control, IoC), когда она применяется к управлению зависимостями. В полном соответствии с принципом единственной ответственности объект отдаёт заботу о построении требуемых ему зависимостей внешнему, специально предназначенному для этого общему механизму. Внедрение зависимости для Spring это и есть инициализация полей бинов другими бинами (зависимостями). Ведь помимо создания объектов, Spring-контейнер внедряет эти объекты в другие объекты, то есть делает их полями других объектов. Иногда это выглядит магически - например, контейнер способен внедрить зависимость в поле с модификатором private, для которого нет сеттера. Как же код Spring может это сделать? Дело в том, что под капотом он использует рефлексию, так что это реально. Но эти детали для нас как разработчиков не важны, главное знать, как объяснить фреймворку, какие объекты вы хотите отдать под его управление, и в какие поля других объектов вы хотите их внедрить. Кстати, шаблон Dependency Injection не привязан к Spring, это всего лишь инициализация поля класса. Это такая обычная вещь и так часто встречается в коде (через конструктор либо сеттер), что даже странно выделять ее в отдельный шаблон. В связи со Spring это название мелькает часто наверно потому, что внедрение выполняет Spring, и у программиста тут много возни с конфигурацией зависимостей. Но с другой стороны, создание и внедрение Spring-ом — это уже другой шаблон — инверсия контроля (IoC).
Что такое IoC-контейнер?	Внедрение зависимости используется во многих фреймворках, которые называются IoC-контейнерами. Если сравнить с более низкоуровневыми технологиями, IoC-контейнер — это компоновщик, который собирает не объектные файлы, а объекты ООП (экземпляры класса) во время исполнения программы. Очевидно, для реализации подобной идеи было необходимо создать не только сам компоновщик, но и фабрику, производящую объекты. Предоставление программисту инструментов внедрения зависимостей дало значительно бо́льшую гибкость в разработке и удобство в тестировании кода.
Что такое Spring IoC?	Центральной частью Spring является подход Inversion of Control, который позволяет конфигурировать и управлять объектами Java с помощью рефлексии. Вместо ручного внедрения зависимостей, фреймворк забирает ответственность за это посредством контейнера. Контейнер отвечает за управление жизненным циклом объекта: создание объектов, вызов методов инициализации и конфигурирование объектов путём связывания их между собой. Объекты, создаваемые контейнером, также называются управляемыми объектами (beans). Обычно, конфигурирование контейнера, осуществляется путём внедрения аннотаций (начиная с 5 версии J2SE), но также, есть возможность, по старинке, загрузить XML-файлы, содержащие определение bean'ов и предоставляющие информацию, необходимую для создания bean'ов. Плюсы такого подхода: отделение выполнения задачи от ее реализации; легкое переключение между различными реализациями; большая модульность программы; более легкое тестирование программы путем изоляции компонента или проверки его зависимостей и обеспечения взаимодействия компонентов через контракты. Объекты могут быть получены одним из двух способов: Dependency Lookup Поиск зависимости — шаблон проектирования, в котором вызывающий объект запрашивает у объекта-контейнера экземпляр объекта с определённым именем или определённого типа. Dependency Injection Внедрение зависимости — шаблон проектирования, в котором контейнер передает экземпляры объектов по их имени другим объектам с помощью конструктора, свойства или фабричного метода.
Какие преимущества применения Dependency Injection (DI)?	К преимуществам DI можно отнести: Сокращение объема связующего кода. Одним из самых больших плюсов DI является возможность значительного сокращения объема кода, который должен быть написан для связывания вместе различных компонентов приложения. Зачастую этот код очень прост - при создании зависимости должен создаваться новый экземпляр соответствующего объекта. Упрощенная конфигурация приложения. За счет применения DI процесс конфигурирования приложения значительно упрощается. Для конфигурирования классов, которые могут быть внедрены в другие классы, можно использовать аннотации или XML-файлы. Возможность управления общими зависимостями в единственном репозитории. При традиционном подходе к управлению зависимостями в общих службах, к которым относятся, например, подключение к источнику данных, транзакция, удаленные службы и т.п., вы создаете экземпляры (или получаете их из определенных фабричных классов) зависимостей там, где они нужны - внутри зависимого класса. Это приводит к распространению зависимостей по множеству классов в приложении, что может затруднить их изменение. В случае использования DI вся информация об общих зависимостях содержится в единственном репозитории (в Spring есть возможность хранить эту информацию в XML-файлах или Java классах). Улучшенная возможность тестирования. Когда классы проектируются для DI, становится возможной простая замена зависимостей. Это особенно полезно при тестировании приложения. Стимулирование качественных проектных решений для приложений. Вообще говоря, проектирование для DI означает проектирование с использованием интерфейсов. Используя Spring, вы получаете в свое распоряжение целый ряд средств DI и можете сосредоточиться на построении логики приложения, а не на поддерживающей DI платформе.
Какие IoC контейнеры вы знаете?	Spring является IoC контейнером. Помимо него существуют HiveMind, Avalon, PicoContainer и т.д.
Как реализуется DI в Spring Framework?	Внедрение зависимостей (DI) - это концепция, которая определяет, как должно быть связано несколько классов. Это один из примеров Инверсии контроля. Вам не нужно явно подключать службы и компоненты в коде при использовании внедрения зависимостей. Вместо этого вы описываете службы, необходимые каждому компоненту, в файле конфигурации XML и разрешаете контейнеру IOC автоматически подключать их. Реализация DI в Spring основана на двух ключевых концепциях Java - компонентах JavaBean и интерфейсах. При использовании Spring в качестве поставщика DI вы получаете гибкость определения конфигурации зависимостей внутри своих приложений разнообразными путями (т.е. внешне в XML-файлах, с помощью конфигурационных Java классов Spring или посредством аннотаций Java в коде). Компоненты JavaBean (также называемые POJO (Plain Old Java Object — простой старый объект Java)) предоставляют стандартный механизм для создания ресурсов Java, которые являются конфигурируемыми множеством способов. За счет применения DI объем кода, который необходим при проектировании приложения на основе интерфейсов, снижается почти до нуля. Кроме того, с помощью интерфейсов можно получить максимальную отдачу от DI, потому что бины могут использовать любую реализацию интерфейса для удовлетворения их зависимости.ff
Какие существуют виды DI?	DI можно делать через: Поля класса Сеттеры Конструкторы
DI через поля	Я думаю, что это худший из всех представленных вариантов. Он нарушает принципы ООП и логику управления потоком данных. Нет ни конструктора, ни сеттера, но зависимость каким-то образом просто появляется внутри объекта. Spring использует Reflection API, поэтому ему совершено безразличны область видимости и отсутствие публичного доступа. Однако нас, программистов, это еще как касается. Внедрение зависимостей при помощи поля не рекомендуется делать по нескольким причинам: при этом типе внедрения нельзя сделать зависимость неизменяемой; плотная зависимость от IoC-контейнера — если вы захотите заменить спринговый IoC-контейнер или просто его убрать, то перед этим придется переписывать много кода; ряд дополнительных сложностей с рефлексией при написании юнит-тестов; слишком простая процедура добавления зависимостей, в результате которой легко создать «суперкласс» и перезагрузить код программы.
DI через сеттеры	Внедрение через сеттер следует использовать, когда зависимость является опциональной. Setter Injection позволяет делать опциональные зависимости — такие зависимости можно внедрять повторно. Но использование внедрения через сеттер для обязательной зависимости может привести к NullPointerException и остановке приложения. Хоть и существует способ избежать этого с помощью аннотации @Required , все равно следует внимательно следить за этим типом DI. Setter Injection часто используется в классах, которые должны легко поддаваться реконфигурации. Помимо этого, сеттеры дают возможность определять зависимости в интерфейсе. Отличный пример привел Евгений Борисов в своем докладе «Spring-потрошитель, часть 1» (34:56). В рантайме с помощью JMX в Java-приложении переключался флаг профилирования функций. Очевидно, что без сеттера этого не сделать. У DI через сеттеры и поля есть общая проблема - циклические зависимости. Я бы разделил их на два типа: явные и неявные.
DI через конструкторы	Внедрение через конструктор следует использовать когда зависимость является обязательной, или ее необходимо сделать неизменяемой (с помощью ключевого слова final). Благодаря Constructor Injection также легче заметить «суперклассы» — перегруженные классы с большим количеством зависимостей. Если в классе все зависимости подключаются через конструктор, то в глаза сразу бросается большое количество параметров. И у разработчика появится ощущение, что он делает что-то не так. Я думаю, что этот вариант является лучшим из всех представленных. Во-первых, классы тестируемы. Во-вторых, при необходимости мы можем легко поменять тип инициализации бина. В-третьих, все зависимости инкапсулированы внутри компонентов и не могут быть изменены ни снаружи, ни внутри, так как поля final.
Назовите некоторые из шаблонов проектирования, используемых в Spring Framework?	Вот некоторые известные паттерны, используемые в Spring Framework: Chain of Responsibility - это поведенческий паттерн проектирования, который позволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи. Ему Spring Security Singleton (Одиночка) - Паттерн Singleton гарантирует, что в памяти будет существовать только один экземпляр объекта, который будет предоставлять сервисы. Spring область видимости бина (scope) по умолчанию равна singleton и IoC-контейнер создаёт ровно один экземпляр объекта на Spring IoC-контейнер. Spring-контейнер будет хранить этот единственный экземпляр в кэше синглтон-бинов, и все последующие запросы и ссылки для этого бина получат кэшированный объект. Рекомендуется использовать область видимости singleton для бинов без состояния. Область видимости бина можно определить как singleton или как prototype (создаётся новый экземпляр при каждом запросе бина). Model View Controller (Модель-Представление-Контроллер) - Преимущество Spring MVC в том, что ваши контроллеры являются POJO, а не сервлетами. Это облегчает тестирование контроллеров. Стоит отметить, что от контроллеров требуется только вернуть логическое имя представления, а выбор представления остаётся за ViewResolver. Это облегчает повторное использование контроллеров при различных вариантах представления. Front Controller (Контроллер запросов) - Spring предоставляет DispatcherServlet, чтобы гарантировать, что входящий запрос будет отправлен вашим контроллерам.Паттерн Front Controller используется для обеспечения централизованного механизма обработки запросов, так что все запросы обрабатываются одним обработчиком. Этот обработчик может выполнить аутентификацию, авторизацию, регистрацию или отслеживание запроса, а затем передать запрос соответствующему контроллеру. View Helper отделяет статическое содержимое в представлении, такое как JSP, от обработки бизнес-логики. Dependency injection и Inversion of control (IoC) (Внедрение зависимостей и инверсия управления) - IoC-контейнер в Spring, отвечает за создание объекта, связывание объектов вместе, конфигурирование объектов и обработку всего их жизненного цикла от создания до полного уничтожения. В контейнере Spring используется инъекция зависимостей (Dependency Injection, DI) для управления компонентами приложения. Эти компоненты называются "Spring-бины" (Spring Beans). Service Locator (Локатор служб) - ServiceLocatorFactoryBean сохраняет информацию обо всех бинах в контексте. Когда клиентский код запрашивает сервис (бин) по имени, он просто находит этот компонент в контексте и возвращает его. Клиентскому коду не нужно писать код, связанный со Spring, чтобы найти бин. Паттерн Service Locator используется, когда мы хотим найти различные сервисы, используя JNDI. Учитывая высокую стоимость поиска сервисов в JNDI, Service Locator использует кеширование. При запросе сервиса первый раз Service Locator ищет его в JNDI и кэширует объект. Дальнейший поиск этого же сервиса через Service Locator выполняется в кэше, что значительно улучшает производительность приложения. Observer-Observable (Наблюдатель) - Используется в механизме событий ApplicationContext. Определяет зависимость "один-ко-многим" между объектами, чтобы при изменении состояния одного объекта все его подписчики уведомлялись и обновлялись автоматически. Context Object (Контекстный объект) - Паттерн Context Object, инкапсулирует системные данные в объекте-контексте для совместного использования другими частями приложения без привязки приложения к конкретному протоколу. ApplicationContext является центральным интерфейсом в приложении Spring для предоставления информации о конфигурации приложения. Proxy (Заместитель) - позволяет подставлять вместо реальных объектов специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу. Factory (Фабрика) - определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов. Template (Шаблон) - Этот паттерн широко используется для работы с повторяющимся бойлерплейт кодом (таким как, закрытие соединений и т. п.).
Каковы некоторые из важных особенностей и преимуществ Spring Framework?	Spring Framework обеспечивает решения многих задач, с которыми сталкиваются Java-разработчики и организации, которые хотят создать информационную систему, основанную на платформе Java. Из-за широкой функциональности трудно определить наиболее значимые структурные элементы, из которых он состоит. Spring Framework не всецело связан с платформой Java Enterprise, несмотря на его масштабную интеграцию с ней, что является важной причиной его популярности. Относительная легкость в изучении и применении фреймворка в разработке и поддержке приложения. Внедрение зависимостей (DI) и инверсия  управления (IoC) позволяют писать независимые друг от друга компоненты, что дает преимущества в командной разработке, переносимости модулей и т.д.. Spring IoC контейнер управляет жизненным циклом Spring Bean и настраивается наподобие JNDI lookup (поиска). Проект Spring содержит в себе множество подпроектов, которые затрагивают важные части создания софта, такие как вебсервисы, веб программирование, работа с базами данных, загрузка файлов, обработка ошибок и многое другое. Всё это настраивается в едином формате и упрощает поддержку приложения.
Каковы преимущества использования Spring Tool Suite?	Для упрощения процесса разработки основанных на Spring приложений в Eclipse (наиболее часто используемая IDE-среда для разработки Java-приложений), в рамках Spring создан проект Spring IDE. Проект бесплатный. Он интегрирован в Eclipse IDE, Spring IDE, Mylyn (среда разработки в Eclipse, основанная на задачах), Maven for Eclipse, AspectJ Development Tool.
Что такое контейнер?	Container создаёт объекты, связывает их вместе, настраивает и управляет ими от создания до момента уничтожения. Spring Container получает инструкции какие объекты инстанциировать и как их конфигурировать через метаданные: XML, Аннотации или Java код . Spring BeanFactory Container Это самый простой контейнер, который обеспечивает базовую поддержку DI и который основан на интерфейсе org.springframework.beans.factory.BeanFactory. Такие интерфейсы, как BeanFactoryAware и DisposableBean всё ещё присутствуют в Spring для обеспечения обратной совместимости. Бины создаются при вызове метода getBean(). Наиболее часто используемая реализация интерфейса BeanFactory - XmlBeanFactory. XmlBeanFactory получает метаданные из конфигурационного XML файла и использует его для создания настроенного приложения или системы. BeanFactory обычно используется тогда, когда ресурсы ограничены (мобильные устройства). Поэтому, если ресурсы не сильно ограничены, то лучше использовать ApplicationContext. Spring ApplicationContext Container ApplicationContext является более сложным и более продвинутым Spring Container-ом. Наследует BeanFactory и так же загружает бины, связывает их вместе и конфигурирует их определённым образом. Но кроме этого, ApplicationContext обладает дополнительной функциональностью: общий механизм работы с ресурсами, распознание текстовых сообщений из файлов настройки и отображение событий, которые происходят в приложении различными способами. Этот контейнер определяется интерфейсом org.springframework.context.ApplicationContext.
Что такое Spring бин?	Термин бин (англ. Bean) - в Spring используется для ссылки на любой компонент, управляемый контейнером. Обычно бины на определенном уровне придерживаются спецификации JavaBean, но это не обязательно особенно если для связывания бинов друг с другом планируется применять Constructor Injection. Для получения экземпляра бина используется ApplicationContext. IoC контейнер управляет жизненным циклом спринг бина, областью видимости и внедрением.
Какое значение имеет конфигурационный файл Spring Bean?	Конфигурационный файл спринг определяет все бины, которые будут инициализированы в Spring Context. При создании экземпляра Spring ApplicationContext будет прочитан конфигурационный xml файл и выполнены указанные в нем необходимые инициализации. Отдельно от базовой конфигурации, в файле могут содержаться описание перехватчиков (interceptors), view resolvers, настройки локализации и др...
Каковы различные способы настроить класс как Spring Bean?	Существует несколько способов работы с классами в Spring: XML конфигурация: Java based конфигурация. Все настройки и указания бинов прописываются в java коде: Annotation based конфигурация. Можно использовать внутри кода аннотации @Component, @Service, @Repository, @Controller для указания классов в качестве спринг бинов. Для их поиска и управления контейнером прописывается настройка в xml файле:
Какие вы знаете различные scope у Spring Bean?	В Spring предусмотрены различные области времени действия бинов: Singleton Prototype  Request  Session  Application  WebSocket - жизненный цикл WebSocket
Что знаете про scope Singleton	Может быть создан только один экземпляр бина. Этот тип используется спрингом по умолчанию, если не указано другое. Следует осторожно использовать публичные свойства класса, т.к. они не будут потокобезопасными. Spring создает Singleton бины при загрузке контекста и присваивает им имена (иначе, ID бина). Эта область видимости называется Singleton, поскольку при обращении к конкретному бину мы всегда получаем один и тот же экземпляр. Но будьте внимательны! В контексте Spring может существовать несколько экземпляров одного типа, но с разными именами. Я особенно акцентирую этот момент. Вероятно, для обозначения шаблонов проектирования вам уже встречалось слово «одиночка» (синглтон). Если нет, то вы не спутаете его с одиночной областью видимости бинов — можете пропустить следующий абзац.
Что знаете про scope Prototype	Каждый раз, когда запрашивается ссылка на прототипный бин, Spring создает новый экземпляр объекта. В случае прототипных бинов Spring не создает сам объект и не управляет им. Фреймворк управляет только типом объекта и создает новый экземпляр всякий раз, когда какой-либо объект запрашивает ссылку на этот бин..
Что знаете про scope Request	Spring создает отдельный экземпляр класса бина для каждого HTTP-запроса. Конкретный экземпляр существует только для конкретного HTTP-запроса. Для каждого следующего HTTP-запроса (от того же или другого клиента) создается и используется новый бин
Что знаете про scope Session	Spring создает экземпляр и хранит его в памяти сервера в течение всей HTTP-сессии. Фреймворк связывает этот экземпляр в контексте с сессией данного клиента. Бин с областью видимости в рамках сессии — это управляемый Spring объект, для которого фреймворк создает экземпляр, привязанный к текущей HTTP-сессии. Когда клиент посылает запрос на сервер, сервер выделяет в памяти место для этого запроса на все время сессии, к которой данный запрос относится. Spring создает экземпляр бина с областью видимости в рамках сессии в начале HTTP-сессии для данного клиента. Этот экземпляр может многократно использоваться одним и тем же клиентом, пока HTTP-сессия остается активной. Данные в атрибутах бина с областью видимости в рамках сессии доступны для всех запросов клиента в рамках сессии. Такой способ хранения данных позволяет не потерять информацию о том, что делает пользователь, пока переходит по страницам приложения. При всех запросах, передаваемых в рамках одной HTTP-сессии, клиент получает доступ к одному и тому же экземпляру бина. У каждого пользователя есть своя сессия, поэтому они получают доступ к собственным бинам, имеющим область видимости в рамках сессии. Потратим некоторое время на анализ
Что знаете про scope Application	Экземпляр является уникальным в контексте приложения и доступен все время работы приложения. Бин с областью видимости Application доступен для всех запросов от всех клиентов . Он похож на Singleton. Различие состоит в том, что в данном случае нельзя создать в контексте несколько экземпляров. Кроме того, когда мы говорим о жизненном цикле бинов Application (включая область видимости в рамках всего веб-приложения), отправной точкой всегда являются HTTP-запросы. В случае бинов с областью видимости в рамках приложения возникают те же проблемы конкурентности, которые были описаны для Singleton бинов. Желательно, чтобы атрибуты Singleton бинов были неизменяемыми. Тот же совет касается и бинов с областью видимости Application. Но если сделать атрибуты неизменяемыми, вместо бина с областью видимости Application можно просто использовать Singleton.
Как связаны различные скоупы и многопоточность?	Prototype Scope не потокбезопасный, т.к. он не гарантирует что один и тот же экземпляр будет вызываться только в 1 потоке. Singleton Scope же наоборот потокобезопасный.
Как создаются бины: сразу или лениво? Как изменить это поведение?	Singleton-бины обычно создаются сразу при сканировании.Prototype-бины обычно создаются только после запроса. Чтобы указать способ инициализации, можно использовать аннотацию @Lazy. Она ставится на @Bean-методы, на @Configuration-классы, или на @Component-классы.В зависимости от параметра(true или false), который принимает аннотация, инициализация будет или ленивая, или произойдет сразу. По умолчанию(т.е. без указания параметра) используется true.
Что будет если бин с одним скоупом внедрить в бин с другим скоупом?	Singleton bean можно внедрять в любой другой бин. В сам singleton можно внедрить только prototype или singleton.Если внедрять prototype, то для каждого singleton будет создан уникальный prototype. Prototype может быть зависимостью для любого бина.Внедрять можно только singleton или prototype.
Как работает инъекция прототипа в синглтон?	 В аннотации @Scope кроме самого scopeName доступен второй параметр - proxyMode. По умолчанию его значение NO - прокси не создается. Но если указать INTERFACES или TARGET_CLASS, то под @Autowired будет внедряться не сам объект, а сгенерированный фреймворком прокси. И когда проксируемый бин имеет скоуп prototype, то объект внутри прокси будет пересоздаваться при каждом обращении.Spring предоставляет интерфейс ObjectFactory<T> для создания объектов по требованию заданного типа: public class SingletonObjectFactoryBean {  @Autowired private ObjectFactory<PrototypeBean> prototypeBeanObjectFactory; public PrototypeBean getPrototypeInstance() {  return prototypeBeanObjectFactory.getObject() } } Давайте посмотрим на метод getPrototypeInstance(); GetObject() возвращает совершенно новый экземпляр PrototypeBean для каждого запроса. Здесь у нас больше контроля над инициализацией прототипа. Кроме того, ObjectFactory является частью фреймворка; это означает, что для использования этой опции не требуется дополнительной настройки. ObjectProvider, расширение существующего интерфейса ObjectFactory с удобными сигнатурами, такими как getIfAvailable и getIfUnique, для извлечения компонента, только если он существует или если может быть определен один кандидат (в частности: основной кандидат в случае нескольких совпадающих компонентов).
Объясните работу BeanFactory в Spring.	BeanFactory - это реализация паттерна Фабрика, его функицональность покрывает создание бинов. Так как эта фабрика знает многие об объектах приложения, то она может создавать связи между объектами на этапе создания экземпляра. Существует несколько реализаций BeanFactory, самая используемся - "org.springframework.beans.factory.xml.XmlBeanFactory". Она загружает бины на основе конфигурационного XML-файла. Чтобы создать XmlBeanFactory передайте конструктору InputStream, например: BeanFactory factory = new XmlBeanFactory(new FileInputStream("myBean.xml")); После этой строки фабрика знает о бинах, но их экземпляры еще не созданы. Чтобы инстанцировать бин нужно вызвать метод getBean(). Например: myBean bean1 = (myBean)factory.getBean("myBean");
В чем разница между BeanFactory и ApplicationContext?	BeanFactory - это базовый, компактный контейнер с ограниченной функциональностью. Его лучше всего использовать для простых задач или при использовании машин с низким ресурсом. ApplicationContext - это расширенный, более интенсивный контейнер с расширенным интерфейсом и дополнительными возможностями, такими как AOP.  ApplicationContext загружает все бины при запуске, а BeanFactory - по требованию. ApplicationContext расширяет BeanFactory и предоставляет функции, которые подходят для корпоративных приложений: a. поддержка внедрения зависимостей на основе аннотаций; b. удобный доступ к MessageSource (для использования в интернационализации); c. публикация ApplicationEvent - для бинов, реализующих интерфейс ApplicationListener, с помощью интерфейса ApplicationEventPublisher; d. простая интеграция с функциями Spring AOP. ApplicationContext поддерживает автоматическую регистрацию BeanPostProcessor и BeanFactoryPostProcessor. Поэтому всегда желательно использовать ApplicationContext, потому что Spring 2.0 (и выше) интенсивно использует BeanPostProcessor. ApplicationContext поддерживает практически все типы scope для бинов, а BeanFactory поддерживает только два - Singleton и Prototype. В BeanFactory не будут работать транзакции и Spring AOP. Это может привести к путанице, потому что конфигурация с виду будет корректной
Как получить объекты ServletContext и ServletConfig внутри Spring Bean?	Доступны два способа для получения основных объектов контейнера внутри бина: Реализовать один из Spring*Aware (ApplicationContextAware, ServletContextAware, ServletConfigAware и др.) интерфейсов. Использовать автоматическое связывание @Autowired в спринг. Способ работает внутри контейнера спринг.
В чем роль ApplicationContext в Spring?	В то время, как BeanFactory используется в простых приложениях, Application Context - это более сложный контейнер. Как и BeanFactory он может быть использован для загрузки и связывания бинов, но еще он предоставляет: возможность получения текстовых сообщений, в том числе поддержку интернационализации; общий механизм работы с ресурсами; события для бинов, которые зарегестрированы как слушатели. Из-за большей функциональности рекомендуется использование Application Context вместо BeanFactory. Последний используется только в случаях нехватки ресурсов, например при разработке для мобильных устройств
Как получить ApplicationContext в интеграционном тесте?	Если вы используете JUnit 5, то вам нужно указать 2 аннотации: @ExtendWith(TestClass.class) — используется для указания тестового класса @ContextConfoguration(classes = JavaConfig.class) — загружает java/xml конфигурацию для создания контекста в тесте Можно использовать аннотацию @SpringJUnitConfig, которая сочетает обе эти аннотации.Для теста веб-слоя можно использовать аннотацию @SpringJUnitWebConfig.
Как завершить работу контекста в приложении?	Если это не веб-приложение, то есть 2 способа: Регистрация shutdown-hook с помощью вызова метода registerShutdownHook(), он также реализован в классе AbstractApplicationContext. Это предпочтительный способ. Можно вызвать метод close() из класса AbstractApplicationContext. В Spring Boot приложении: Spring Boot самостоятельно зарегистрирует shutdown-hook за вас.
Для чего нужен Component Scan?	Если вы понимаете как работает Component Scan, то вы понимаете Spring Первый шаг для описания Spring Beans это добавление аннотации — @Component, или @Service, или @Repository. Однако, Spring ничего не знает об этих бинах, если он не знает где искать их. То, что скажет Spring где искать эти бины и называется Component Scan. В @ComponentScan вы указываете пакеты, которые должны сканироваться. Spring будет искать бины не только в пакетах для сканирования, но и в их подпакетах.
Различия @Component, @Service, @Repository, @Controller	Они все служат для обозначения класса как Бин. @Component - Spring определяет этот класс как кандидата для создания bean. @Service - класс содержит бизнес-логику и вызывает методы на уровне хранилища. Ничем не отличается от классов с @Component. @Repository - указывает, что класс выполняет роль хранилища (объект доступа к DAO). При этом отлавливает определенные исключения персистентности и пробрасывает их как одно непроверенное исключение Spring Framework. Для этого Spring оборачивает эти классы в прокси, и в контекст должен быть добавлен класс PersistenceExceptionTranslationPostProcessor @Controller - указывает, что класс выполняет роль контроллера MVC. Диспетчер сервлетов просматривает такие классы для поиска @RequestMapping.
Как вы добавите Component Scan в Spring Boot?	@SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } @SpringBootApplication определяет автоматическое сканирование пакета, где находится класс Application Всё будет в порядке, ваш код целиком находится в указанном пакете или его подпакетах. Однако, если необходимый вам компонент находится в другом пакете, вы должны использовать дополнительно аннотацию @ComponentScan, где перечислите все дополнительные пакеты для сканирования
В чём отличие между @Component и @ComponentScan?	@Component и @ComponentScan предназначены для разных целей @Component помечает класс в качестве кандидата для создания Spring бина.@ComponentScan указывает где Spring искать классы, помеченные аннотацией @Component или его производной
Для чего используется аннотация @Bean?	В классах конфигурации Spring, @Bean используется для определения компонентов с кастомной логикой.
Почему для создания Spring beans рекомендуются интерфейсы?	Улучшенное тестирование. В тестах бин может быть заменен специальным объектом(mock или stub), который реализует интерфейс бина. Позволяет использовать механизм динамических прокси из JDK(например, при создании репозитория через Spring Data) Позволяет скрывать реализацию
Как внедряется singleton-бин?	Если в контейнере нет экземпляра бина, то вызывается @Bean-метод. Если экземпляр бина есть, то возвращается уже созданный бин.
В чём разница между @Bean и @Component?	@Bean используется в конфигурационных классах Spring. Он используется для непосредственного создания бина. @Component используется со всеми классами, которыми должен управлять Spring. Когда Spring видит класс с @Component, Spring определяет этот класс как кандидата для создания bean.
Как выглядит типичная реализция метода используя Spring?	Для типичного Spring-приложения нам необходимы следующие файлы: Интерфейс, описывающий функционал приложения Реализация интерфейса, содержащая свойства, сэттеры-гэттеры, функции и т.п. Конфигурационный XML-файл Spring'а. Клиентское приложение, которое использует функцию.
Можем ли мы применить @Autowired с не сеттерами и не конструкторами методами?	Да, конечно. @Autowired может использоваться вместе с конструкторами, сеттерами или любым другими методами. Когда Spring находит @Autowired на методе, Spring автоматически вызовет этот метод, после создания экземпляра бина. В качестве аргументов, будут подобраны подходящие объекты из контекста Spring.
Как внедрить простые значения в свойства в Spring?	Для этого можно использовать аннотацию @Value.Такие значения можно получать из property файлов, из бинов, и т.п. @Value("$some.key") public String stringWithDefaultValue; В эту переменную будет внедрена строка, например из property или из view.
Как вы решаете какой бин инжектить, если у вас несколько подходящих бинов. Расскажите о @Primary и @Qualifier?	Если есть бин, который вы предпочитаете большую часть времени по сравнению с другими, то используйте @Primary, и используйте @Qualifier для нестандартных сценариев. Если все бины имеют одинаковый приоритет, мы всегда будем использовать @Qualifier Если бин надо выбрать во время исполнения программы, то эти аннотации вам не подойдут. Вам надо в конфигурационном классе создать метод, пометить его аннотацией @Bean, и вернуть им требуемый бин.
Что такое связывание в Spring и расскажите об аннотации @Autowired?	Процесс внедрения зависимостей в бины при инициализации называется Spring Bean Wiring. Считается хорошей практикой задавать явные связи между зависимостями, но в Spring предусмотрен дополнительный механизм связывания @Autowired. Аннотация может использоваться над полем или методом для связывания по типу. Чтобы аннотация заработала, необходимо указать небольшие настройки в конфигурационном файле спринг с помощью элемента context:annotation-config.
Опишите поведение аннотации @Autowired	 Контейнер определяет тип объекта для внедрения 2) Контейнер ищет бины в контексте(он же контейнер), которые соответствуют нужному типу 3) Если есть несколько кандидатов, и один из них помечен как @Primary, то внедряется он 4) Если используется аннотации @Autowire + Qualifier, то контейнер будет использовать информацию из @Qualifier, чтобы понять, какой компонент внедрять 5) В противном случае контейнер попытается внедрить компонент, основываясь на его имени или ID 6) Если ни один из способов не сработал, то будет выброшено исключение Контейнер обрабатывает DI с помощью AutowiredAnnotationBeanPostProcessor. В связи с этим, аннотация не может быть использована ни в одном BeanFactoryPP или BeanPP. Если внедряемый объект массив, коллекция, или map с дженериком, то Spring внедрит все бины подходящие по типу в этот массив(или другую структуру данных). В случае с map ключом будет имя бина. //параметр указывает, требуется ли DI @Authowired(required = true/false)
Как можно использовать аннотацию @Autowire и в чем отличие между способами?	Ниже перечислены типы DI, которые могут быть использованы в вашем приложении: Constructor DI Setter DI Field DI DI через конструктор считается самым лучшим способом, т.к. для него не надо использовать рефлексию, а также он не имеет недостатков DI через сеттер.DI через поле не рекомендуется использовать, т.к. для этого применяется рефлексия, снижающая производительность.DI через конструктор может приводить к циклическим зависимостям. Чтобы этого избежать, можно использовать ленивую инициализацию бинов или DI через сеттер.
Аннотация Qualifier	Данная аннотация позволяет несколько специфицировать бин, который необходим для @Autowired. @Qualifier принимает один входной параметр — имя бина. @Autowired@Qualifier("specialTestBean") private TestBean bean; * This source code was highlighted with Source Code Highlighter. Эта конструкция будет искать в контексте бин с именем specialTestBean и в нашем примере мы соответственно получим исключение, так как TestBean объявлен с именем 'testBean' (@Service(«testBean»)).На основе @Qualifier можно создавать свои признаки бинов, об этом достаточно хорошо написано (и, что немаловажно, с огромным количеством примеров) в Spring Reference Manual.
Каковы различные типы автоматического связывания в Spring?	Существует четыре вида связывания в спринг: autowire byName, autowire byType, autowire by constructor, autowiring by @Autowired and @Qualifier annotations
Приведите пример часто используемых аннотаций Spring.	@Controller - класс фронт контроллера в проекте Spring MVC. @RequestMapping - позволяет задать шаблон маппинга URI в методе обработчике контроллера. @ResponseBody - позволяет отправлять Object в ответе. Обычно используется для отправки данных формата XML или JSON. @PathVariable - задает динамический маппинг значений из URI внутри аргументов метода обработчика. @Autowired - используется для автоматического связывания зависимостей в spring beans. @Qualifier - используется совместно с @Autowired для уточнения данных связывания, когда возможны коллизии (например одинаковых имен\типов). @Service - указывает что класс осуществляет сервисные функции. @Scope - указывает scope у spring bean. @Configuration, @ComponentScan и @Bean - для java based configurations. AspectJ аннотации для настройки aspects и advices, @Aspect, @Before, @After,@Around, @Pointcut и др.
Что такое профили? Какие у них причины использования?	Используя аннотацию @Profile - мы сопоставляем bean-компонент с этим конкретным профилем; аннотация просто берет имена одного (или нескольких) профилей. Отвечает за то - какие бины буду создаваться, в зависимости от профайла. Фактически реализована с помощью гораздо более гибкой аннотации @Conditional. Рассмотрим базовый сценарий - у нас есть компонент, который должен быть активным только во время разработки, но не должен использоваться в производстве. Мы аннотируем этот компонент с профилем «dev», и он будет присутствовать в контейнере только во время разработки - в производственном процессе dev просто не будет активен. Или можно задать @Profile("postgres") и @Profile("mysql"), а в application.properties указать, бин с каким профилем использовать = spring.profiles.active = mysql По умолчанию, если профиль бина не определен, то он относится к профилю "default". Spring также предоставляет способ установить профиль по умолчанию, когда другой профиль не активен, используя свойство «spring.profiles.default»
Что делает @LookUp	Используется для внедрения prototype bean в singleton bean. ПРИМЕР - Обычно бины в приложении Spring являтся синглтонами, и для внедрения зависимостей мы используем конструктор или сеттер. Но бывает и другая ситуация: имеется бин Car - синглтон (singleton bean), и ему требуется каждый раз новый экземпляр бина Passenger. То есть Car - синглтон, а Passenger - так называемый прототипный бин (prototype bean). Жизненные циклы бинов разные. Бин Car создается контейнером только раз, а бин Passenger создается каждый раз новый - допустим, это происходит каждый раз при вызове какого-то метода бина Car.Вот здесь то и пригодится внедрение бина с помощью Lookup метода. Оно происходит не при инициализации контейнера, а позднее: каждый раз, когда вызывается метод. @Component  public class Car {  @Lookup  public Passenger createPassenger() {  return null;  } public String drive(String name) {  Passenger passenger = createPassenger(); passenger.setName(name);  return "car with " + passenger.getName();  }  } Суть в том, что вы создаете метод-заглушку в бине Car и помечаете его специальным образом - аннотацией @Lookup. Этот метод должен возвращать бин Passenger, каждый раз новый. Контейнер Spring под капотом создаст подкласс и переопределит этот метод и будет вам выдавать новый экземпляр бина Passenger при каждом вызове аннотированного метода. Даже если в вашей заглушке он возвращает null (а так и надо делать, все равно этот метод будет переопределен). @Component @Scope("prototype")  public class Passenger {  private String name; public String getName() {  return name; }  public void setName(String name) {  this.name = name;  }  } Теперь при вызове метода drive() мы можем везти каждый раз нового пассажира. Имя его передаётся в аргументе метода drive(), и затем задается сеттером во вновь созданном экземпляре пассажира.
Что такое @Resource	Java-аннотация @Resource может применяться к классам, полям и методам. Она пытается получить зависимость: сначала по имени, затем по типу, затем по описанию (Qualifier). Имя извлекается из имени аннотируемого сеттера или поля, либо берется из параметра name. При аннотировании классов имя не извлекается из имени класса по умолчанию, поэтому оно должно быть указано явно. Указав данную аннотацию у полей или методов с аргументом name, в контейнере будет произведен поиск компонентов с данным именем, и в контейнере должен быть бин с таким именем: @Resource(name="namedFile") private File defaultFile; Если указать её без аргументов, то Spring Framework поможет найти бин по типу. Если в контейнере несколько бинов-кандидатов на внедрение, то нужно использовать аннотацию @Qualifier: @Resource  @Qualifier("defaultFile")  private File dependency1;  @Resource  @Qualifier("namedFile")  private File dependency2; Разница с @Autowired: ищет бин сначала по имени, а потом по типу; не нужна дополнительная аннотация для указания имени конкретного бина; @Autowired позволяет отметить место вставки бина как необязательное @Autowired(required = false); при замене Spring Framework на другой фреймворк, менять аннотацию @Resource не нужно
Что делает @Inject	Размещается над полями, методами, и конструкторами с аргументами. @Inject как и @Autowired в первую очередь пытается подключить зависимость по типу, затем по описанию и только потом по имени. Это означает, что даже если имя переменной ссылки на класс отличается от имени компонента, но они одинакового типа, зависимость все равно будет разрешена: @Inject  private ArbitraryDependency fieldInjectDependency; //fieldInjectDependency - отличается от имени компонента, настроенного в контексте приложения:  @Bean  public ArbitraryDependency injectDependency() { ArbitraryDependency injectDependency = new ArbitraryDependency();  return injectDependency;  } Разность имён injectDependency и fieldInjectDependency не имеет значения, зависимость будет подобрана по типу ArbitraryDependency. Если в контейнере несколько бинов-кандидатов на внедрение, то нужно использовать аннотацию @Qualifier: @Inject  @Qualifier("defaultFile")  private ArbitraryDependency defaultDependency;  @Inject  @Qualifier("namedFile")  private ArbitraryDependency namedDependency;  //При использовании конкретного имени (Id) бина используем @Named:  @Inject  @Named("yetAnotherFieldInjectDependency")  private ArbitraryDependency yetAnotherFieldInjectDependency
@Autowired vs @Resource vs @Inject	Аннотации для внедрения зависимостей. @Resource (java) пытается получить зависимость: по имени, по типу, затем по описанию. Имя извлекается из имени аннотируемого сеттера или поля, либо берется из параметра name. @Inject (java) или @Autowired (spring) в первую очередь пытается подключить зависимость по типу, затем по описанию и только потом по имени.
Что такое Java-конфигурация? Как она применяется?	Чтобы создать класс с конфигурацией на основе Java-кода, нужно аннотировать его с помощью@Configuration. Этот класс будет содержать фабричные методы для создания бинов в контейнере.Эти методы должны быть аннотированы аннотацией @Bean. Пример: @Configuration  public class DSConfig {  @Bean  public DataSource dataSource() {  return DataSourceBuilder .create()  .username("")  .password("")  .url("")  .driverClassName("")  .build();  } } Этот класс поместит в контейнер экземпляр класса DataSource. Позднее его можно будет использовать при доступе к базе данных.
Можем ли мы послать объект как ответ метода обработчика контроллера?	Да, это возможно. Для этого используется аннотация @ResponseBody. Так можно отправлять ответы в виде JSON, XML в restful веб сервисах.
Является ли Spring bean потокобезопасным?	По умолчанию бин задается как синглтон в Spring. Таким образом все публичные переменные класса могут быть изменены одновременно из разных мест. Так что - нет, не является. Однако поменяв область действия бина на request, prototype, session он станет потокобезопасным, но это скажется на производительности.
Как создать ApplicationContext в программе Java?	В независимой Java программе ApplicationContext можно создать следующим образом: FileSystemXmlApplicationContext - Загружает данные о бине из XML файла. При использовании этой реализации в конструкторе необходимо указать полный адрес конфигурационного файла. ClassPathXmlApplicationContext - Этот контейнер также получает данные о бине из XML файла. Но в отличие от FileSystemApplicationContext, в этом случае необходимо указать относительный адрес конфигурационного файла (CLASSPATH). AnnotationConfigApplicationContext — метаданные конфигурируются с помощью аннотаций прямо на классах. WebApplicationContext — для веб-приложений GenericGroovyApplicationContext - эта конфигурация работает по сути так же, как и Xml, только с Groovy-файлами. К тому же, GroovyApplicationContext нормально работает и с Xml-файлом. Принимает на в
Можем ли мы иметь несколько файлов конфигурации Spring?	С помощью указания contextConfigLocation можно задать несколько файлов конфигурации Spring. Параметры указываются через запятую или пробел: Поддерживается возможность указания нескольких корневых файлов конфигурации Spring: Файл конфигурации можно импортировать:
Как внедрить java.util.Properties в Spring Bean?	Для возможности использования Spring EL для внедрения свойств (properties) в различные бины необходимо определить propertyConfigure bean, который будет загружать файл свойств. Или через аннотации @Value
Что предпочитаете использовать для конфигурации Spring - xml или аннотирование?	Предпочитаю аннотации, если кодовая база хорошо описывается такими элементами, как @Service, @Component, @Autowired Однако когда дело доходит до конфигурации, у меня нет каких-либо предпочтений. Я бы оставил этот вопрос команде.
Можно ли использовать xyz.xml вместо applicationContext.xml?	ContextLoaderListener - это ServletContextListener, который инициализируется когда ваше web-приложение стартует. По-умолчанию оно загружает файл WEB-INF/applicationContext.xml. Вы можете изменить значение по-умолчанию, указав параметр contextConfigLocation.
Что делает @PostConstruct	Spring вызывает методы, аннотированные @PostConstruct, только один раз, сразу после инициализации свойств компонента. За данную аннотацию отвечает один из BeanPostProcessor-ов. Метод, аннотированный @PostConstruct, может иметь любой уровень доступа, может иметь любой тип возвращаемого значения (хотя тип возвращаемого значения игнорируется Spring-ом), метод не должен принимать аргументы. Он также может быть статическим, но преимуществ такого использования метода нет, т.к. доступ у него будет только к статическим полям/методам бина, и в таком случае смысл его использования для настройки бина пропадает. Одним из примеров использования @PostConstruct является заполнение базы данных. Например, во время разработки нам может потребоваться создать пользователей по умолчанию.
Что делает @PreDestroy	Метод, аннотированный @PreDestroy, запускается только один раз, непосредственно перед тем, как Spring удаляет наш компонент из контекста приложения. Как и в случае с @PostConstruct, методы, аннотированные @PreDestroy, могут иметь любой уровень доступа, но не могут быть статическими. Целью этого метода может быть освобождение ресурсов или выполнение любых других задач очистки до уничтожения бина, например, закрытие соединения с базой данных. Обратите внимание, что аннотации @PostConstruct и @PreDestroy являются частью Java EE, а именно пакета javax.annotation модуля java.xml.ws.annotation. И поскольку Java EE устарела в Java 9, то с этой версии пакет считается устаревшим (Deprecated). С Java 11 данный пакет вообще удален, поэтому мы должны добавить дополнительную зависимость для использования этих аннотаций: <dependency>  <groupId>javax.annotation</groupId> <artifactId>javax.annotation-api</artifactId> <version>1.3.2</version>  </dependency>
Этапы инициализации контекста Spring	1. Парсирование конфигурации и создание BeanDefinition 2. Настройка созданных BeanDefinition 3. Создание кастомных FactoryBean (только для XML-конфигурации) 4. Создание экземпляров бинов 5. Настройка созданных бинов 6. Бины готовы к использованию 7. Закрытие контекста
Этап Парсирование конфигурации и создание BeanDefinition	Цель первого этапа — это создание всех BeanDefinition. Объекты BeanDefinition — это набор метаданных будущего бина, макет, по которому нужно будет создавать бин в случае необходимости. То есть для каждого бина создается свой объект BeanDefinition, в котором хранится описание того, как создавать и управлять этим конкретным бином. Проще говоря, сколько бинов в программе - столько и объектов BeanDefinition, их описывающих. BeanDefinition содержат (среди прочего) следующие метаданные: Имя класса с указанием пакета: обычно это фактический класс бина. Элементы поведенческой конфигурации бина, которые определяют, как бин должен вести себя в контейнере (scope, обратные вызовы жизненного цикла и т.д.). Ссылки на другие bean-компоненты, которые необходимы для его работы. Эти ссылки также называются зависимостями. Другие параметры конфигурации для установки во вновь созданном объекте - например, ограничение размера пула или количество соединений, используемых в бине, который управляет пулом соединений. Эти метаданные преобразуются в набор свойств, которые составляют каждое BeanDefinition. При конфигурации через аннотации с указанием пакета для сканирования или JavaConfig используется класс AnnotationConfigApplicationContext. Если заглянуть во внутрь AnnotationConfigApplicationContext, то можно увидеть два поля. private final AnnotatedBeanDefinitionReader reader; private final ClassPathBeanDefinitionScanner scanner; ClassPathBeanDefinitionScanner сканирует указанный пакет на наличие классов помеченных аннотацией @Component (или любой другой аннотацией которая включает в себя @Component). Найденные классы парсируются и для них создаются BeanDefinition.Чтобы сканирование было запущено, в конфигурации должен быть указан пакет для сканирования. @ComponentScan({"package.name"}) AnnotatedBeanDefinitionReader работает в несколько этапов. Первый этап — это регистрация всех @Configuration для дальнейшего парсирования. Если в конфигурации используются Conditional, то будут зарегистрированы только те конфигурации, для которых Condition вернет true. Аннотация Conditional появилась в четвертой версии спринга. Она используется в случае, когда на момент поднятия контекста нужно решить, создавать бин/конфигурацию или нет. Причем решение принимает специальный класс, который обязан реализовать интерфейс Condition. Второй этап — это регистрация специального BeanFactoryPostProcessor, а именно BeanDefinitionRegistryPostProcessor, который при помощи класса ConfigurationClassParser парсирует JavaConfig и создает BeanDefinition, создаёт граф зависимостей (между бинами) и создаёт: Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>(256); в которой хранятся все описания бинов, обнаруженных в ходе парсинга конфигурации.
Этап Настройка созданных BeanDefinition	После первого этапа у нас имеется Map, в котором хранятся BeanDefinition. Архитектура спринга построена таким образом, что у нас есть возможность повлиять на то, какими будут наши бины еще до их фактического создания, иначе говоря мы имеем доступ к метаданным класса. Для этого существует специальный интерфейс BeanFactoryPostProcessor, реализовав который, мы получаем доступ к созданным BeanDefinition и можем их изменять. В этом интерфейсе всего один метод. public interface BeanFactoryPostProcessor { void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException; } Метод postProcessBeanFactory принимает параметром ConfigurableListableBeanFactory. Данная фабрика содержит много полезных методов, в том числе getBeanDefinitionNames, через который мы можем получить все BeanDefinitionNames, а уже потом по конкретному имени получить BeanDefinition для дальнейшей обработки метаданных. Давайте разберем одну из родных реализаций интерфейса BeanFactoryPostProcessor. Обычно, настройки подключения к базе данных выносятся в отдельный property файл, потом при помощи PropertySourcesPlaceholderConfigurer они загружаются и делается inject этих значений в нужное поле. Так как inject делается по ключу, то до создания экземпляра бина нужно заменить этот ключ на само значение из property файла. Эта замена происходит в классе, который реализует интерфейс BeanFactoryPostProcessor. Название этого класса — PropertySourcesPlaceholderConfigurer. Весь этот процесс можно увидеть на рисунке ниже.Давайте еще раз разберем что же у нас тут происходит. У нас имеется BeanDefinition для класса ClassName. Код класса приведен ниже. @Component  public class ClassName {  @Value("${host}")  private String host;  @Value("${user}")  private String user;  @Value("${password}")  private String password;  @Value("${port}")  private Integer port;  } Если PropertySourcesPlaceholderConfigurer не обработает этот BeanDefinition, то после создания экземпляра ClassName, в поле host проинжектится значение — "${host}" (в остальные поля проинжектятся соответсвующие значения). Если PropertySourcesPlaceholderConfigurer все таки обработает этот BeanDefinition, то после обработки, метаданные этого класса будут выглядеть следующим образом. @Component  public class ClassName {  @Value("127.0.0.1")  private String host;  @Value("root")  private String user;  @Value("root")  private String password;  @Value("27017")  private Integer port;  } Соответственно в эти поля проинжектятся правильные значения.Для того что бы PropertySourcesPlaceholderConfigurer был добавлен в цикл настройки созданных BeanDefinition, нужно сделать одно из следующих действий. @Configuration @PropertySource("classpath:property.properties")  public class DevConfig {  @Bean public static PropertySourcesPlaceholderConfigurer configurer() { return new PropertySourcesPlaceholderConfigurer();  }  } PropertySourcesPlaceholderConfigurer обязательно должен быть объявлен как static. Без static у вас все будет работать до тех пор, пока вы не попробуете использовать @Value внутри класса @Configuration.
Этап Создание экземпляров бинов	Сначала BeanFactory из коллекции Map с объектами BeanDefinition вначале достает определения этих BeanPostProcessor-ов, создает их и кладет в сторону, т.е. в первую очередь он создаст те бины, которые имплементируют интерфейс BeanPostProcessor и с их помощью будет потом настраивать все остальные бины. Создаются экземпляры бинов через BeanFactory на основе ранее созданных BeanDefinition
Этап Настройка созданных бинов	На данном этапе бины уже созданы, мы можем лишь их донастроить. Интерфейс BeanPostProcessor позволяет вклиниться в процесс настройки наших бинов до того, как они попадут в контейнер. ApplicationContext автоматически обнаруживает любые бины с реализацией BeanPostProcessor и помечает их как "post-processors" для того, чтобы создать их определенным способом. Например, в Spring есть реализации BeanPostProcessor-ов, которые обрабатывают аннотации @Autowired, @Inject, @Value и @Resource. Интерфейс несет в себе несколько методов. public interface BeanPostProcessor {  Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;  Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;  } Оба метода вызываются для каждого бина. У обоих методов параметры абсолютно одинаковые. Разница только в порядке их вызова. Первый вызывается до init-метода, воторой, после. Важно понимать, что на данном этапе экземпляр бина уже создан и идет его донастройка.  Тут есть два важных момента: 1) Оба метода в итоге должны вернуть бин. Если в методе вы вернете null, то при получении этого бина из контекста вы получите null, а поскольку через бинпостпроцессор проходят все бины, после поднятия контекста, при запросе любого бина вы будете получать фиг, в смысле null.Если вы хотите сделать прокси над вашим объектом (аспекты, транзакции, и т.д. — некая бизнес логика), то имейте ввиду, что это принято делать после вызова init метода, иначе говоря это нужно делать в методе postProcessAfterInitialization.Если нужно заполнить бины через маркерные интерфейсы или настраивает объект, реализовывают метод postProcessBeforeInitialization (Object bean, String beanName), Прокси — это класс-декорация над бином. Например, мы хотим добавить логику нашему бину, но джава-код уже скомпилирован, поэтому нам нужно на лету сгенерировать новый класс. Этим классом мы должны заменить оригинальный класс так, чтобы никто не заметил подмены. Есть два варианта создания этого класса: либо он должен наследоваться от оригинального класса (CGLIB) и переопределять его методы, добавляя нужную логику; либо он должен имплементировать те же самые интерфейсы, что и первый класс(Dynamic Proxy). По конвенции спринга, если какой-то из BeanPostProcessor-ов меняет что-то в классе, то он должен это делать на этапе postProcessAfterInitialization(). Таким образом мы уверены, что initMethod у данного бина, работает на оригинальный метод, до того, как на него накрутился прокси. Хронология событий: Сначала сработает метод postProcessBeforeInitialization() всех имеющихся BeanPostProcessor-ов. Затем, при наличии, будет вызван метод, аннотированный @PostConstruct. Если бин имплементирует InitializingBean, то Spring вызовет метод afterPropertiesSet() - не рекомендуется к использованию как устаревший. При наличии, будет вызван метод, указанный в параметре initMethod аннотации @Bean. В конце бины пройдут через postProcessAfterInitialization (Object bean, String beanName). Именно на данном этапе создаются прокси стандартными BeanPostProcessor-ами. Затем отработают наши кастомные BeanPostProcessor-ы и применят нашу логику к прокси-объектам. После чего все бины окажутся в контейнере, который будет обязательно обновлен методом refresh(). Но даже после этого мы можем донастроить наши бины ApplicationListener-ами. Теперь всё Пример: Порядок в котором будут вызваны BeanPostProcessor не известен, но мы точно знаем что выполнены они будут последовательно. Для того, что бы лучше понять для чего это нужно, давайте разберемся на каком-нибудь примере. При разработке больших проектов, как правило, команда делится на несколько групп. Например первая группа разработчиков занимается написанием инфраструктуры проекта, а вторая группа, используя наработки первой группы, занимается написанием бизнес логики. Допустим второй группе понадобился функционал, который позволит в их бины инжектить некоторые значения, например случайные числа.На первом этапе будет создана аннотация, которой будут помечаться поля класса, в которые нужно проинжектить значение. @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD)  public @interface InjectRandomInt {  int min() default 0;  int max() default 10;  } По умолчанию, диапазон случайных числе будет от 0 до 10. Затем, нужно создать обработчик этой аннотации, а именно реализацию BeanPostProcessor для обработки аннотации InjectRandomInt. @Component  public class InjectRandomIntBeanPostProcessor implements BeanPostProcessor {  @Override  public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {  Field[] fields = bean.getClass().getDeclaredFields(); for (Field field : fields) {  if (field.isAnnotationPresent(InjectRandomInt.class)) {  field.setAccessible(true);  InjectRandomInt annotation = field.getAnnotation(InjectRandomInt.class);  ReflectionUtils.setField(field, bean, getRandomIntInRange(annotation.min(),annotation.max()));  }  }  return bean;  }  @Override  public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {  return bean;  } private int getRandomIntInRange(int min, int max) { return min + (int)(Math.random() * ((max - min) + 1)); }  } Код данного BeanPostProcessor достаточно прозрачен, поэтому мы не будем на нем останавливаться, но тут есть один важный момент. BeanPostProcessor обязательно должен быть бином, поэтому мы его либо помечаем аннотацией @Component, либо регестрируем его в xml конфигурации как обычный бин.Первая группа разработчиков свою задачу выполнила. Теперь вторая группа может использовать эти наработки. @Component @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)  public class MyBean {  @InjectRandomInt  private int value1;  @InjectRandomInt(min = 100, max = 200)  private int value2;  private int value3;  @Override  public String toString() {  return "MyBean{" + "value1=" + value1 + ", value2=" + value2 + ", value3=" + value3 + '}';  }  } В итоге, все бины типа MyBean, получаемые из контекста, будут создаваться с уже проинициализированными полями value1 и value2. Также тут стоить отметить, этап на котором будет происходить инжект значений в эти поля будет зависеть от того какой @ Scope у вашего бина. SCOPE_SINGLETON — инициализация произойдет один раз на этапе поднятия контекста. SCOPE_PROTOTYPE — инициализация будет выполняться каждый раз по запросу. Причем во втором случае ваш бин будет проходить через все BeanPostProcessor-ы что может значительно ударить по производительности.
Этап Бины готовы к использованию	Их можно получить с помощью метода ApplicationContext#getBean().
Этап Закрытие контекста	Когда контекст закрывается (метод close() из ApplicationContext), бин уничтожается. Если в бине есть метод, аннотированный @PreDestroy, то перед уничтожением вызовется этот метод. Если бин имплементирует DisposibleBean, то Spring вызовет метод destroy() - не рекомендуется к использованию как устаревший. Если в аннотации @Bean определен метод destroyMethod, то будет вызван и он.
Что такое BeanDefinitions ?	Что такое BeanDefinitions ? В первую очередь это интерфейс.Можно представить его в виде map, который в качестве ключа хранит id бина, а в качестве значения — его декларацию.Что такое декларация ? Это то, из какого класса надо создавать бин, есть ли у него init() метод и как он называется, какие у него проперти и все остальные подробности бина, которые мы прописываем в XML. Другими словами это интерфейс, через который можно получить доступ к метаданным будущего бина.
BeanDefinitions имплементаций.	У интерфейса BeanDefinitions есть много имплементаций.Основные из них, это: — AbstractBeanDefinition — AnnotatedBeanDefinition — если используем аннотацию @Component — ConfigurationClassBeanDefinition — с помощью него мы можем узнать то, что нам нужно (какого типа и из какого класса создался бин). — GenericBeanDefinition — ScannedGenericBeanDefinition
Что такое BeanFactory	BeanFactory — важный элемент структуры, т.к. он отвечает за создание и хранение всех объектов (занимается созданием экземпляров бинов, которые создаются на основе ранее созданных BeanDefinition). Это generic интерфейс. Он изначально был сделан для того, чтобы у разработчика была возможность управлять процессом создания бинов.После создания BeanDefinition, BeanFactory начинает по ним работать, создает из классов объекты и все бины складывает в контейнер.
Что такое BeanPostProcessor	BeanPostProcessor — это интерфейс. Он позволяет настраивать бины прежде чем они попадут в контейнер. Здесь задействован паттерн "Change Of Responsibility" ("цепочка обязанностей""). У этого интерфейса обязательно нужно переопределить 2 метода, если вы собираетесь его имплементировать:— postProcessBeforeInitialization() — вызывается до init() метода.— postProcessAfterInitialization() — вызывается после init() метода.
Зачем нужен ApplicationContextAware	ApplicationContextAware - это интерфейс, и, если верить документации Spring (лучше верить) он должен реализовываться всеми объектами, которые хотят знать в каком ApplicationContext они запущены. Вроде бы звучит просто. Интерфейс определяет единственный метод setApplicationContext(AppicationContext applicationContext). Приступим к его реалиации!  @Service("BeanUtil") public class BeanUtil implements ApplicationContextAware {  private static ApplicationContext context;  @Override  public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {  context = applicationContext; }  public static <T> T getBean(Class<T> beanClass) { return context.getBean(beanClass); }  public static <T> Object getBean(String className) { return context.getBean(className); } } Создали класс BeanUtil, в нём - статическая переменная для хранения ссылки на текущий контекст. Переопределили метод setApplicationContext и создали свой метод getBean, который по имени класса возвращает бин из текущего контекста. Все и вправду легко. Само собой, чтобы дать Spring корректно внедрить все зависимости, те классы-компоненты контекста, в которых вызывается getBean, должны собираться после того, как собран сам BeanUtil, иначе на старте контекста можем поймать самый настоящий NullPointerException (это, кстати, самое популярное исключение в мире Java). Для этого на зависимых классах можем указать аннотацию @DependsOn: @Bean @DependsOn("BeanUtil") public DbClient clusterClient() { return new DBClient(); }
Что такое ApplicationListener	ApplicationListener - Он умеет слушать контекст Spring, все "events", которые с ним происходят. Работает на этапе, когда все уже создано. Также он имеет дженерики <>, в которых мы можем указать что конкретно мы хотим слушать. Обозначается аннотацией @EventListener. — contextStartedEvent — контекст начал свое построение (не построился, а только начал) — contextRefreshedEvent — когда контекст заканчивает свое построение, он всегда делает refresh. — contextStoppedEvent — contextClosedEvent
CommandLineRunner и ApplicationRunner	Эти интрефейсы используются для запуска логики при запуске приложения, после создания экземпляра контекста приложения Spring. ApplicationRunner.run() и CommandLineRunner.run() выполнятся сразу после создания applicationcontext и до запуска приложения. Оба они обеспечивают одинаковую функциональность, и единственное различие между CommandLineRunner и ApplicationRunner состоит в том, что CommandLineRunner.run() принимает String array[], тогда как ApplicationRunner.run() принимает ApplicationArguments в качестве аргумента. @Component public class CommandLineAppStartupRunner implements CommandLineRunner {  private static final Logger LOG = LoggerFactory.getLogger(CommandLineAppStartupRunner.class); public static int counter;  @Override  public void run(String...args) throws Exception { LOG.info("Increment counter");  counter++;  }  } Можно запускать несколько CommandLineRunner одновременно, например чтобы распаралелить сложную логику. Управлять их порядком через @Order. Каждый Runner может иметь свои собственные зависимости