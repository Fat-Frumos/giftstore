Почему службы REST должны быть stateless	Потому что это обеспечивает отказоустойчивость и масштабируемость: запросы от одного клиента могут обрабатываться на разных серверах.
Какие запросы кэшируются и как их можно реализовать	GET-запросы кэшируются. Его можно определить, добавив HTTP-заголовок Cache-Control.
Почему события можно использовать для подключаемой архитектуры	События предоставляют возможность прикрепить дополнительный функционал к любой части приложения. Слушатели событий позволяют избежать изменения основной части приложения. События позволяют отделить компоненты в системе, разделив владение данными по доменам. Это позволяет добавлять новые функции через подключаемое ядро ​​и позволяет заинтересованным сторонам получать уведомления об изменениях состояния путем подписки на опубликованные события.
Как заставить прослушиватели событий работать в отдельных потоках	По умолчанию прослушиватели событий работают в основном потоке. Вы можете определить bean-компонент ApplicationEventMulticaster в @Configuration, чтобы разрешить использование нескольких потоков. Он позволяет запускать несколько прослушивателей событий параллельно и берет потоки из пула потоков, делая потоки повторно используемыми.
Каковы варианты использования ETag	используется, когда мы извлекаем одни и те же данные и нам нужно знать, были ли они изменены. Если это не так, мы получим HTTP-статус 304 (Not Modified).
Почему значение ETag представляет собой хеш-значение объекта	Это потому, что данные можно получить разными способами, но если хэш не изменился, мы предполагаем, что и данные не изменились. Значение ETag представляет собой хэш-значение объекта, поскольку это значение представляет состояние сущности. Как правило, значение ETag представляет собой хэш содержимого, хэш метки времени последней модификации или просто номер версии1. Сервер может прикрепить HTTP-заголовок ETag к ответу при запросе ресурса, такой ETag будет представлять состояние ресурса.
Почему использование ETag может повысить производительность приложения	Поскольку сервер не передает все данные клиенту, если они не были изменены (и, следовательно, сервер должен передавать меньше данных)
Как мы можем использовать ETags в приложении Spring	Нам нужно добавить ShallowEtagHeaderFilter для генерации ETag на стороне сервера и выполнения запросов GET на стороне клиента с HTTP-заголовком If-None-Match: ETag.
Можете ли вы привести несколько примеров, когда события REST полезны?	В Spring Data REST события REST могут определять дополнительное поведение для обработки объекта, например, его можно использовать для проверки объекта перед его сохранением (обработчик событий должен генерировать исключение, если проверка не удалась, и это предотвратит изменение данных в базу данных).
Можно ли использовать события REST с контроллером REST	Нет, REST-события могут использоваться только для Data REST с автоматически сгенерированным REST-контроллером и позволяют определить некоторое поведение в дополнение к по умолчанию.
Почему мы должны использовать HATEOAS? Каковы варианты использования	HATEOAS позволяет нам предоставлять автоматически сгенерированную документацию службы REST: мы получаем не только данные, но и некоторые ссылки «куда идти», например, на веб-странице. HATEOAS дает более высокий уровень абстракции: мы можем не полагаться на точных жестко закодированных URL-адресах, но вместо этого он может быть сгенерирован автоматически (например, указать на разные серверы). HATEOAS может предоставить некоторые стандартные ссылки, такие как «я», чтобы получить фактические данные (перечитать) или "details", чтобы получить более подробные данные. Некоторые данные JSON можно заменить ссылкой на дополнительные данные, например, мы можем опустить полный адрес человека, а добавить ссылку "/address" для получения подробной информации, если это необходимо. .
Что нам нужно, чтобы добавить ссылки HATEOAS	Нам нужно реализовать RepresentationModelAssembler, который включает в себя 2 метода: toModel(), который преобразует объект в EntityModel и добавляет ссылку на один объект, и toCollectionModel(), который преобразует список объектов в коллекцию EntityModel со ссылками, прикрепленными ко всей коллекции. .
Почему RestTemplate устарел? Должны ли мы избегать этого	Он устарел, поскольку не поддерживает реактивное программирование, и команда Spring рекомендует использовать более универсальный и современный WebClient. Тем не менее, многие проекты все еще используют RestTemplate, и, скорее всего, он не скоро станет устаревшим.
Зачем нам нужно вызывать метод block() в WebClient	Поскольку WebClient имеет реактивный интерфейс, нам нужно вызвать block(), чтобы дождаться получения данных. В противном случае мы получим разблокирующее поведение, и для его обработки потребуются реактивные операторы.
Что такое BodyExtractors в WebClient и когда мы должны его использовать	BodyExtractors позволяет десериализовать полученные данные (обычно JSON). Мы должны использовать его для чтения и обработки ответа от сервера.
Зачем нужны методы BodyExtractors.toMono() и BodyExtractors.toFlux()? Какой параметр они принимают	Эти методы необходимы для чтения ответа сервера и преобразования одного объекта JSON с помощью BodyExtractors.toMono() или массива JSON с помощью BodyExtractors.toFlux() в объект или коллекцию Java. В качестве параметра он принимает класс данных, которые мы должны получить, например Person.class: BodyExtractors.toMono(Person.class) десериализует JSON в объект класса Mono<Person>
Почему рекомендуется использовать Open Feign	работает намного быстрее, чем RestTemplate, и требует гораздо меньше кода. Это позволяет определить только интерфейс клиента REST для эффективного использования, так же, как это делается с данными. когда вы хотите взаимодействовать с внешними системами и использовать внешние API в приложении Spring Boot. Фреймворк можно легко интегрировать с Spring Boot, что позволяет быстро разрабатывать и тестировать свои системы с помощью внешних API. Это может сэкономить время и усилия по сравнению с написанием и обслуживанием клиентов веб-служб вручную.
Что такое Open API и какие версии Open API можно использовать	Open API это стандарт документирования REST API. Он может быть представлен в виде YAML или JSON. Существует 2 широко используемые версии Open API: 2 и 3, и Swagger поддерживает обе.
Что такое Swagger и какие инструменты он предоставляет	Swagger — самый популярный набор инструментов для работы с Open API. Пользовательский интерфейс Swagger используется для визуального представления Open API, чтобы сделать его удобным для конечных пользователей (обычно разработчиков внешнего интерфейса). Swagger Editor используется для создания и редактирования документов Open API (он представлен в виде YAML). Swagger Codegen позволяет генерировать исходный код сервера и клиента на основе спецификации Open API.
Что такое SpringFox и когда мы должны его использовать	Это библиотека Java, которая позволяет автоматически генерировать спецификации Open API из исходного кода сервисов Spring REST. Он генерирует спецификацию (контракт) на основе вашего кода, а также развертывает клиент пользовательского интерфейса Swagger с вашим приложением, что позволяет вам немедленно протестировать ваш REST API.
В чем разница между подходами Design First и Code First? Какие инструменты можно использовать для реализации этих подходов	Design First означает, что в первую очередь аналитики создают спецификации REST API, и только потом реализуется сервер. Code First означает, что сначала создается сервер, а затем с сервера генерируются спецификации REST API. Для Design First мы можем использовать Swagger Editor для создания спецификаций + Swagger Codegen для генерации кода. Для Code First мы можем использовать SpringFox для создания документации с сервера.
Как мы можем настроить SpringFox для настройки документации REST	Мы можем использовать аннотации @Api и @ApiOperation для переименования или описания операций REST, как это описано в спецификации Open API. Кроме того, мы можем отфильтровать некоторые конечные точки по их URL-адресам или по методу HTTP, если мы не хотим, чтобы они присутствовали во внешнем API. Кроме того, мы можем определить метаинформацию, такую ​​как авторы, лицензия и т. д.
Зачем нам нужно ограничивать данные, передаваемые на сторону клиента	Это необходимо, потому что иначе мы можем передать клиенту слишком много данных (в худшем случае все дерево объектов будет сериализовано в JSON и передано клиенту). Кроме того, некоторые данные, такие как пароли, всегда следует опускать. Существуют ограничения на объем данных, которые можно хранить с помощью API-интерфейсов хранилища на стороне клиента, и эти ограничения зависят от браузера и, возможно, от пользовательских настроек1. Отправляя на сторону клиента только необходимые данные, вы можете уменьшить объем данных, которые необходимо хранить и обрабатывать, что приводит к более быстрому времени загрузки и более быстрому отклику приложения.
Что такое шаблон DTO и почему мы должны его использовать	DTO это Data Transfer Object — самый мощный способ подготовки данных, которые должны быть переданы клиенту. Однако для выполнения преобразования требуется много дополнительной работы.
Что такое подход с нулевыми полями	Обнуление полей означает, что мы устанавливаем некоторые свойства объекта, которые будут сериализованы в JSON, равными нулю. Обычно это выполняется в REST-контроллере и не меняет базу данных — мы просто исключаем некоторые данные из сериализации.
Какую аннотацию Джексона можно использовать для ограничения данных, передаваемых клиенту, и в чем недостаток этого подхода	У Джексона есть аннотация @JsonIgnore, которая позволяет исключить какое-то свойство из сериализации. Недостатком является то, что @JsonIgnore не является гибким, т. е. исключает свойство навсегда. Другие подходы, такие как обнуление полей и DTO, более гибкие.
Что такое проекции, как их применять и когда их можно использовать	Прогнозы и выдержки работают только с Data REST и могут использоваться с репозиториями Spring Data. Они позволяют создавать подмножества данных для сериализации. Это достигается путем добавления параметров проекции к URL-адресу с именем, определенным с помощью аннотации @Projection. Прогнозы могут быть полезны, когда вы хотите оптимизировать производительность за счет уменьшения объема данных, которые необходимо извлечь из базы данных. Они также могут помочь упростить код, позволяя работать с объектами, содержащими только те данные, которые вам нужны.
Что такое выдержки, как их применять и когда их можно использовать	Выдержки похожи на проекцию по умолчанию для репозитория Spring Data. Однако он применяется [только] к коллекциям, [не] к отдельным объектам. Для [отдельного объекта] мы должны использовать параметр проекции.
Когда и почему мы должны использовать MapStruct? В чем преимущество использования MapStruct	MapStruct автоматизирует создание DTO для сущности. Преимущество MapStruct заключается в том, что он позволяет избежать шаблонного кода и определять только нетривиальные сопоставления Entity с DTO и DTO с Entity.
Как можно использовать сериализатор Джексона для настройки сериализации на JSON? В чем польза от его использования	Сериализатор Джексона это [низкоуровневый] подход к настройке сериализации. Мы можем использовать @JsonSerialize и @JsonDeserialize для применения пользовательского сериализатора. Преимущество в том, что мы можем избежать добавления слоя DTO и можем предоставить некоторые общие правила для сериализации (например, поле с именем «пароль» не должно сериализоваться).
Каковы преимущества использования среды проверки Java Bean	Это стандарт JEE (в качестве реализации Spring использует Hibernate Validator) 2) Он обеспечивает декларативный подход, который упрощает чтение кода, поскольку ограничения данных определяются с помощью аннотаций 3) Его можно настраивать, мы можем создавать свои собственные валидаторы 4) Стандартные валидаторы могут распространяться на ограничения базы данных. Еще одно преимущество заключается в том, что инфраструктура расширяема и настраиваема, что позволяет вам при необходимости определять свои собственные правила проверки. Он интегрирован со многими популярными ORM, и проверки вызываются автоматически перед сохранением изменений в базе данных.
Как создать собственный валидатор для платформы проверки Java Bean	Создайте аннотацию с именем валидатора 2) Создайте класс, реализующий ConstraintValidator, имеющий логический метод isValid()
Как использовать валидатор сущностей в контроллере REST	Добавьте аннотацию @Valid к @RequestBody 2) Предоставьте обработчик для MethodArgumentNotValidException, возвращающий JSON, если проверка не удалась 3) Поместите обработчик в контроллер REST, который расширяет ResponseEntityExceptionHandler и помечен как @ContollerAdvice - таким образом вы заставите его обрабатывать все исключения такого рода
Как использовать валидатор с параметрами запроса	Добавьте аннотации проверки к параметрам метода контроллера, например @PathVariable @Min(1) Long id 2) Добавьте аннотацию @Validated к классу контроллера REST 3) Предоставьте обработчик для ConstraintViolationException, используя метод, помеченный @ExceptionHandler 4) Поместите обработчик в контроллер REST, помеченный как @ContollerAdvice — таким образом вы заставите его обрабатывать все исключения такого рода
Каковы свойства ACID transaction	Атомарность означает, что либо все операции в транзакции фиксируются, либо все откатываются. Непротиворечивость означает, что база данных находится в согласованном состоянии после фиксации или отката транзакции. Изоляция означает, что transaction не взаимодействует с эффектами других transaction. Долговечность означает, что если transaction зафиксирована, изменения не могут исчезнуть (это достигается первой записью в журнал transaction, который применяется снова в случае любого сбоя). Эти свойства обеспечивают надежную обработку transaction и помогают поддерживать целостность данных в базе данных.
Что такое PlatformTransactionManager? Каковы возможные реализации этого менеджера	PlatformTransactionManager это центральный интерфейс для работы с транзакциями. Он неявно используется в декларативном управлении транзакциями и может использоваться для программного управления транзакциями путем внедрения его экземпляра. У него всего 3 метода: getTransaction(), commit() и rollback(). Существуют различные реализации этого интерфейса, и наиболее часто используемыми являются DataSourceTransactionManager для простого JDBC, JpaTransactionManager для использования с JPA, HibernateTransactionManager для Hibernate и JmsTransactionManager для работы с брокерами сообщений.
Что такое TransactionDefinition? Какие у него параметры	TransactionDefinition это интерфейс, используемый для настройки транзакционного метода. TransactionDefinition определяет 4 свойства: изоляция, propagation, время ожидания и статус только для чтения.
Почему мы должны устанавливать тайм-аут для транзакции? Какой таймаут по умолчанию	Мы должны установить тайм-аут, чтобы избежать слишком длинных transaction. Единицей времени ожидания является миллисекунды. Если за это время запрос не будет выполнен, мы получим TransactionException (время транзакции истекло). Установка времени ожидания может быть полезна для отката длительных запросов к базе данных. Значение по умолчанию равно -1 (без ограничений).
Почему мы должны установить только для чтения значение true	Этот атрибут является подсказкой для JPA-провайдера (Hibernate) и JDBC-драйвера, который мы не собираемся записывать в БД, что позволяет выполнить некоторые дополнительные оптимизации. В результате запросы на вставку/обновление не будут выполняться. Кроме того, если вы читаете данные и обновляете данные, эти обновления не будут сохраняться при фиксации. Это означает, что Hibernate не будет проверять, были ли внесены какие-либо изменения в объекты, и не будет выдавать никаких заявлений об обновлении базы данных. Это может быть полезно, когда вы знаете, что не будете вносить никаких изменений в выбранные объекты, и хотите оптимизировать производительность, избегая ненужной грязной проверки.
Зачем нужна transaction для чтения данных	Согласованность результатов: когда мы хотим запустить более одного SELECT и хотим, чтобы результаты были согласованными, мы должны сделать это в транзакции только для чтения. Если мы хотим быть уверены, что не произойдет никаких попыток записи данных в БД.
Что такое уровень изоляции READ UNCOMMITTED?	накладывает минимальное количество блокировок. Это предотвращает только потерю обновлений — когда данные изменяются одной транзакцией, те же данные не могут быть изменены другой транзакцией до фиксации или отката. В то же время он может допускать грязные чтения, неповторяемые чтения и фантомные чтения.
Когда следует использовать уровень изоляции READ UNCOMMITTED	Его можно использовать, если нам нужна максимальная производительность, и мы можем считать допустимыми грязные чтения и неповторяемые чтения. * Если мы выполняем агрегирование по многим строкам: например, среднее значение одного миллиона значений существенно не изменится * Если мы читаем локальные данные, которые никто другой не модифицирует * Если мы читаем старые данные, никто не изменяет должен изменить больше
Что такое уровень изоляции READ COMMITTED	Этот уровень предотвращает чтение незафиксированных данных (грязные чтения). Если мы что-то обновляем в транзакции, эти данные не могут быть прочитаны другими транзакциями. Это достигается за счет получения блокировки при изменении данных. Это предотвращает грязное чтение, когда transaction считывает данные, которые были изменены другой транзакцией, но еще не зафиксированы. Однако данные по-прежнему могут быть изменены другими транзакциями между отдельными операторами в рамках текущей транзакции, что приводит к неповторяющимся операциям чтения или фиктивным данным.
Когда следует использовать уровень изоляции READ COMMITTED	Это уровень изоляции по умолчанию во многих базах данных (Oracle, PostgreSQL и т. д.). Он обеспечивает хороший баланс между производительностью и изоляцией. На этом уровне могут возникать неповторяемые или фантомные чтения. READ COMMITTED используется для предотвращения грязного чтения. Это гарантирует, что transaction видит только те данные, которые были зафиксированы другими транзакциями до начала запроса, и не будет видеть незафиксированные данные или изменения, зафиксированные во время выполнения запроса параллельными транзакциями.
Что такое уровень изоляции REPEATABLE READ?	Это уровень изоляции, который предотвращает грязные чтения и неповторяемые чтения. Если transaction считывает некоторые данные, эти данные не могут быть изменены другими транзакциями. Это достигается путем получения блокировки, когда мы читаем данные. Недостаток в том, что мы получаем много замков: мы запираем все, на что смотрим.
Что такое уровень изоляции SERIALIZABLE?	 это уровень, обеспечивающий полную изоляцию. Это предотвращает все возможные проблемы, в том числе фантомные чтения. Однако за это приходится платить слишком большим количеством блокировок, что замедляет работу базы данных.
Что такое проблема с потерянным обновлением	Проблема потерянных обновлений это ситуация, когда база данных изменяется несколькими пользователями, а изменения одного пользователя теряются. Например, если первый пользователь читает некоторые данные, например, A=1, а затем второй пользователь также читает то же значение, A=1. Затем первый пользователь устанавливает A=A+1 и сохраняет его значение 2 в базе данных. Второй пользователь делает то же самое: вычисляет A=A+1 и сохраняет значение 2 в базу данных. В итоге у нас было 2 приращения: +1 у первого пользователя и +1 у второго пользователя. Однако значение базы данных по-прежнему равно 2, что означает, что второй пользователь перезаписывает изменения, сделанные первым пользователем. У нас возникла проблема с потерянным обновлением: теряются изменения первого пользователя.
Что такое грязное чтение	Грязное чтение это чтение несогласованных данных или данных из середины работы какой-то транзакции (грязные данные). Это происходит, когда одна transaction изменяет данные, но не фиксирует их, а другая transaction читает данные, которые еще не зафиксированы. Ее можно решить, запретив чтение любых измененных данных (получив блокировку от чтения). Решается с помощью уровня изоляции READ COMMITTED.
Что такое неповторимая проблема чтения	Проблема, когда мы читаем данные в транзакции, потом через какое-то время читаем те же данные в той же транзакции — и получаем разные результаты. Это можно решить, предотвратив изменение прочитанных данных (получив блокировку при чтении данных). Решается с помощью уровня изоляции REPEATABLE READ. Неповторяющееся чтение происходит, когда transaction дважды читает одну и ту же строку и каждый раз видит разные данные. Это может произойти, когда другая transaction обновляет строку между двумя операциями чтения.
Что такое фантомное чтение	Проблема, когда мы выполняем несколько одинаковых запросов SELECT... FROM... в транзакции, но получаем разные результаты. Это происходит потому, что другие транзакции могут добавлять новые строки (фантомы), а результаты запроса могут измениться. Это решается на уровне изоляции SERIALIZABLE путем получения блокировки для всей таблицы. Фантомное чтение происходит, когда transaction дважды выполняет запрос и каждый раз получает разное количество строк в результирующем наборе. Это может произойти, когда вторая transaction вставляет или удаляет строки, соответствующие предложению WHERE запроса, выполняемого первой транзакцией между двумя ее выполнениями.
Когда следует использовать уровень изоляции SERIALIZABLE	Если мы хотим быть уверены, что у нас есть полная изоляция transaction, мы должны использовать уровень изоляции SERIALIZABLE. Использование этого уровня замедлит работу базы данных из-за большого количества блокировок.
Что такое transaction propagation	Распространение транзакции определяет, что произойдет, когда один транзакционный метод вызовет другой. Следует ли повторно использовать ту же транзакцию, или начать новую транзакцию, или предотвратить выполнение транзакции, или потребовать транзакцию — что такое обязательное transaction propagation и когда его следует использовать. Требуется это transaction propagation по умолчанию для аннотации @Transactional. Его следует использовать, когда нам нужна transaction для метода (он нужен всегда, если мы меняем какие-либо данные), но мы хотим иметь возможность вызывать метод как из транзакционного, так и из нетранзакционного метода.
Что такое RequiresNew transaction propagation	Метод означает, что ему всегда нужна новая транзакция. Если метод вызывается из нетранзакционного метода, он запускает новую транзакцию. Если метод вызывается из транзакционного метода, он приостанавливает выполнение текущей транзакции и создает новую транзакцию. внутри своей собственной транзакции, независимо от любых других transaction, которые могут быть активны в это время.
Когда следует использовать transaction propagation RequiresNew	Поведение нарушает атомарный принцип: может случиться так, что часть транзакции откатится, а transaction зафиксируется, или наоборот. Если транзакционный метод A() вызывает метод B(), помеченный как RequiresNew, метод B() может выполнить откат, когда метод A() фиксируется, или метод B() может выполнить откат, когда выполняется откат метода A(). Поэтому это propagation можно использовать только для какой-то отдельной части работы, не связанной с внешней транзакцией. Например, его можно использовать для записи лог-сообщений (может зафиксировать, если transaction откатится), или для кеширования, или для синхронизации — для чего-то, где сбой части может не привести к сбою всего.
Что такое обязательное propagation transaction и когда его следует использовать	означает, что метод может быть вызван только из транзакционного метода, но не запускает транзакцию. Его можно использовать, если методу нужна транзакция, но его нельзя использовать самостоятельно, а только как часть какого-то многошагового алгоритма. В случае, если метод, помеченный как обязательный, не выполняется в рамках транзакции, создается исключение TransactionRequiredException.
Что такое propagation transaction NotSupported и когда его следует использовать	означает, что метод не поддерживает транзакции. Его следует запускать из нетранзакционного метода, иначе, если он запускается из транзакционного метода, transaction будет приостановлена. Его можно использовать только для чтения данных. Поскольку транзакции предполагают накладные расходы, этот атрибут может повысить производительность (например, избежать получения блокировок при чтении данных).
Что такое поддержка propagation transaction и когда ее следует использовать	означает, что метод не меняет поведение вызывающего метода: если вызывающий метод был транзакционным, он будет выполняться в рамках транзакции, в противном случае он будет выполняться без транзакции. Его можно использовать только для чтения данных и чаще всего в связке с readOnly=true. В этом случае мы избегаем потери производительности, связанной с созданием транзакции и приостановкой транзакции, потому что все, что нам здесь нужно, это прочитать данные. Распространение transaction NotSupported используется, когда вы хотите выполнить часть кода без транзакции. Если transaction доступна, она приостанавливается, и код запускается без какой-либо транзакции.
Что такое никогда не propagation transaction и когда его следует использовать	Never означает, что метод никогда не должен вызываться из транзакционного метода. Если бы это было так, мы бы получили исключение IllegalTransactionStateException. Его можно использовать для долго выполняющихся методов, которые никогда не должны выполняться внутри транзакции, поскольку это может привести к низкой производительности базы данных (блокировки будут удерживаться в течение длительного времени), и либо не нужны транзакции, либо используются внутренние программные транзакции. Его также можно использовать в целях тестирования, чтобы убедиться, что метод не является транзакционным.
Как откатить транзакцию при использовании декларативных transaction	По умолчанию любое RuntimeException|RollbackException приводит к откату транзакции. В противном случае можно изменить список исключений, которые могут привести к откату, с помощью свойства rollbackFor аннотации @Transactional.
В чем разница между логическими и физическими транзакциями	Физические транзакции это фактические транзакции базы данных, а логические транзакции это методы Spring с аннотацией @Transactional. Как правило, одна физическая transaction может включать в себя несколько логических transaction.
Что происходит с физической транзакцией, если логическая transaction вызывает исключение	Если метод @Transactional выдает исключение, указанное в rollbackFor (или любое исключение RuntimeException по умолчанию), внешняя физическая transaction не будет зафиксирована и выдаст исключение UnexpectedRollbackException. Это произойдет потому, что выброс одного из исключений из списка rollbackFor пометит физическую транзакцию как предназначенную только для отката, поэтому ее нельзя будет зафиксировать, даже если исключение было перехвачено.
Можно ли вызвать транзакционный метод из того же класса	Нет, в данном случае этот метод не будет транзакционным, поскольку транзакции используют механизм прокси, который можно использовать только в том случае, если Spring вводит ссылку на прокси-реализацию, что добавляет транзакционное поведение. Вы можете использовать шаблон самоинъекции, если вам нужно вызвать транзакционный метод из того же класса.
В каком сценарии следует использовать оптимистическую или пессимистическую блокировку вместо transaction	Транзакции используются для кратковременного набора операций. Если нам нужны какие-то длительные операции, особенно с участием человека, мы не можем делать их в транзакции, потому что мы не должны долго держать соединение и блокировки. Мы должны использовать подход, называемый прикладной транзакцией или длинным разговором. Типичный сценарий включает в себя пользователя, которому необходимо изменить некоторые данные в базе данных: пользователь открывает данные в форме (считывает данные), затем редактирует данные в форме, затем нажимает кнопку «Сохранить», чтобы записать обновленные данные обратно в базу данных. В этом случае мы можем столкнуться с проблемой потерянного обновления | неповторяемого чтения. Например, пользователь Алиса и пользователь Боб открывают одни и те же данные, затем пользователь Алиса сохраняет свои изменения, затем пользователь Боб сохраняет свои изменения. В этом случае изменения, внесенные Бобом, перезапишут изменения, внесенные Алисой. Как это решить? Мы можем запретить изменять данные, открытые кем-то другим (они могут быть открыты в режиме только для чтения) - эта опция называется пессимистической блокировкой. В противном случае мы можем разрешить изменять данные всем, но успешно сохранятся только изменения, сделанные первым пользователем это называется оптимистической блокировкой (потому что мы надеемся, что первый пользователь будет единственным). Как правило, оптимистическая locking предпочтительнее для этого сценария.
Что такое оптимистическая locking и как она работает	это стратегия предотвращения одновременных обновлений одних и тех же данных несколькими пользователями без использования блокировок. Чтобы сделать это возможным, объект данных имеет специальное свойство (типа int/long/Date), помеченное аннотацией @Version. Обычно это число, изначально установленное на 0. Когда сущность читается, версия также читается. Если кто-то изменяет данные, он автоматически увеличивает версию. Если нам нужно сохранить обновленные данные, мы должны сначала проверить, не изменилась ли версия после того, как мы прочитали данные (это делается автоматически Hibernate). Если он не был изменен, мы можем быть уверены, что никто больше не трогал данные (представленные в виде строки базы данных) и мы работаем исключительно с этими данными. В противном случае, если версия отличается, это означает, что данные были изменены кем-то другим, и мы получим OptimisticLockException при попытке сохранить эти данные. В этом случае мы должны откатить наше изменение и перечитать данные из базы данных, чтобы получить фактические данные. Затем мы можем показать его пользователю или объединить наши изменения с обновлениями из базы данных и попытаться сохранить его снова. Эта стратегия позволяет избежать потери обновлений, поскольку изменения одних и тех же данных, сделанные другим пользователем, не будут перезаписаны нами. Оптимистичная locking может повысить производительность в системах, где конфликты между транзакциями редки, поскольку позволяет избежать накладных расходов на получение и снятие блокировок. Однако при частых конфликтах оптимистичная locking может привести к откату и повторным попыткам многих transaction, что снижает производительность. Затем мы можем показать его пользователю или объединить наши изменения с обновлениями из базы данных и попытаться сохранить его снова. Эта стратегия позволяет избежать потери обновлений, поскольку изменения одних и тех же данных, сделанные другим пользователем, не будут перезаписаны нами. Оптимистичная locking может повысить производительность в системах, где конфликты между транзакциями редки, поскольку позволяет избежать накладных расходов на получение и снятие блокировок. Однако при частых конфликтах оптимистичная locking может привести к откату и
Что такое пессимистическая locking и как она работает	называется «пессимистическим», потому что система предполагает худшее, что два или более пользователей захотят обновить одну и ту же запись одновременно, и поэтому система предотвращает эту возможность, блокируя запись, независимо от того, насколько маловероятны конфликты. Пессимистическая locking используется внутри и автоматически при использовании transaction (в зависимости от уровня изоляции). Однако можно вручную получить блокировку для объекта, используя entityManager.lock(entity, PESSIMISTIC_WRITE) или аннотацию @Lock(PESSIMISTIC_WRITE) для метода — в этом случае мы можем получить блокировку в момент чтения данные. Он выполнит запрос SELECT FOR UPDATE, который получит монопольную блокировку. Блокировка предотвратит изменение данных (поскольку изменение данных требует монопольной блокировки) и предотвратит получение блокировки для этих данных другими транзакциями. В противном случае мы можем получить PESSIMISTIC_READ (общую) блокировку, которая не позволит изменять данные, но гарантирует, что никто другой не сможет получить монопольную блокировку для изменения данных. Если база данных не поддерживает общие блокировки (например, Oracle), то запрос на общую блокировку (PESSIMISTIC_READ) просто получит запрос на эксклюзивную блокировку (PESSIMISTIC_WRITE). Пессимистические блокировки автоматически снимаются в конце транзакции (при фиксации/откате) и должны использоваться только внутри транзакции. не иметь возможности получить эксклюзивную блокировку для изменения данных. Если база данных не поддерживает общие блокировки (например, Oracle), то запрос на общую блокировку (PESSIMISTIC_READ) просто получит запрос на эксклюзивную блокировку (PESSIMISTIC_WRITE). Пессимистические блокировки автоматически снимаются в конце транзакции (при фиксации/откате) и должны использоваться только внутри транзакции. не иметь возможности получить эксклюзивную блокировку для изменения данных. Если база данных не поддерживает общие блокировки (например, Oracle), то запрос на общую блокировку (PESSIMISTIC_READ) просто получит запрос на эксклюзивную блокировку (PESSIMISTIC_WRITE). Пессимистические блокировки автоматически снимаются в конце транзакции (при фиксации/откате) и должны использоваться только внутри транзакции.
Что такое распределенная transaction и как она работает	Распределенная transaction это набор операций с данными, которые выполняются в двух или более базах данных (работающих на разных серверах). Это может быть реализовано с помощью сценария двухфазной/однофазной фиксации: 1) Диспетчер transaction запускает распределенную транзакцию, и все участники должны проголосовать за то, что они получили все необходимые блокировки и готовы зафиксировать транзакцию - это состояние называется подготовленной транзакцией. 2) Если какой-либо участник распределенной транзакции не смог подготовить транзакцию (не смог получить необходимые блокировки), transaction помечается для отката и все участники должны ее откатить. Если все участники смогли подготовить транзакцию, диспетчер transaction говорит, что распределенную транзакцию можно исправить. Затем,
Как можно использовать распределенную транзакцию	Spring поддерживает распределенные транзакции через JTA (Java Transaction API, часть спецификаций JEE) или с помощью класса ChainedTransactionManager, встроенного в Spring. Однако ChainedTransactionManager не является надежным решением и устарел. Вы можете использовать JTA с каким-либо сервером приложений JEE или облегченным провайдером JTA, таким как Atomikos/Bitronix/Narayana (если вы не хотите использовать сервер приложений JEE). В противном случае вы можете использовать шаблон SAGA.
Что такое шаблон SAGA и когда его следует использовать	лучший вариант для реализации распределенных transaction, который можно использовать не только для реляционных баз данных, но и для баз данных NoSQL и различных других источников данных. SAGA нужен какой-то канал обмена сообщениями для обмена данными между серверами (это может быть Kafka/Rabbit/JMS). У каждой транзакционной операции A в SAGA должен быть обратный аналог (для выполнения отката операции) — операция A'. Например, если мы положили деньги на счет (операция А), мы должны определить обратную операцию, чтобы снять ту же сумму со счета (операция А'), которая отменит первую операцию. Предположим, что у нас есть 2 сервиса, участвующих в распределенной транзакции, и нам нужен первый сервис для выполнения операции A, а второй сервис для выполнения операции B. После успешного завершения операции A, первая служба отправляет сообщение второй службе для запуска операции B. Если операция B завершается успешно, служба отправляет первой службе подтверждающее сообщение об успешном завершении. В случае сбоя операции B вторая служба отправляет сообщение первой службе для отката операции A, а первая служба выполняет операцию A', которая отменяет операцию A. То же самое произойдет, если первая служба не получит сообщение об утверждении. со второй службы в течение длительного времени (например, если вторая служба не работает).
Какова цель Spring Security?	Это платформа, ориентированная на предоставление возможностей аутентификации и авторизации для приложений Java. Он направлен на обеспечение безопасности приложений путем контроля доступа к ресурсам и защиты от распространенных угроз безопасности. Pазработчики могут внедрять безопасные механизмы аутентификации, обрабатывать авторизацию пользователей и защищать конфиденциальные данные от несанкционированного доступа. Предлагайте настраиваемый способ реализации аутентификации, авторизации и защиты от распространенных атак, таких как фиксация сеанса, кликджекинг и подделка межсайтовых запросов.
Что из следующего используется для безопасного хранения паролей пользователей?	пароли пользователей надежно хранятся с использованием алгоритмов хеширования. Алгоритмы хеширования преобразуют пароли в необратимые строки фиксированной длины, что делает невозможным с вычислительной точки зрения перепроектирование исходного пароля.
Какая аннотация используется для защиты метода или класса с безопасностью на уровне метода?	@Secured используется для защиты метода или класса с безопасностью на уровне метода. Он позволяет указать роли или полномочия, необходимые для доступа к защищенному методу или классу.
Какова цель защиты от CSRF?	Предназначен для защиты от атак с подделкой межсайтовых запросов. Он гарантирует, что запросы к приложению исходят из надежных источников, не позволяя злоумышленникам обманом заставить пользователей выполнять непреднамеренные действия.
WebClient Customization 	обеспечивает легкую настройку благодаря шаблону Builder. Вы можете настраивать различные аспекты HTTP-запросов, такие как установка заголовков, параметров запроса, тайм-аутов и аутентификации. Вы также можете настроить обработку ответа, например, обработку ошибок и десериализацию тела ответа. WebClient предоставляет такие методы, как defaultHeader, defaultHeaders, defaultRequest, defaultRequestHeaders и exchangeStrategies для настройки поведения клиента в соответствии с вашими конкретными требованиями. Кроме того, вы можете расширить WebClient и создать свои собственные экземпляры WebClient с предварительно настроенными параметрами или пользовательским поведением.