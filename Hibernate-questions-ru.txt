Что такое ORM? Что такое JPA? Что такое Hibernate?	ORM(Object Relational Mapping) - это концепция преобразования данных из объектно-ориентированного языка в реляционные БД и наоборот. JPA(Java Persistence API) - это стандартная для Java спецификация, описывающая принципы ORM. JPA не умеет работать с объектами, а только определяет правила как должен действовать каждый провайдер (Hibernate, EclipseLink), реализующий стандарт JPA Hibernate - библиотека, являющаяся реализацией этой спецификации, в которой можно использовать стандартные API-интерфейсы JPA.
Что такое EntityManager?	EntityManager интерфейс JPA, который описывает API для всех основных операций над Entity, а также для получения данных и других сущностей JPA. Основные операции:1) Операции над Entity: persist (добавление Entity), merge (обновление), remove (удаления), refresh (обновление данных), detach (удаление из управление JPA), lock (блокирование Entity от изменений в других thread),2) Получение данных: find (поиск и получение Entity), createQuery, createNamedQuery, createNativeQuery, contains, createNamedStoredProcedureQuery, createStoredProcedureQuery3) Получение других сущностей JPA: getTransaction, getEntityManagerFactory, getCriteriaBuilder, getMetamodel, getDelegate4) Работа с EntityGraph: createEntityGraph, getEntityGraph5) Общие операции над EntityManager или всеми Entities: close, clear, isOpen, getProperties, setProperty.Объекты EntityManager не являются потокобезопасными. Это означает, что каждый поток должен получить свой экземпляр EntityManager, поработать с ним и закрыть его в конце.
Каким условиям должен удовлетворять класс чтобы являться Entity?	Entity это легковесный хранимый объект бизнес логики. Основная программная сущность это entity-класс, который так же может использовать дополнительные классы, которые могут использоваться как вспомогательные классы или для сохранения состояния еntity.1) Entity класс должен быть помечен аннотацией Entity или описан в XML файле2) Entity класс должен содержать public или protected конструктор без аргументов (он также может иметь конструкторы с аргументами) - при получении данных из БД и формировании из них объекта сущности, Hibernate должен создать этот самый объект сущности,3) Entity класс должен быть классом верхнего уровня (top-level class),4) Entity класс не может быть enum или интерфейсом,5) Entity класс не может быть финальным классом (final class),6) Entity класс не может содержать финальные поля или методы, если они участвуют в маппинге (persistent final methods or persistent final instance variables),7) Если объект Entity класса будет передаваться по значению как отдельный объект (detached object), например через удаленный интерфейс (through a remote interface), он так же должен реализовывать Serializable интерфейс8) Поля Entity класс должны быть напрямую доступны только методам самого Entity класса и не должны быть напрямую доступны другим классам, использующим этот Entity. Такие классы должны обращаться только к методам (getter/setter методам или другим методам бизнес-логики в Entity классе),9) Entity класс должен содержать первичный ключ, то есть атрибут или группу атрибутов которые уникально определяют запись этого Entity класса в базе данных
Может ли абстрактный класс быть Entity?	Может, при этом он сохраняет все свойства Entity, за исключением того что его нельзя непосредственно инициализировать.
Что такое встраиваемый (Embeddable) класс? Какие требования JPA устанавливает к встраиваемым (Embeddable) классам?	Embeddable класс - это класс, который не используется сам по себе, а является частью одного или нескольких Entity-классов. Entity-класс может содержать как одиночные встраиваемые классы, так и коллекции таких классов. Также такие классы могут быть использованы как ключи или значения map. Во время выполнения каждый встраиваемый класс принадлежит только одному объекту Entity-класса и не может быть использован для передачи данных между объектами Entity-классов (то есть такой класс не является общей структурой данных для разных объектов). В целом, такой класс служит для того чтобы выносить определение общих атрибутов для нескольких Entity.Embeddable-класс может содержать другой встраиваемый класс.Встраиваемый класс может содержать связи с другими Entity или коллекциями Entity, если такой класс не используется как первичный ключ или ключ map'ы.
Что такое Mapped Superclass?	Mapped Superclass - это класс, от которого наследуются Entity, он может содержать анотации JPA, однако сам такой класс не является Entity, ему не обязательно выполнять все требования установленные для Entity (например, он может не содержать первичного ключа). Такой класс не может использоваться в операциях EntityManager или Query. Такой класс должен быть отмечен аннотацией MappedSuperclass или описан в xml файле. Создание такого класса-предка оправдано тем, что мы заранее определяем ряд свойств и методов, которые должны быть определены в сущностях. Использование такого подхода позволило сократить количество кода
Какие три типа стратегий наследования мапинга (Inheritance Mapping Strategies) описаны в JPA?	одна таблица на всю иерархию наследования (a single table per class hierarchy) — все entity, со всеми наследниками записываются в одну таблицу, для идентификации типа entity определяется специальная колонка "discriminator column". Например, если есть entity Animals c классами-потомками Cats и Dogs, при такой стратегии все entity записываются в таблицу Animals, но при это имеют дополнительную колонку animalType в которую соответственно пишется значение «cat» или «dog».Минусом является то что в общей таблице, будут созданы все поля уникальные для каждого из классов-потомков, которые будет пусты для всех других классов-потомков. Например, в таблице animals окажется и скорость лазанья по дереву от cats и может ли пес приносить тапки от dogs, которые будут всегда иметь null для dog и cat соответственно.3) Таблица для каждого класса (TABLE_PER_CLASS) — каждый отдельный класс-наследник имеет свою таблицу, т.е. для cats и dogs (см.выше) все данные будут записываться просто в таблицы cats и dogs как если бы они вообще не имели общего суперкласса. Минусом является плохая поддержка полиморфизма (polymorphic relationships) и то что для выборки всех классов иерархии потребуются большое количество отдельных sql запросов или использование UNION запроса.Для задания стратегии наследования используется аннотация Inheritance (или соответствующие блоки)
Как мапятся Enum'ы?	@Enumerated(EnumType.STRING) - означает, что в базе будут храниться имена Enum.@Enumerated(EnumType.ORDINAL) - в базе будут храниться порядковые номера Enum.Другой вариант - мы можем смапить наши enum в БД и обратно в методах с аннотациями @PostLoad и @PrePersist. @EntityListener над классом Entity, в которой указать класс, в котором создать два метода, помеченнх этими аннотациями.Идея в том, чтобы в сущности иметь не только поле с Enum, но и вспомогательное поле. Поле с Enum аннотируем @Transient, а в БД будет храниться значение из вспомогательного поля. В JPA с версии 2.1 можно использовать Converter для конвертации Enum'а в некое его значение для сохранения в БД и получения из БД. Все, что нам нужно сделать, это создать новый класс, который реализует javax.persistence.AttributeConverter и аннотировать его с помощью @Converter и поле в сущности аннотацией @Convert.
Как мапятся даты (до java 8 и после)?	Аннотация @Temporal до Java 8, в которой надо было указать какой тип даты мы хотим использовать.В Java 8 и далее аннотацию ставить не нужно.
Как "смапить" коллекцию примитивов?	@ElementCollection@OrderByЕсли у нашей сущности есть поле с коллекцией, то мы привыкли ставить над ним аннотации @OneToMany либо @ManyToMany. Но данные аннотации применяются в случае, когда это коллекция других сущностей (entities). Если у нашей сущности коллекция не других сущностей, а базовых или встраиваемых (embeddable) типов для этих случаев в JPA имеется специальная аннотация @ElementCollection, которая указывается в классе сущности над полем коллекции. Все записи коллекции хранятся в отдельной таблице, то есть в итоге получаем две таблицы: одну для сущности, вторую для коллекции элементов.При добавлении новой строки в коллекцию, она полностью очищается и заполняется заново, так как у элементов нет id. Можно решить с помощью @OrderColumn@CollectionTable - позволяет редактировать таблицу с коллекцией, прочитать
Какие есть виды связей?	Существуют 4 типа связей:1. OneToOne - когда один экземпляр Entity может быть связан не больше чем с одним экземпляром другого Entity.2. OneToMany - когда один экземпляр Entity может быть связан с несколькими экземплярами других Entity.3. ManyToOne - обратная связь для OneToMany. Несколько экземпляров Entity могут быть связаны с одним экземпляром другого Entity.4. ManyToMany - экземпляры Entity могут быть связаны с несколькими экземплярами друг друга.Каждую из которых можно разделить ещё на два вида:1. Bidirectional с использованием mappedBy на стороне, где указывается @OneToMany2. UnidirectionalBidirectional — ссылка на связь устанавливается у всех Entity, то есть в случае OneToOne A-B в Entity A есть ссылка на Entity B, в Entity B есть ссылка на Entity A. Entity A считается владельцем этой связи (это важно для случаев каскадного удаления данных, тогда при удалении A также будет удалено B, но не наоборот).Undirectional- ссылка на связь устанавливается только с одной стороны, то есть в случае OneToOne A-B только у Entity A будет ссылка на Entity B, у Entity B ссылки на A не будет.
Что такое владелец связи?	В отношениях между двумя сущностями всегда есть одна владеющая сторона, а владеемой может и не быть, если это однонаправленные отношения.По сути, у кого есть внешний ключ на другую сущность - тот и владелец связи. То есть, если в таблице одной сущности есть колонка, содержащая внешние ключи от другой сущности, то первая сущность признаётся владельцем связи, вторая сущность - владеемой.В однонаправленных отношениях сторона, которая имеет поле с типом другой сущности, является владельцем этой связи по умолчанию.
Что такое каскады?	Каскадирование - это когда мы выполняем какое-то действие с целевой Entity, то же самое действие будет применено к связанной Entity.JPA CascadeType:ALL - гарантируют, что все персистентные события, которые происходят на родительском объекте, будут переданы дочернему объекту.PERSIST - означает, что операции save () или persist () каскадно передаются связанным объектам.MERGE - означает, что связанные entity объединяются, когда объединяется entity-владелец.REMOVE - удаляет все entity, связанные с удаляемой entity.DETACH - отключает все связанные entity, если происходит «ручное отключение».REFRESH - повторно считывают значение данного экземпляра и связанных сущностей из базы данных при вызове refresh().
Разница между PERSIST и MERGE?	persist(entity) следует использовать с совершенно новыми объектами, чтобы добавить их в БД (если объект уже существует в БД, будет выброшено исключение EntityExistsException).Но в случае merge(entity) сущность, которая уже управляется в контексте персистентности, будет заменена новой сущностью (обновленной), и копия этой обновленной сущности вернется обратно. Но рекомендуется использовать для уже сохраненных сущностей.
Какие два типа fetch стратегии в JPA вы знаете?	1) LAZY — Hibernate может загружать данные не сразу, а при первом обращении к ним, но так как это необязательное требование, то Hibernate имеет право изменить это поведение и загружать их сразу. Это поведение по умолчанию для полей, аннотированных @OneToMany, @ManyToMany и @ElementCollection. В объект загружается прокси lazy-поля.2) EAGER — данные поля будут загруженны немедленно. Это поведение по умолчанию для полей, аннотированных @Basic, @ManyToOne и @OneToOne.
Какие четыре статуса жизненного цикла Entity объекта (Entity Instance's Life Cycle) вы можете перечислить?	Transient (New) — свежесозданная оператором new() сущность не имеет связи с базой данных, не имеет данных в базе данных и не имеет сгенерированных первичных ключей.managed - объект создан, сохранён в бд, имеет primary key, управляется JPAdetached - объект создан, не управляется JPA. В этом состоянии сущность не связана со своим контекстом (отделена от него) и нет экземпляра Session, который бы ей управлял.removed - объект создан, управляется JPA, будет удален при commit-е и статус станет опять detached
Как влияет операция persist на Entity объекты каждого из четырех статусов?	new → managed, и объект будет сохранен в базу при commit-е транзакции или в результате flush операцийmanaged → операция игнорируется, однако зависимые Entity могут поменять статус на managed, если у них есть аннотации каскадных измененийdetached → exception сразу или на этапе commit-а транзакцииremoved → managed, но только в рамках одной транзакции.
Как влияет операция remove на Entity объекты каждого из четырех статусов?	new → операция игнорируется, однако зависимые Entity могут поменять статус на removed, если у них есть аннотации каскадных изменений и они имели статус managedmanaged → removed и запись объект в базе данных будет удалена при commit-е транзакции (также произойдут операции remove для всех каскадно зависимых объектов)detached → exception сразу или на этапе commit-а транзакцииremoved → операция игнорируется
Как влияет операция merge на Entity объекты каждого из четырех статусов?	new → будет создан новый managed entity, в который будут скопированы данные прошлого объектаmanaged → операция игнорируется, однако операция merge сработает на каскадно зависимые Entity, если их статус не manageddetached → либо данные будут скопированы в существующий managed entity с тем же первичным ключом, либо создан новый managed в который скопируются данныеremoved → exception сразу или на этапе commit-а транзакции
Как влияет операция refresh на Entity объекты каждого из четырех статусов?	managed → будут восстановлены все изменения из базы данных данного Entity, также произойдет refresh всех каскадно зависимых объектовnew, removed, detached → exception
Как влияет операция detach на Entity объекты каждого из четырех статусов?	managed, removed → detached.new, detached → операция игнорируется
Для чего нужна аннотация Basic?	@Basic - указывает на простейший тип маппинга данных на колонку таблицы базы данных. Также в параметрах аннотации можно указать fetch стратегию доступа к полю и является ли это поле обязательным или нет.Аннотация @Basic определяет 2 атрибута:1. optional - boolean (по умолчанию true) - определяет, может ли значение поля или свойства быть null. Игнорируется для примитивных типов. Но если тип поля не примитивного типа, то при попытке сохранения сущности будет выброшено исключение.2. fetch - FetchType (по умолчанию EAGER) - определяет, должен ли этот атрибут извлекаться незамедлительно (EAGER) или лениво (LAZY). Однако, это необязательное требование JPA, и провайдерам разрешено незамедлительно загружать данные, даже для которых установлена ленивая загрузка.Без аннотации @Basic при получении сущности из БД по умолчанию её поля базового типа загружаются принудительно (EAGER) и значения этих полей могут быть null
Для чего нужна аннотация Access?	Она определяет тип доступа (access type) для класса entity, суперкласса, embeddable или отдельных атрибутов, то есть как JPA будет обращаться к атрибутам entity, как к полям класса (FIELD) или как к свойствам класса (PROPERTY), имеющие гетеры (getter) и сетеры (setter).Определяет тип доступа к полям сущности. Для чтения и записи этих полей есть два подхода:1. Field access (доступ по полям). При таком способе аннотации маппинга (Id, Column,...) размещаются над полями, и Hibernate напрямую работает с полями сущности, читая и записывая их.2. Property access (доступ по свойствам). При таком способе аннотации размещаются над методами-геттерами, но никак не над сеттерами.По умолчанию тип доступа определяется местом, в котором находится аннотация @Id. Если она будет над полем - это будет AccessType.FIELD, если над геттером - это AccessType.PROPERTY.Чтобы явно определить тип доступа у сущности, нужно использовать аннотацию @Access, которая может быть указана у сущности, Mapped Superclass и Embeddable class, а также над полями или методами.Поля, унаследованные от суперкласса, имеют тип доступа этого суперкласса.Когда у одной сущности определены разные типы доступа, то нужно использовать аннотацию @Transient для избежания дублирования маппинга.
Для чего нужна аннотация @Cacheable?	@Cacheable - необязательная аннотация JPA, используется для указания того, должна ли сущность храниться в кэше второго уровня. JPA говорит о пяти значениях shared-cache-mode из persistence.xml, который определяет как будет использоваться second-level cache:❖ ENABLE_SELECTIVE: только сущности с аннотацией @Cacheable (равносильно значению по умолчанию @Cacheable(value=true)) будут сохраняться в кэше второго уровня.❖ DISABLE_SELECTIVE: все сущности будут сохраняться в кэше второго уровня, за исключением сущностей, помеченных @Cacheable(value=false) как некэшируемые.❖ ALL: сущности всегда кэшируются, даже если они помечены как некэшируемые.❖ NONE: ни одна сущность не кэшируется, даже если помечена как кэшируемая. При данной опции имеет смысл вообще отключить кэш второго уровня.❖ UNSPECIFIED: применяются значения по умолчанию для кэша второго уровня, определенные Hibernate. Это эквивалентно тому, что вообще не используется shared-cache-mode, так как Hibernate не включает кэш второго уровня, если используется режим UNSPECIFIED.Аннотация @Cacheable размещается над классом сущности. Её действие распространяется на эту сущность и её наследников, если они не определили другое поведение.
Для чего нужна аннотация @Cache?	Это аннотация Hibernate, настраивающая тонкости кэширования объекта в кэше второго уровня Hibernate. @Cache принимает три параметра:❖ include - имеет по умолчанию значение all и означающий кэширование всего объекта. Второе возможное значение - non-lazy, запрещает кэширование лениво загружаемых объектов. Кэш первого уровня не обращает внимания на эту директиву и всегда кэширует лениво загружаемые объекты.❖ region - позволяет задать имя региона кэша для хранения сущности. Регион можно представить как разные области кэша, имеющие разные настройки на уровне реализации кэша. Например, можно было бы создать в конфигурации ehcache два региона, один с краткосрочным хранением объектов, другой с долгосрочным и отправлять часто изменяющиеся объекты в первый регион, а все остальные - во второй. Ehcache по умолчанию создает регион для каждой сущности с именем класса этой сущности, соответственно в этом регионе хранятся только эти сущности. К примеру, экземпляры Foo хранятся в Ehcache в кэше с именем "com.baeldung.hibernate.cache.model.Foo".❖ usage - задаёт стратегию одновременного доступа к объектам.transactionalread-writenonstrict-read-writeread-only
Embeddable и Embedded	@Embeddable - аннотация JPA, размещается над классом для указания того, что класс является встраиваемым в другие классы.@Embedded - аннотация JPA, используется для размещения над полем в классе-сущности для указания того, что мы внедряем встраиваемый класс.
Как смапить составной ключ?	Составной первичный ключ, также называемый составным ключом, представляет собой комбинацию из двух или более столбцов для формирования первичного ключа таблицы.@IdClassДопустим, у нас есть таблица с именем Account, и она имеет два столбца - accountNumber и accountType, которые формируют составной ключ. Чтобы обозначить оба этих поля как части составного ключа мы должны создать класс, например, ComplexKey с этими полями.Затем нам нужно аннотировать сущность Account аннотацией @IdClass(ComplexKey.class). Мы также должны объявить поля из класса ComplexKey в сущности Account с такими же именами и аннотировать их с помощью @Id.@EmbeddedIdРассмотрим пример, в котором мы должны сохранить некоторую информацию о книге с заголовком и языком в качестве полей первичного ключа. В этом случае класс первичного ключа, BookId, должен быть аннотирован @Embeddable.Затем нам нужно встроить этот класс в сущность Book, используя @EmbeddedId.
Для чего нужна аннотация ID? Какие @GeneratedValue вы знаете?	Аннотация @Id определяет простой (не составной) первичный ключ, состоящий из одного поля. В соответствии с JPA, допустимые типы атрибутов для первичного ключа:1. примитивные типы и их обертки;2. строки;3. BigDecimal и BigInteger;4. java.util.Date и java.sql.Date.Если мы хотим, чтобы значение первичного ключа генерировалось для нас автоматически, мы можем добавить первичному ключу, отмеченному аннотацией @Id, аннотацию @GeneratedValue.Возможно 4 варианта: AUTO(default) - Указывает, что Hibernate должен выбрать подходящую стратегию для конкретной базы данных, учитывая её диалект, так как у разных БД разные способы по умолчанию. Поведение по умолчанию - исходить из типа поля идентификатора. IDENTITY - для генерации значения первичного ключа будет использоваться столбец IDENTITY, имеющийся в базе данных. Значения в столбце автоматически увеличиваются вне текущей выполняемой транзакции(на стороне базы, так что этого столбца мы не увидим), что позволяет базе данных генерировать новое значение при каждой операции вставки. В промежутках транзакций сущность будет сохранена.SEQUENCE - тип генерации, рекомендуемый документацией Hibernate. Для получения значений первичного ключа Hibernate должен использовать имеющиеся в базе данных механизмы генерации последовательных значений (Sequence). В бд можно будет увидеть дополнительную таблицу. Но если наша БД не поддерживает тип SEQUENCE, то Hibernate автоматически переключится на тип TABLE. В промежутках транзакций сущность не будет сохранена, так как хибер возьмет из таблицы id hibernate-sequence и вернётся обратно в приложение.SEQUENCE - это объект базы данных, который генерирует инкрементные целые числа при каждом последующем запросе. TABLE - Hibernate должен получать первичные ключи для сущностей из создаваемой для этих целей таблицы, способной содержать именованные сегменты значений для любого количества сущностей. Требует использования пессимистических блокировок, которые помещают все транзакции в последовательный порядок и замедляет работу приложения.
Расскажите про аннотации @JoinColumn и @JoinTable? Где и для чего они используются?	@JoinColumn используется для указания столбца FOREIGN KEY, используемого при установлении связей между сущностями или коллекциями. Мы помним, что только сущность-владелец связи может иметь внешние ключи от другой сущности (владеемой). Однако, мы можем указать @JoinColumn как во владеющей таблице, так и во владеемой, но столбец с внешними ключами всё равно появится во владеющей таблице. Особенности использования:❖ @OneToOne: означает, что появится столбец в таблице сущности-владельца связи, который будет содержать внешний ключ, ссылающийся на первичный ключ владеемой сущности.❖ @OneToMany/@ManyToOne: если не указать на владеемой стороне связи атрибут mappedBy, создается joinTable с ключами обеих таблиц. Но при этом же у владельца создается столбец с внешними ключами. @JoinColumns используется для группировки нескольких аннотаций @JoinColumn, которые используются при установлении связей между сущностями или коллекциями, у которых составной первичный ключ и требуется несколько колонок для указания внешнего ключа.В каждой аннотации @JoinColumn должны быть указаны элементы name и referencedColumnName.
Для чего нужны аннотации @OrderBy и @OrderColumn, чем они отличаются?	@OrderBy указывает порядок, в соответствии с которым должны располагаться элементы коллекций сущностей, базовых или встраиваемых типов при их извлечении из БД. Если в кэше есть нужные данные, то сортировки не будет. Так как @OrderBy просто добавляет к sql-запросу Order By, а при получении данных из кэша, обращения к бд нет. Эта аннотация может использоваться с аннотациями @ElementCollection, @OneToMany, @ManyToMany. При использовании с коллекциями базовых типов, которые имеют аннотацию @ElementCollection, элементы этой коллекции будут отсортированы в натуральном порядке, по значению базовых типов.Если это коллекция встраиваемых типов (@Embeddable), то используя точку (".") мы можем сослаться на атрибут внутри встроенного атрибута. Если это коллекция сущностей, то у аннотации @OrderBy можно указать имя поля сущности, по которому сортировать эти самые сущности:Если мы не укажем у @OrderBy параметр, то сущности будут упорядочены по первичному ключу.В случае с сущностями доступ к полю по точке не работает. Попытка использовать вложенное свойство, например @OrderBy ("supervisor.name") повлечет Runtime Exceprtion.@OrderColumn создает в таблице столбец с индексами порядка элементов, который используется для поддержания постоянного порядка в списке, но этот столбец не считается частью состояния сущности или встраиваемого класса.Hibernate отвечает за поддержание порядка как в базе данных при помощи столбца, так и при получении сущностей и элементов из БД. Hibernate отвечает за обновление порядка при записи в базу данных, чтобы отразить любое добавление, удаление или иное изменение порядка, влияющее на список в таблице.@OrderBy vs @OrderColumnПорядок, указанный в @OrderBy, применяется только в рантайме при выполнении запроса к БД, То есть в контексте персистентности, в то время как при использовании @OrderColumn, порядок сохраняется в отдельном столбце таблицы и поддерживается при каждой вставке/обновлении/удалении элементов.
Для чего нужна аннотация Transient?	@Transient используется для объявления того, какие поля у сущности, встраиваемого класса или Mapped SuperClass не будут сохранены в базе данных.Persistent fields (постоянные поля) - это поля, значения которых будут по умолчанию сохранены в БД. Ими являются любые не static и не final поля.Transient fields (временные поля):❖ static и final поля сущностей;❖ иные поля, объявленные явно с использованием Java-модификатора transient, либо JPA-аннотации @Transient.
Какие шесть видов блокировок (lock) описаны в спецификации JPA (или какие есть значения у enum LockModeType в JPA)?у	В порядке от самого ненадежного и быстрого, до самого надежного и медленного:1. NONE — без блокировки.2. OPTIMISTIC (синоним READ в JPA 1) — оптимистическая блокировка, которая работает, как описано ниже: если при завершении транзакции кто-то извне изменит поле @Version, то будет сделан RollBack транзакции и будет выброшено OptimisticLockException.3. OPTIMISTIC_FORCE_INCREMENT (синоним WRITE в JPA 1) — работает по тому же алгоритму, что и LockModeType.OPTIMISTIC за тем исключением, что после commit значение поле Version принудительно увеличивается на 1. В итоге окончательно после каждого коммита поле увеличится на 2(увеличение, которое можно увидеть в Post-Update + принудительное увеличение).4. PESSIMISTIC_READ — данные блокируются в момент чтения и это гарантирует, что никто в ходе выполнения транзакции не сможет их изменить. Остальные транзакции, тем не менее, смогут параллельно читать эти данные. Использование этой блокировки может вызывать долгое ожидание блокировки или даже выкидывание PessimisticLockException.5. PESSIMISTIC_WRITE — данные блокируются в момент записи и никто с момента захвата блокировки не может в них писать и не может их читать до окончания транзакции, владеющей блокировкой. Использование этой блокировки может вызывать долгое ожидание блокировки.6. PESSIMISTIC_FORCE_INCREMENT — ведёт себя как PESSIMISTIC_WRITE, но в конце транзакции увеличивает значение поля @Version, даже если фактически сущность не изменилась.Оптимистичное блокирование - подход предполагает, что параллельно выполняющиеся транзакции редко обращаются к одним и тем же данным и позволяет им свободно выполнять любые чтения и обновления данных. Но при окончании транзакции производится проверка, изменились ли данные в ходе выполнения данной транзакции и, если да, транзакция обрывается и выбрасывается OptimisticLockException. Оптимистичное блокирование в JPA реализовано путём внедрения в сущность специального поля версии:@Versionprivate long version;Поле, аннотирование @Version, может быть целочисленным или временнЫм. При завершении транзакции, если сущность была заблокирована оптимистично, будет проверено, не изменилось ли значение @Version кем-либо ещё, после того как данные были прочитаны, и, если изменилось, будет выкинуто OptimisticLockException. Использование этого поля позволяет отказаться от блокировок на уровне базы данных и сделать всё на уровне JPA, улучшая уровень конкурентности.Позволяет отказатьсь от блокировок на уровне БД и делать всё с JPA.Пессимистичное блокирование - подход напротив, ориентирован на транзакции, которые часто конкурируют за одни и те же данные и поэтому блокирует доступ к данным в тот момент когда читает их. Другие транзакции останавливаются, когда пытаются обратиться к заблокированным данным и ждут снятия блокировки (или кидают исключение). Пессимистичное блокирование выполняется на уровне базы и поэтому не требует вмешательств в код сущности.
Какие два вида кэшей (cache) вы знаете в JPA и для чего они нужны?	1. first-level cache (кэш первого уровня) — кэширует данные одной транзакции;2. second-level cache (кэш второго уровня) — кэширует данные транзакций от одной фабрики сессий. Провайдер JPA может, но не обязан реализовывать работу с кэшем второго уровня.Кэш первого уровня - это кэш сессии (Session), который является обязательным, это и есть PersistenceContext. Через него проходят все запросы.В том случае, если мы выполняем несколько обновлений объекта, Hibernate старается отсрочить (насколько это возможно) обновление этого объекта для того, чтобы сократить количество выполненных запросов в БД. Например, при пяти истребованиях одного и того же объекта из БД в рамках одного persistence context, запрос в БД будет выполнен один раз, а остальные четыре загрузки будут выполнены из кэша. Если мы закроем сессию, то все объекты, находящиеся в кэше, теряются, а далее - либо сохраняются в БД, либо обновляются.Особенности кэша первого уровня:❖ включен по умолчанию, его нельзя отключить;❖ связан с сессией (контекстом персистентности), то есть разные сессии видят только объекты из своего кэша, и не видят объекты, находящиеся в кэшах других сессий;❖ при закрытии сессии PersistenceContext очищается - кэшированные объекты, находившиеся в нем, удаляются;❖ при первом запросе сущности из БД, она загружается в кэш, связанный с этой сессией;❖ если в рамках этой же сессии мы снова запросим эту же сущность из БД, то она будет загружена из кэша, и никакого второго SQL-запроса в БД сделано не будет;❖ сущность можно удалить из кэша сессии методом evict(), после чего следующая попытка получить эту же сущность повлечет обращение к базе данных;❖ метод clear() очищает весь кэш сессии.Если кэш первого уровня привязан к объекту сессии, то кэш второго уровня привязан к объекту-фабрике сессий (Session Factory object) и, следовательно, кэш второго уровня доступен одновременно в нескольких сессиях или контекстах персистентности. Кэш второго уровня требует некоторой настройки и поэтому не включен по умолчанию. Настройка кэша заключается в конфигурировании реализации кэша и разрешения сущностям быть закэшированными.Hibernate не реализует сам никакого in-memory сache, а использует существующие реализации кэшей.
Как работать с кешем 2 уровня?	Чтение из кэша второго уровня происходит только в том случае, если нужный объект не был найден в кэше первого уровня.Hibernate поставляется со встроенной поддержкой стандарта кэширования Java JCache, а также двух популярных библиотек кэширования: Ehcache и Infinispan.В Hibernate кэширование второго уровня реализовано в виде абстракции, то есть мы должны предоставить любую её реализацию, вот несколько провайдеров: Ehcache, OSCache, SwarmCache, JBoss TreeCache. Для Hibernate требуется только реализация интерфейса org.hibernate.cache.spi.RegionFactory, который инкапсулирует все детали, относящиеся к конкретным провайдерам. По сути, RegionFactory действует как мост между Hibernate и поставщиками кэша. В примерах будем использовать Ehcache. Что нужно сделать: ❖ добавить мавен-зависимость кэш-провайдера нужной версии ❖ включить кэш второго уровня и определить конкретного провайдера hibernate.cache.use_second_level_cache=true hibernate.cache.region.factory_class=org.hibernate.cache.ehcache.EhCacheRegionFactory ❖ установить у нужных сущностей JPA-аннотацию @Cacheable, обозначающую, что сущность нужно кэшировать, и Hibernate-аннотацию @Cache, настраивающую детали кэширования, у которой в качестве параметра указать стратегию параллельного доступа Чтение из кэша второго уровня происходит только в том случае, если нужный объект не был найден в кэше первого уровня. Hibernate поставляется со встроенной поддержкой стандарта кэширования Java JCache, а также двух популярных библиотек кэширования: Ehcache и Infinispan.
Что такое JPQL/HQL и чем он отличается от SQL?	Hibernate Query Language (HQL) и Java Persistence Query Language (JPQL) - оба являются объектно-ориентированными языками запросов, схожими по природе с SQL. JPQL - это подмножество HQL.JPQL - это язык запросов, практически такой же как SQL, однако, вместо имен и колонок таблиц базы данных, он использует имена классов Entity и их атрибуты. В качестве параметров запросов также используются типы данных атрибутов Entity, а не полей баз данных. В отличии от SQL в JPQL есть автоматический полиморфизм, то есть каждый запрос к Entity возвращает не только объекты этого Entity, но также объекты всех его классов-потомков, независимо от стратегии наследования. В JPA запрос представлен в виде javax.persistence.Query или javax.persistence.TypedQuery, полученных из EntityManager. В Hibernate HQL-запрос представлен org.hibernate.query.Query, полученный из Session. Если HQL является именованным запросом, то будет использоваться Session#getNamedQuery, в противном случае требуется Session#createQuery.
Что такое Criteria API и для чего он используется?	Начиная с версии 5.2 Hibernate Criteria API объявлен deprecated. Вместо него рекомендуется использовать JPA Criteria API.JPA Criteria API - это актуальный API, используемый только для выборки(select) сущностей из БД в более объектно-ориентированном стиле.Основные преимущества JPA Criteria API:❖ ошибки могут быть обнаружены во время компиляции;❖ позволяет динамически формировать запросы на этапе выполнения приложения.Основные недостатки:❖ нет контроля над запросом, сложно отловить ошибку❖ влияет на производительность, множество классовДля динамических запросов - фрагменты кода создаются во время выполнения - JPA Criteria API является предпочтительней.
Расскажите про проблему N+1 Select и путях ее решения.	Проблема N+1 запросов возникает, когда получение данных из БД выполняется за N дополнительных SQL-запросов для извлечения тех же данных, которые могли быть получены при выполнении основного SQL-запроса.1. JOIN FETCHИ при FetchType.EAGER и при FetchType.LAZY нам поможет JPQL-запрос с JOIN FETCH. Опцию «FETCH» можно использовать в JOIN (INNER JOIN или LEFT JOIN) для выборки связанных объектов в одном запросе вместо дополнительных запросов для каждого доступа к ленивым полям объекта.Лучший вариант решения для простых запросов (1-3 уровня вложенности связанных объектов).select pcfrom PostComment pcjoin fetch pc.post p2. EntityGraphВ случаях, когда нам нужно получить по-настоящему много данных, и у нас jpql запрос - лучше всего использовать EntityGraph.3. @Fetch(FetchMode.SUBSELECT)Аннотация Hibernate. Можно использовать только с коллекциями. Будет сделан один sql-запрос для получения корневых сущностей и, если в контексте персистентности будет обращение к ленивым полям-коллекциям, то выполнится еще один запрос для получения связанных коллекций:@Fetch(value = FetchMode.SUBSELECT)private Set<Order> orders = new HashSet<>();4. Batch fetchingЭто Аннотация Hibernate, в JPA её нет. Указывается над классом сущности или над полем коллекции с ленивой загрузкой. Будет сделан один sql-запрос для получения корневых сущностей и, если в контексте персистентности будет обращение к ленивым полям-коллекциям, то выполнится еще один запрос для получения связанных коллекций. Количество загружаемых сущностей указывается в аннотации.@BatchSize(size=5)private Set<Order> orders = new HashSet<>();5. HibernateSpecificMapping, SqlResultSetMappingДля нативных запросов рекомендуется использовать именно их.
Что такое Maven? Для чего он нужен? Как добавлять в проект библиотеки без него?	Maven — инструмент для управления и сборки проектов, подключения зависимостей и создания документации. Pom.xml главный файл для управления. Добавить библиотеку без maven - кинуть jarник в папку lib.
Как добавить dependency в Maven? Для чего они нужны? Откуда они скачиваются?	Добавить в pom.xml, чаще всего из репозитория maven, можно так же из локального репозитория, так же есть вариант удаленного репозитория. Зависимости это разные полезные библиотеки/фреймворки.
Основные фазы проекта под управлением Maven?	1. compile - компилирование проекта; 2. test - тестирование с помощью JUnit тестов; 3. package - создание jar файла или war, ear в зависимости от типа проекта; 4. integration-test - запуск интеграционных тестов; 5. install - копирование jar (war, ear) в локальный репозиторий; 6. deploy - публикация файла в удалённый репозиторий.
Что такое JDBC? Какие классы/интерфейсы относятся к JDBC?	JDBC это стандартный API для независимого соединения языка программирования Java с различными базами данных. · Менеджер драйверов (Driver Manager)Этот элемент управляет списком драйверов БД. Каждой запрос на соединение требует соответствующего драйвера. Первое совпадение даёт нам соединение. · Драйвер (Driver)Этот элемент отвечает за связь с БД. Работать с ним нам приходится крайне редко. Вместо этого мы чаще используем объекты DriverManager, которые управляют объектами этого типа. · Соединение (Connection)Этот интерфейс обеспечивает нас методами для работы с БД. Все взаимодействия с БД происходят исключительно через Connection. · Выражение (Statement)Для подтверждения SQL-запросов мы используем объекты, созданные с использованием этого интерфейса. · Результат (ResultSet)Экземпляры этого элемента содержат данные, которые были получены в результате выполнения SQL - запроса. Он работает как итератор и "пробегает" по полученным данным. · Исключения (SQL Exception)Этот класс обрабатывает все ошибки, которые могут возникнуть при работе с БД.
Для чего нужен DriverManager?	Класс DriverManager является уровнем управления JDBC, отслеживает все доступные драйверы и управляет установлением соединений между БД и соответствующим драйвером. Чтобы сказать диспетчеру драйверов JDBC, какой именно драйвер следует загрузить, необходимо выполнить одну из команд : Class.forName("полное имя класса") Class.forName("полное имя класса").newInstance() DriverManager.registerDriver(new "полное имя класса")
Что такое PreparedStatement?	PreparedStatement - создаваемый запрос к БД который можно переиспользовать.
Что такое sql-injection?	Атака с помощью sql запроса, например когда в форму ввода данных пользователь вводит sql запрос.
Как получить все записи из одной таблицы в JDBC?	select * from table
Как получить из ResultSet вторую ячейку второй строки, если в таблице, на основе которой был построен ResultSet всего три столбца и три строки?	resultset.next() resultSet.next() resultset.get(2)
Рассказать про паттерн DAO.	Data Acsess Object, паттерн при котором создается отдельный слой для взаимодействия с БД, изолируя бизнес логику от логики доступа к данным. Позволяет не привязывать приложение к логике взаимодействия с конкретным типом хранения данных.
Что такое JPA?	JPA (Java Persistence API) это спецификация Java EE и Java SE, описывающая систему управления сохранением java объектов в таблицы реляционных баз данных в удобном виде. Сама Java не содержит реализации JPA, однако существует много реализаций данной спецификации от разных компаний (открытых и нет). Это не единственный способ сохранения java объектов в базы данных (ORM систем), но один из самых популярных в Java мире.
Что такое ORM?	ORM — это концепция о том, что Java объект можно представить как данные в БД (и наоборот). Она нашла воплощение в виде спецификации JPA — Java Persistence API.
Что такое Hibernate?	Hibernate — это библиотека, которая предназначена для задач объектно-реляционного отображения. Если простыми словами — hibernate позволяет разработчику работать с базой данных не напрямую, с помощью библиотеки JDBC а с помощью представления таблиц баз данных в виде классов java.
В чем разница между JPA и Hibernate? Как связаны все эти понятия? (нужно четкое понимание и умение объяснить).	Hibernate одна из самых популярных открытых реализаций последней версии спецификации (JPA 2.1). Даже скорее самая популярная, почти стандарт де-факто. То есть JPA только описывает правила и API, а Hibernate реализует эти описания.
Основные аннотации Hibernate, рассказать.	@Id. @GeneratedValue определеяет генерацию. @Entity указывает на сущность. @Table Так говорим Hibernate, с какой именно таблицей необходимо связать данный класс. @Column к какому столбцу относить поле, есть значения unique, name, nullable lenght.
Обязательны ли аннотации @Column и @Table?	Нет, автоматически используются имя класса или поля.
Что делать, если я не хочу сохранять какое-то поле в БД?	@Transient
Для чего нужны @Id и @GeneratedValue?	@Id уникальный идентификатор сущности. @GeneratedValue механизмы автоматической генерации значений суррогатных ключей.
Как достать все записи из таблицы используя HQL?	from Object
Чем HQL отличается от SQL?	SQL работает с данными, HQL обьектно ориентирован и работает с сущностями.
Как передать в объект Query параметры?	Integer id = 1; Query query = session.createQuery("from Employee e where e.idEmployee=:id"); query.setParameter("id", id);
Какие можно устанавливать параметры в hbm2ddl, рассказать про каждый из них.	auto: none: ничего не делать validate: проверить схему, не вносить изменения в базу данных. update: обновить схему. create: создает схему, уничтожая предыдущие данные. create-drop: отказаться от схемы, когда SessionFactory закрывается явно, как правило, когда приложение остановлено.
Требования JPA к Entity-классам? Не менее пяти.	Аннотация Entity. Иметь пустой конструктор public или protected. Иметь уникальный id. Быть классом верхнего уровня. Переменные Entity класса не должны быть доступны извне, должны быть реализованы с помощью методов получения и установки значений getter/setter.
Жизненный цикл Entity в Hibernate? Рассказать.	new - обьект создан-не имеет primary key. managed - обьект создан имеет primary key , управляется JPA. detached - обьект создан, не управляется JPA. removed - обьект создан, управляется JPA, будет удален при коммите
Что такое Spring? Чем фреймворк отличается от библиотеки?	Spring это фреймворк, берет контроль над классами(бинами) и внедряет зависимости. Библиотека это набор инструментов которыми нужно управлять вручную.
Что такое Inversion of Control?	IOC переносит ответственность за выполнение действий с кода приложения на фреймворк.
Что такое DI? Чем отличается от композиции?	Dependency injection это когда зависимости нам внедряет фреймворк. Композиция это когда мы вручную внедряем зависимости.
Что такое bean?	В Spring-е бином (bean) называют любой класс, который управляется контейнером Spring, находится в контейнере.
Скоупы бинов? Какой по-умолчанию?	• singleton - объект создается однажды, при последующих внедрениях переиспользуется. Полезен для большинства случаев: различные сервисы, объекты без состояния, неизменяемые объекты. Это скоуп по умолчанию. • prototype - при каждом внедрении фабрика бинов создает новый объект. Нужен для изменяемых бинов с состоянием. Можно создавать свои скоупы, например threadLocal.
Рассказать про Singlton, как реализуется без Спринга?	Одиночка — это порождающий паттерн, который гарантирует существование только одного объекта определённого класса. Приватный конструктор и статический создающий метод.
Что будет если 2 бина реализуют один и тот же интерфейс и как сделать что бы это работало?	Можно указать Qualifier, можно один пометить как Primary.
@Autowired, где можно ставить и какие есть отличия? Плюсы и минусы каждого способа. Почему не рекомендуется связывать через поле?	При внедрении прямо в поля вы не предоставляете прямого способа создания экземпляра класса со всеми необходимыми зависимостями. Сеттеры следует использовать для инъекций опциональных зависимостей. Класс должен быть способен функционировать, даже если они не были предоставлены Инъекция через конструкторы хороша для обязательных зависимостей — тех, которые требуются для корректной функциональности объекта. Передавая их через конструктор, вы можете быть уверенными в том, что объект полностью готов к использованию с момента создания. Поля, присвоенные в конструкторе, также могут быть final, что позволяет объекту быть полностью неизменным или как минимум защищает необходимые поля.
Для чего используется аннотация ComponentScan, где её можно указывать?	В @ComponentScan вы указываете пакеты, которые должны сканироваться в поиске бинов. Указывается в конфигурации.
Какая основная зависимость фреймворка Спринг? Почему во многих сборках она не указывается явно?	spring-core транзитивная зависимость, подтягивается сама другими модулями.
Как работает аннотация @PropertySource?	@PropertySource предоставляет механизм для добавления источника пар свойств имя / значение в среду Spring,
Рассказать про класс Enviroment.	Интерфейс Environment представляет окружение, в котором приложение запущено. Свойства (properties) - это не только содержимое файлов с соответствующим расширением, но и свойства JVM, переменные окружения операционной системы, параметры сервлета (если приложение запущено в соответствующем контейнере) и многое другое. Environment предоставляет к ним ко всем единообразный доступ.
Как еще можно читать файл .properties в Spring?	С помощью java.util.Properties
Как запустить Spring -приложение из-под сервера Tomcat?	Создать билд war/war-exploded, сконфигурировать томкэт из среды, запустить.
В чем отличие артефакта war от war exploded?	war это архив с веб приложением. exploded это распакованая на сервере версия, позволяет обновлять конфигурацию без редеплоя.
Рассказать про аннотации Controller, Service, Component, Repository, Bean, Configuration. Чем они отличаются друг от друга?	@Component - аннотация класса-компонента приложения в спринге. @Service - специализированная component для сервис слоя. @Repository - специализированная component для persistence слоя(ДАО). @Controller - специализированная component для presentation слоя в MVC. @Bean - аннотация метода в котором описан bean. @Configuration - аннотация конфиг класса спринга.
Как выглядит структура MVC-приложения? Что есть Model / View / Controller?	Model (Модель) инкапсулирует (объединяет) данные приложения, Контроллер управляет запросами пользователя (получаемые в виде запросов HTTP GET или POST, когда пользователь нажимает на элементы интерфейса для выполнения различных действий). Его основная функция — вызывать и координировать действие необходимых ресурсов и объектов, нужных для выполнения действий, задаваемых пользователем. View это представление приложения, например страницы html.
Чем контроллер отличается от сервлета?	Сервлет принимает запросы от пользователя и перенаправляет их на определенный контроллер.
Как вернуть страницу в контроллере? Как вернуть данные?	Вернуть страницу можно по ее названию. Вернуть данные с помощью модели.
Что еще можно принимать в методах контроллера, что можно возвращать из этих методов?	Можно принимать параметры из запроса, возвращать обьекты через модель, работать с ними в отображении.Методы в классе-контроллере могут использовать некоторые типы объектов в качестве принимаемых аргументов. Тогда Spring автоматически внедрит их. Например, нужный объект HttpSession, Security, и т.п.
В чём отличие @RequesMapping от @GetMapping, @PostMapping?	RequestMapping более общая аннотация, остальные ее "наследники". GetMapping/Post мы можем применять только на уровне метода, а аннотацию RequestMapping мы можем применять как на уровне класса
Что такое объект Model, View и ModelAndView?	View используется для отображения данных приложения пользователю.Spring MVC поддерживает несколько поставщиков View(они называются шаблонизаторы) — JSP, JSF, Thymeleaf. Model это объект класса который реализует интерфейс Model и представляет коллекцию пар ключ-значение. ModelAndView это обьект содержащий model и view для удобства возвращения из контроллера.
Что такое HTTP, основные его методы?	HTTP — протокол прикладного уровня передачи данных. Метод GET запрашивает представление ресурса. Можно только извлекать данные. POST используется для отправки сущностей/данных к определённому ресурсу. PATCH для обновления данных. PUT для обновления или отправки новых данных. DELETE для удаления. HEAD запрашивает ресурс так же, как GET, но без тела ответа.
Коды состояний HTTP	1xx информационные 2хх успешно 3хх редирект 4хх ошибка клиента 5хх ошибка сервера
Что такое http-заголовок? Что такое http-сессия?	Заголовки HTTP являются основной частью этих HTTP-запросов и ответов, и они несут информацию о браузере клиента, запрошенной странице, сервере и многом другом. HTTP сессия состоит из трёх фаз: Клиент устанавливает TCP соединения (или другое соединение, если не используется TCP транспорт). Клиент отправляет запрос и ждёт ответа. Сервер обрабатывает запрос и посылает ответ, в котором содержится код статуса и соответствующие данные. Начиная с версии HTTP/1.1, после третьей фазы соединение не закрывается, так как клиенту позволяется инициировать другой запрос. То есть, вторая и третья фазы могут повторяться.
Что такое ORM?	ORM - технология программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования, создавая "виртуальную объектную базу данных".
Какие преимущства от использования Hibernate?	Устраняет множество повторяющегося кода, который постоянно преследует разработчика при работе с JDBC. Скрывает от разработчика множество кода, необходимого для управления ресурсами и позволяет сосредоточиться на бизнес логике. Поддерживает XML так же как и JPA аннотации, что позволяет сделать реализацию кода независимой. Предоставляет собственный мощный язык запросов (HQL), который похож на SQL. Стоит отметить, что HQL полностью объектно-ориентирован и понимает такие принципы, как наследование, полиморфизм и ассоциации (связи). Hibernate легко интегрируется с другими Java EE фреймворками, например, Spring Framework поддерживает встроенную интеграцию с Hibernate. Поддерживает ленивую инициализацию используя proxy объекты и выполняет запросы к базе данных только по необходимости. Поддерживает разные уровни cache, а следовательно может повысить производительность. Важно, что Hibernate может использовать чистый SQL, а значит поддерживает возможность оптимизации запросов и работы с любым сторонним вендором БД. Hibernate - open source проект. Благодаря этому доступны тысячи открытых статей, примеров, а так же документации по использованию фреймворка.
Как Hibernate помогает в программировании?	Hibernate реализует ряд фичь которые значительно упрощают работу разработчика. Одной из таких фичь является то, что hibernate позволяет разработчику избежать написания большинства SQL запросов (они уже реализованы , вам надо просто использовать методы которые предоставляет фреймворк). Под бортом у Hibernate есть куча полезных инструментов которые значительно ускоряют работу приложения, самыми примечательными из них являются двухуровневое кэширования и тонкие настройки lazy и fetch изъятия. Сам генерирует таблицы в базу данных
Какие преимущества Hibernate над JDBC?	Hibernate имеет ряд преимуществ перед JDBC API: Hibernate удаляет множество повторяющегося кода из JDBC API, а следовательно его легче читать, писать и поддерживать. Hibernate поддерживает наследование, ассоциации и коллекции, что не доступно в JDBC API. Hibernate неявно использует управление транзакциями. Большинство запросов нельзя выполнить вне транзакции. При использовании JDBC API для управления транзакциями нужно явно использовать commit и rollback. JDBC API throws SQLException, которое относится к проверяемым исключениям, а значит необходимо постоянно писать множество блоков try-catch. В большинстве случаев это не нужно для каждого вызова JDBC и используется для управления транзакциями. Hibernate оборачивает исключения JDBC через непроверяемые JDBCException или HibernateException, а значит нет необходимости проверять их в коде каждый раз. Встроенная поддержка управления транзакциями в Hibernate убирает блоки try-catch. Hibernate Query Language (HQL) более объектно ориентированный и близкий к Java язык программирования, чем SQL в JDBC. Hibernate поддерживает кэширование, а запросы JDBC - нет, что может понизить производительность. Hibernate предоставляет возможность управления БД (например создания таблиц), а в JDBC можно работать только с существующими таблицами в базе данных. Конфигурация Hibernate позволяет использовать JDBC вроде соединения по типу JNDI DataSource для пула соединений. Это важная фича для энтерпрайз приложений, которая полностью отсутствует в JDBC API. Hibernate поддерживает аннотации JPA, а значит код является переносимым на другие ORM фреймворки, реализующие стандарт, в то время как код JDBC сильно привязан к приложению.
Что такое конфигурационный файл Hibernate?	Файл конфигурации Hibernate содержит в себе данные о базе данных и необходим для инициализации SessionFactory. В .xml файле необходимо указать вендора базы данных или JNDI ресурсы, а так же информацию об используемом диалекте, что поможет hibernate выбрать режим работы с конкретной базой данных.
Способы конфигурации работы с Hibernate.	Существует четыре способа конфигурации работы с Hibernate   используя аннотации; hibernate.cfg.xml; hibernate.properties; persistence.xml. Самый частый способ конфигурации: через аннотации и файл persistence.xml, что касается файлов hibernate.properties и hibernate.cfg.xml, то hibernate.cfg.xml главнее (если в приложение есть оба файла, то принимаются настройки из файла hibernate.cfg.xml). Конфигурация аннотациями, хоть и удобна, но не всегда возможна, к примеру, если для разных баз данных или для разных ситуаций вы хотите иметь разные конфигурацию сущностей, то следует использовать xml файлы конфигураций.
Что такое Hibernate mapping file?	Файл отображения (mapping file) используется для связи entity бинов и колонок в таблице базы данных. В случаях, когда не используются аннотации JPA, файл отображения .xml может быть полезен (например при использовании сторонних библиотек).
Что такое Переходные объекты (Transient Objects)?	Экземпляры долгоживущих классов, которые в настоящее время не связаны c Cессией. Они, возможно, были инициализированы в приложении и еще не сохранены, или же они были инициализированы закрытой Cессией.
Что такое постоянные объекты (Persistent objects)?	Короткоживущие, однопоточные объекты, содержащие постоянное состояние и бизнес-функции. Это могут быть простые Java Beans/POJOs (Plain Old Java Object). Они связаны только с одной Cессией. После того, как Cессия закрыта, они будут отделены и свободны для использования в любом протоколе прикладного уровня (например, в качестве объектов передачи данных в и из представления).
Что такое TransactionFactory?	Фабрика для экземпляров Transaction. Интерфейс не открыт для приложения, но может быть расширен или реализован разработчиком.
Что такое Трансакция (Transaction)?	Однопоточный, короткоживущий объект, используемый приложением для указания atomic переменных работы. Он абстрагирует приложение от основных JDBC, JTA или CORBA трансакций. Сессия может охватывать несколько Трансакций в некоторых случаях. Тем не менее, разграничение транзакций, также используемое в основах API или Transaction, всегда обязателно.
Что такое Пул соединений ?	Пул соединений - это метод повышения производительности приложения, когда N соединений с базой данных открываются и управляются в пуле. Приложение просто запрашивает соединение, использует его и затем отбрасывает обратно в пул. Когда приложение требует подключения, готовые подключения остаются доступными для использования в пуле. Пул управляет жизненным циклом соединения, так что разработчику фактически не нужно ждать установления соединения и отфильтровывать устаревшие. Механизм объединения пула избавляет от дорогостоящей операции, чтобы установить сетевое соединение во время выполнения приложения и в конечном итоге инициализировать сеанс базы данных на бэкэнде. Внутренний алгоритм пулинга соединений в Hibernate довольно рудиментарен, и нужен, по большей части, для разработки и тестирования. Используйте сторонние (3rd party) пулы для лучшей производительности и стабильности. Для использования 3rd party пула, замените значение свойства hibernate.connection.pool_size на соответствующие специфике вашего выбранного пула. Это отключит использование встроенного пула Hibernate.
Какие бывают пулы соединений	c3p0 Proxool JNDI
Пулинг с помощью c3p0	C3P0 - опенсорсный пул JDBC-соединений, распространяемый вместе с Hibernate в директории lib/. Hibernate будет использовать свой собственный org.hibernate.service.jdbc.connections.internal.C3P0ConnectionProvider для пулинга соединений, при настройке свойств hibernate.c3p0.* Важные конфигурационные свойства для c3p0 hibernate.c3p0.min_size hibernate.c3p0.max_size hibernate.c3p0.timeout hibernate.c3p0.max_statements
Пулинг с помощью Proxool	Proxool — другой опенсорсный пул, распространяемый вместе с Hibernate в директории lib/. Hibernate будет использовать свой собственный org.hibernate.service.jdbc.connections.internal.ProxoolConnectionProvider для пулинга соединений при соответствующей настройке hibernate.proxool.*. В отличие от c3p0, proxool требует некоторых дополнительных параметров настройки, которые описаны в документации, доступной на proxool.sourceforge.net/configure.html. hibernate.proxool.xml - Сконфигурируйте провайдер Proxool, используя указанный файл XML (.xml добавляется автоматически )hibernate.proxool.properties - Сконфигурируйте провайдер Proxool, используя указанный property-файл (.properties добавляется автоматически) hibernate.proxool.existing_pool - Конфигурировать ли провайдер Proxool из существующего пулаhibernate.proxool.pool_alias - Псевдоним пула Proxool. Необходим.
Получение соединений от сервера приложений, через JNDI	Для использования Hibernate внутри сервера приложений, настройте Hibernate для получения соединений от javax.sql.Datasource, зарегистрированном в JNDI, установив по крайней мере одно из следующих свойств:Важные свойства для источников данных JNDI hibernate.connection.datasource (необходимо) hibernate.jndi.url hibernate.jndi.class hibernate.connection.username hibernate.connection.password JDBC-соединения, полученные из источника данных JNDI, автоматически участвуют в container-managed транзакциях сервера приложений.
Какие существуют стратегии загрузки объектов в Hibernate?	Существуют следующие типа fetch'a: Join fetching: hibernate получает ассоциированные объекты и коллекции одним SELECT используя OUTER JOIN Select fetching: использует уточняющий SELECT чтобы получить ассоциированные объекты и коллекции. Если вы не установите lazy fetching определив lazy="false", уточняющий SELECT будет выполнен только когда вы запрашиваете доступ к ассоциированным объектам Subselect fetching: поведение такое же, как у предыдущего типа, за тем исключением, что будут загружены ассоциации для все других коллекций, "родительским" для которых является сущность, которую вы загрузили первым SELECT'ом. Batch fetching: оптимизированная стратегия вида select fetching. Получает группу сущностей или коллекций в одном SELECT'е.
Какие бывают id generator классы в Hibernate?	increment - генерирует идентификатор типа long, short или int, которые будет уникальным только в том случае, если другой процесс не добавляет запись в эту же таблицу в это же время. identity - генерирует идентификатор типа long, short или int. Поддерживается в DB2, MySQL, MS SQL Server, Sybase и HypersonicSQL. sequence - использует последовательности в DB2, PostgreSQL, Oracle, SAP DB, McKoi или генератор Interbase. Возвращает идентификатор типа long, short или int. hilo - использует алгоритм hi/lo для генерации идентификаторов типа long, short или int. Алгоритм гарантирует генерацию идентификаторов, которые уникальны только в данной базе данных. seqhilo - использует алгоритм hi/lo для генерации идентификаторов типа long, short или int учитывая последовательность базы данных. uuid - использует для генерации идентификатора алгоритм 128-bit UUID. Идентификатор будет уникальным в пределах сети. UUID представляется строкой из 32 чисел. guid - использует сгенерированую БД строку GUID в MS SQL Server и MySQL. native - использует identity, sequence или hilo в завимисимости от типа БД, с которой работает приложение assigned - позволяет приложению устанавливать идентификатор объекту, до вызова метода save(). Используется по умолчанию, если тег <generator> не указан. select - получает первичный ключ, присвоенный триггером БД foreign - использует идентификатор другого, связанного с данным объекта. Используется в <one-to-one> ассоциации первичных ключей. sequence-identity - специализированный генератор идентификатора.
Какие ключевые интерфейсы использует Hibernate?	Существует пять ключевых интерфейсов которые используются в каждом приложении связанном с Hibernate: Session interface; SessionFactory interface; Configuration interface; Transaction interface; Query and Criteria interfaces.
Назовите некоторые важные аннотации, используемые для отображения в Hibernate.	Hibernate поддерживает как аннотации из JPA, так и свои собственные, которые находятся в пакете org.hibernate.annotations. Наиболее важные аннотации JPA и Hibernate: javax.persistence.Entity: используется для указания класса как entity bean. javax.persistence.Table: используется для определения имени таблицы из БД, которая будет отображаться на entity bean. javax.persistence.Access: определяет тип доступа, поле или свойство. Поле — является значением по умолчанию и если нужно, чтобы hibernate использовать методы getter/setter, то их необходимо задать для нужного свойства. javax.persistence.Id: определяет primary key в entity bean. javax.persistence.EmbeddedId: используется для определения составного ключа в бине. javax.persistence.Column: определяет имя колонки из таблицы в базе данных. javax.persistence.GeneratedValue: задает стратегию создания основных ключей. Используется в сочетании с  javax.persistence.GenerationType enum. javax.persistence.OneToOne: задает связь один-к-одному между двумя сущностными бинами. Соответственно есть другие аннотации OneToMany, ManyToOne и ManyToMany. org.hibernate.annotations.Cascade: определяет каскадную связь между двумя entity бинами. Используется в связке с org.hibernate.annotations.CascadeType. javax.persistence.PrimaryKeyJoinColumn: определяет внешний ключ для свойства. Используется вместе с org.hibernate.annotations.GenericGenerator и org.hibernate.annotations.Parameter.
Какая роль интерфейса Session в Hibernate?	Объект Hibernate Session является связью между кодом java приложения и hibernate. Это основной интерфейс для выполнения операций с базой данных. Жизненный цикл объекта session связан с началом и окончанием транзакции. Этот объект предоставляет методы для CRUD (create, read, update, delete) операций для объекта персистентности. С помощью этого экземпляра можно выполнять HQL, SQL запросы и задавать критерии выборки. (персистентный объект - объект который уже находится в базе данных; объект запроса - объект который получается когда мы получаем результат запроса в базу данных, именно с ним работает приложение). Обьект Session можно получить из SessionFactory : Session session = sessionFactory.openSession(); Роль интерфейса Session: является оберткой для jdbc подключения к базе данных; является фабрикой для транзакций (согласно официальной документации transaction - аllows the application to define units of work, что , по сути, означает что транзакция определяет границы операций связанных с базой данных). является хранителем обязательного кэша первого уровня.
Какая роль интерфейса SessionFactory в Hibernate?	SessionFactory является фабрикой классов и используется для получения объектов session. SessionFactory отвечает за считывание параметров конфигурации Hibernate и подключение к базе данных. Обычно в приложении имеется только один экземпляр SessionFactory и потоки, обслуживающие клиентские запросы, получают экземпляры session с помощью объекта SessionFactory. Внутреннее состояние SessionFactory неизменно (immutable). Internal state (внутреннее состояние) включает в себя все метаданные об Object/ Relational Mapping и задается при создании SessionFactory. SessionFactory также предоставляет методы для получения метаданных класса и статистики, вроде данных о втором уровне кэша, выполняемых запросах и т.д. SessionFactory кэширует мета-дату и SQL запросы которые часто используются приложением во время работы. Так же оно кэширует информацию которая была получена в одной из транзакций и может быть использована и в других транзакциях. Обьект SessionFactory можно получить следующим обращением: SessionFactory sessionFactory = configuration. buildSessionFactory();
Является ли Hibernate SessionFactory потокобезоспансым?	Т.к. объект SessionFactory immutable (неизменяемый), то да, он потокобезопасный. Множество потоков может обращаться к одному объекту одновременно.
В чем разница между openSession и getCurrentSession?	Hibernate SessionFactory getCurrentSession() возвращает сессию, связанную с контекстом. Но для того, чтобы это работало, нам нужно настроить его в конфигурационном файле hibernate. Так как этот объект session связан с контекстом hibernate, то отпадает необходимость к его закрытию. Объект session закрывается вместе с закрытием SessionFactory. <property name="hibernate.current_session_context_class">thread</property> Метод Hibernate SessionFactory openSession() всегда создает новую сессию. Мы должны обязательно контролировать закрытие объекта сеанса по завершению всех операций с базой данных. Для многопоточной среды необходимо создавать новый объект session для каждого запроса. Существует еще один метод openStatelessSession(), который возвращает session без поддержки состояния. Такой объект не реализует первый уровень кэширования и не взаимодействует с вторым уровнем. Сюда же можно отнести игнорирование коллекций и некоторых обработчиков событий. Такие объекты могут быть полезны при загрузке больших объемов данных без удержания большого кол-ва информации в кэше.
Какие типы коллекций представлены в Hibernate?	Bag, Set, List, Map, Array.
Физические транзакции Hibernate	Hibernate использует JDBC API для персистентности. В мире Java есть два хорошо определенных механизма работы с транзакциями: непосредственно JDBC и JTA. Hibernate поддерживает оба механизма интеграции с транзакциями и позволяет приложениям управлять физическими транзакциями.Первая концепция в понимании поддержки транзакций в Hibernate - это интерфейс  org.hibernate.engine.transaction.spi.TransactionFactory, который предоставляет две основные функции: Он позволяет Hibernate понимать семантику транзакций текущего окружения. Работаем ли мы сейчас в окружении JTA? Является ли физическая транзакция в данной момент уже активной, и.т.д Он выступает как фабрика экземпляров org.hibernate.Transaction, используемых приложением для управления и проверки состояния транзакций, org.hibernate.Transaction - понятие логической транзакции в Hibernate's. JPA имеет похожее понятие в интерфейсе javax.persistence.EntityTransaction.
Какие типы менеджмента транзакций поддерживаются в Hibernate?	Hibernate взаимодействует с БД через JDBC-соединение. Таким образом он поддерживает управляемые и не управляемые транзакции. Неуправляемые транзакции в web-контейнере: <bean id="transactionManager" class="org.springframework. orm. hibernate. HibernateTransactionManager" <property name="sessionFactory"> <ref local="sessionFactory"/> </property> </bean> Управляемые транзакции на сервере приложений, использующий JTA: <bean id="transactionManager" class="org.springframework. transaction. jtaTransactionManager."> <property name="sessionFactory"> <ref local="sessionFactory" /> </property> </bean>
Что собой являет коллекция типа Bag и зачем она используется?	Своей реализации тип коллекции Bag очень напоминает Set, разница состоит в том, что Bag может хранить повторяющиеся значения. Bag хранит непроиндексированный список элементов. Большинство таблиц в базе данных имеют индексы отображающие положение элемента данных один относительно другого, данные индексы имеют представление в таблице в виде отдельной колонки. При объектно-реляционном маппинге, значения колонки индексов мапится на индекс в Array, на индекс в List или на key в Map. Если вам надо получить коллекцию объектов не содержащих данные индексы, то вы можете воспользоваться коллекциями типа Bag или Set (коллекции содержат данные в неотсортированном виде, но могут быть отсортированы согласно запросу).
Какие типы кэша используются в Hibernate?	Hibernate использует 2 типа кэша: кэш первого уровня и кэш второго уровня. Кэш первого уровня ассоциирован с объектом сесии, в то время, как кэш второго уровня ассоциирован с объектом фабрики сессий. По-умолчанию Hibernate использует кэш первого уровня для каждой операции в транзакции. В первую очередь кэш используется чтобы уменьшить количество SQL-запросов. Например если объект модифицировался несколько раз в одной и той же транзакции, то Hibernate сгенерирует только один UPDATE. Если сессия обычно (у нас точно) привязана к транзакции и закрывается каждый раз по ее окончании, то SessionFactory создается один раз на все приложение. Этот кэш и считается кэшем второго уровня, но по умолчанию он не работает - его надо включать. Кэш второго уровня - это прослойка, общая для всех сессий. То есть одна сессия извлекла сущность, а другая может получить к этой сущности потом доступ. Очевидно, что с такой прослойкой есть проблема - ее данные могут устареть. В базе данные одни, а в кэше второго уровня - другие. Особенно, если помимо нашего приложения базу обновляет еще какой-то процесс. Но иногда все-таки от кэша второго уровня есть польза. Например, если наша сущность в принципе не редактируема (такой вот задан функционал), а доступна только для чтения. В этом случае почему бы не дать возможность всем сессиям брать готовую сущность, а не извлекать ее из базы каждый раз заново. Все равно сущность не устареет (так как она неизменяемая). Таким образом если результат запроса находится в кэше, мы потенциально уменьшаем количество транзакций к БД. EHCache - это быстрый и простой кэш. Он поддерживает read-only и read/write кэширование, а так же кэширование в память и на диск. Но не поддерживает кластеризацию. OSCache - это другая opensource реализация кэша. Помимо всего, что поддерживает EHCache, эта реализация так же поддерживает кластеризацию через JavaGroups или JMS. SwarmCache - это просто cluster-based решение, базирующееся на JavaGroups. Поддерживает read-only и нестрогое read/write кэширование. Этот тип кэширование полезен, когда количество операций чтения из БД превышает количество операций записи. JBoss TreeCache - предоставляет полноценный кэш транзакции.
Какие существуют типы стратегий кэша?	Read-only: эта стратегия используется когда данные вычитываются, но никогда не обновляется. Самая простая и производительная стратегия Read/write: подходит для приложения, где данные обновляются регулярно. Не используйте read-write стратегию, если вам нужна сериализуемая изоляция транзакций. В JTA-окружении, укажите стратегию для получения JTA TransactionManager, выставив свойство hibernate.transaction.manager_lookup_class. В не-JTA окружениях, убедитесь, что транзакция завершена, перед тем как вызвать Session.close() или Session.disconnect(). Нестрогий read/write: эта стратегия не гарантирует, что две транзакции не модифицируют одни и те же данные синхронно. Некоторым приложениям необходимо лишь иногда читать данные. Это тот случай, когда две транзакции врядли одновременно обновят одну и ту же сущность. В таком случае, вам не нужно ограничивать изоляцию транзакций, и nonstrict-read-write кэш весьма подходящ. Если кэш используется в JTA-окружении, вы должны указать hibernate.transaction.manager_lookup_class. В других окружениях, убедитесь что транзакция завершена, перед тем как вызвать Session.close() или Session.disconnect(). Transactional: стратегия кэширования предоставляет поддержку для транзакционных кэш-провайдеров, таких как JBoss TreeCache. Использовать такой кэш вы можете только в JTA-окружении, и для начала вам нужно будет указать hibernate.transaction.manager_lookup_class.
Что вы знаете о кэширование в Hibernate? Объясните понятие кэш первого уровня в Hibernate?	Hibernate использует кэширование, чтобы сделать наше приложение быстрее. Кэш Hibernate может быть очень полезным в получении высокой производительности приложения при правильном использовании. Идея кэширования заключается в сокращении количества запросов к базе данных. Кэш первого уровня - это кэш Сессии (Session), который является обязательным. Через него проходят все запросы. Перед тем, как отправить объект в БД, сессия хранит объект за счёт своих ресурсов. А именно: Hibernate хранит отслеживаемые сущности в Map, ключами которой являются id сущностей, а значениями - сами объекты-сущности. Если мы извлекаем из базы сущность по id с помощью EntityManager.find(), то сущность помещается в этот Map и хранится в нем до закрытия сессии. И при повторном find() SQL-команда select в базе данных выполнена не будет. Hibernate возьмет эту сущность из Map - карты отслеживаемых сущностей. В том случае, если мы выполняем несколько обновлений объекта, Hibernate старается отсрочить (насколько это возможно) обновление для того, чтобы сократить количество выполненных запросов. Если мы закроем сессию, то все объекты, находящиеся в кэше теряются, а далее - либо сохраняются, либо обновляются.
Как настраивается кэш второго уровня в Hibernate?	Чтобы указать кэш второго уровня нужно определить hibernate.cache.provider_class в hibernate.cfg.xml: <hibernate-configuration> <session-factory> <property name="hibernate.cache.provider_class">org. hibernate, cache. EHCacheProvider</property> </session-factory> </hibernate-configuration> По-умолчанию используется EHCache. Чтобы использвать кэш запросов нужно его включить установив свойство hibernate.cache.use_query_cache в true в hibernate.properties. Использовать аннотацию @Cache и указание настройки стратегии кэширование над entity bean. import org.hibernate.annotations.Cache; import org.hibernate.annotations.CacheConcurrencyStrategy; @Entity @Table(name = "ADDRESS") @Cache(usage=CacheConcurrencyStrategy.READ_ONLY, region="employee") public class Address { }
Какая разница в работе методов load(); и get();?	Hibernate session обладает различными методами для загрузки данных из базы данных. Наиболее часто используемые методы для этого - get() и load(). Метод load(); обычно используется когда в не уверен что запрашиваемый объект уже находится в базе данных. Если объект не найден, то метод кидает исключение Если объект найден — метод возвращает прокси объект, который является ссылкой на объект находящийся в базе данных (запрос в базу данных еще не был осуществлен, своего рода lazy изъятие), непосредственный запрос к базе данных когда мы непосредственно обращаемся к необходимому объекту через прокси объект. Метод get(); используется тогда, вы на 100 процентов не уверены есть ли запрашиваемый объект в базе данных. В случае обращение к несуществующему объекту, метод get(); вернет null. В случае нахождения объект, метод get(); вернет сам объект и запрос в базу данных будет произведен немедленно.
Каковы существуют различные состояния у entity bean?	Transient: состояние, при котором объект никогда не был связан с какой-либо сессией и не является персистентностью. Этот объект находится во временном состоянии. Объект в этом состоянии может стать персистентным при вызове метода save(), persist() или saveOrUpdate(). Объект персистентности может перейти в transient состоянии после вызова метода delete().  Persistent: когда объект связан с уникальной сессией он находится в состоянии persistent (персистентности). Любой экземпляр, возвращаемый методами get() или load() находится в состоянии persistent. Detached: если объект был персистентным, но сейчас не связан с какой-либо сессией, то он находится в отвязанном (detached) состоянии. Такой объект можно сделать персистентным используя методы update(), saveOrUpdate(), lock() или replicate(). Состояния transient или detached так же могут перейти в состояние persistent как новый объект персистентности после вызова метода merge().
Что произойдет, если будет отсутствовать конструктор без аргументов у Entity Bean?	Hibernate использует рефлексию для создания экземпляров Entity бинов при вызове методов get() или load(). Для этого используется метод Class.newInstance(), который требует наличия конструктора без параметров. Поэтому, в случае его отсутствия, вы получите ошибку HibernateException.
Как используется вызов метода Hibernate Session merge()?	Hibernate merge() может быть использован для обновления существующих значений, однако этот метод создает копию из переданного объекта сущности и возвращает его. Возвращаемый объект является частью контекста персистентности и отслеживает любые изменения, а переданный объект не отслеживается.
В чем разница между Hibernate save(), saveOrUpdate() и persist()?	Hibernate save() используется для сохранения сущности в базу данных. Проблема с использованием метода save() заключается в том, что он может быть вызван без транзакции. А следовательно если у нас имеется отображение нескольких объектов, то только первичный объект будет сохранен и мы получим несогласованные данные. Также save() немедленно возвращает сгенерированный идентификатор. Hibernate persist() аналогичен save() с транзакцией. persist() не возвращает сгенерированный идентификатор сразу. Hibernate saveOrUpdate() использует запрос для вставки или обновления, основываясь на предоставленных данных. Если данные уже присутствуют в базе данных, то будет выполнен запрос обновления. Метод saveOrUpdate() можно применять без транзакции, но это может привести к аналогичным проблемам, как и в случае с методом save().
Что такое Lazy fetching(изъятие) в Hibernate?	Тип изьятия Lazy, в Hibernate, связан с листовыми(дочерними) сущностями и определяют политику совместного изъятия, если идет запрос на изъятие сущности родителя. Простой пример: Есть сущность Дом. Он хранит информацию о своем номере, улице, количество квартир и информацию о семьях которые живут в квартирах, эти семьи формируют дочернюю сущность относительно сущности Дом. Когда мы запрашиваем информацию о Доме, нам может быть совершенно ненужным знать информацию семьях которые в нем проживают, тут нам на помощь приходит lazy(ленивое) изъятие(fetching) которая позволяет сконфигурировать сущность Дом, чтобы информацию о семьях подавалась только по востребованию, это значительно облегчает запрос и ускоряет работу приложения.
В чем разница между sorted collection и ordered collection? Какая из них лучше?	При использовании алгоритмов сортировки из Collection API для сортировки коллекции, то он вызывает отсортированный список (sorted list). Для маленьких коллекций это не приводит к излишнему расходу ресурсов, но на больших коллекциях это может привести к потери производительности и ошибкам OutOfMemory. Так же entity бины должны реализовывать интерфейс Comparable или Comparator для работы с сортированными коллекциями. При использовании фреймворка Hibernate для загрузки данных из базы данных мы можем применить Criteria API и команду order by для получения отсортированного списка (ordered list). Ordered list является лучшим выбором к sorted list, т.к. он использует сортировку на уровне базы данных. Она быстрее и не может привести к утечке памяти. Пример запроса к БД для получения ordered list: List<Employee> empList = session.createCriteria(Employee.class) .addOrder(Order.desc("id")).list();
Как реализованы Join'ы Hibernate?	Существует несколько способов реализовать связи в Hibernate. Использовать ассоциации, такие как one-to-one, one-to-many, many-to-many. Использовать в HQL запросе команду JOIN. Существует другая форма «join fetch«, позволяющая загружать данные немедленно (не lazy). Использовать чистый SQL запрос с командой join.
Почему мы не должны делать Entity class как final?	Хибернейт использует прокси классы для ленивой загрузки данных (т.е. по необходимости, а не сразу). Это достигается с помощью расширения entity bean и, следовательно, если бы он был final, то это было бы невозможно. Ленивая загрузка данных во многих случаях повышает производительность, а следовательно важна.
Что вы знаете о HQL и каковы его преимущества?	Hibernate Framework поставляется с мощным объектно-ориентированным языком запросов - Hibernate Query Language (HQL). Он очень похож на SQL, за исключением, что в нем используются объекты вместо имен таблиц, что делает язык ближе к объектно-ориентированному программированию. HQL является регистронезависимым, кроме использования в запросах имен java переменных и классов, где он подчиняется правилам Java. Например, SelECt то же самое, что и select, но com.blogspot.jsehelper.MyClass отличен от com.blogspot.jsehelper.MyCLASS. Запросы HQL кэшируются (это как плюс так и минус).
Что такое Query Cache в Hibernate?	Hibernate реализует область кэша для запросов resultset, который тесно взаимодействует с кэшем второго уровня Hibernate. Кэш запросов используется для кэширования результатов запроса. Когда кэш запроса включен, результаты запроса сохраняются вместе с комбинацией запросов и параметров вызова. Каждый раз запрос вызовет проверку на наличие результата у кэш менеджера. Если результаты найдены в кэше, они возвращаются, иначе инициализируется транзакция в БД. Для подключения этой дополнительной функции требуется несколько дополнительных шагов в коде. Query Cache полезны только для часто выполняющихся запросов с повторяющимися параметрами. Для начала необходимо добавить эту запись в файле конфигурации Hibernate: <property name="hibernate.cache.use_query_cache">true</property> Уже внутри кода приложения для запроса применяется метод setCacheable(true), как показано ниже: Query query = session. createQuery("from Employee"); query. setCacheable(true); query. setCacheRegion("ALL_EMP");
Можем ли мы выполнить SQL (sql native) запрос в Hibernate?	С помощью использования SQLQuery можно выполнять чистый запрос SQL. В общем случае это не рекомендуется, т.к. вы потеряете все преимущества HQL (ассоциации, кэширование). Transaction tx = session.beginTransaction(); SQLQuery query = session.createSQLQuery("select emp_id, emp_name, emp_salary from Employee"); List<Object[]> rows = query.list(); for(Object[] row : rows){ Employee emp = new Employee(); emp.setId(Long.parseLong(row[0].toString())); emp.setName(row[1].toString()); emp.setSalary(Double.parseDouble(row[2].toString())); System.out.println(emp); }
Назовите преимущества поддержки нативного sql в Hibernate.	Использование нативного SQL может быть необходимо при выполнении запросов к некоторым базам данных, которые могут не поддерживаться в Hibernate. Примером может служить некоторые специфичные запросы и «фишки» при работе с БД от Oracle.
Что такое Named SQL Query?	Hibernate поддерживает именованный запрос, который мы можем задать в каком-либо центральном месте и потом использовать его в любом месте в коде. Именованные запросы поддерживают как HQL, так и Native SQL. Создать именованный запрос можно с помощью JPA аннотаций @NamedQuery, @NamedNativeQuery или в конфигурационном файле отображения (mapping files).
Каковы преимущества Named SQL Query?	Именованный запрос Hibernate позволяет собрать множество запросов в одном месте, а затем вызывать их в любом классе. Синтаксис Named Query проверяется при создании session factory, что позволяет заметить ошибку на раннем этапе, а не при запущенном приложении и выполнении запроса. Named Query глобальные, т.е. заданные однажды, могут быть использованы в любом месте. Однако одним из основных недостатков именованного запроса является то, что его очень трудно отлаживать (могут быть сложности с поиском места определения запроса).
Как добавить логирование log4j в Hibernate приложение?	Добавить зависимость log4j в проект. Создать log4j.xml или log4j.properties файл и добавить его в classpath. Для веб приложений используйте ServletContextListener, а для автономных приложений DOMConfigurator или PropertyConfigurator для настройки логирования. Создайте экземпляр org.apache.log4j.Logger и используйте его согласно задачи.
Как логировать созданные Hibernate SQL запросы в лог-файлы?	Для логирования запросов SQL добавьте в файл конфигурации Hibernate строчку: <property name="hibernate.show_sql">true</property>
Что такое Hibernate?	Hibernate — библиотека для языка программирования Java, предназначенная для решения задач объектно-реляционного отображения (object-relational mapping — ORM). Она представляет собой свободное программное обеспечение с открытым исходным кодом (open source), распространяемое на условиях GNU Lesser General Public License. Данная библиотека предоставляет легкий в использовании каркас (фреймворк) для отображения объектно-ориентированной модели данных в традиционные реляционные базы данных. Hibernate совместима с JSR-220/317 и предоставляет стандартные средства JPA. Основные возможности фреймворка: Автоматическая генерация и обновление таблиц в базах данных; Поскольку основные запросы к базе данных (сохранение, обновление, удаление и поиск) представлены как методы фрейморка, то значительно сокращается код, который пишется разработчиком; Обеспечивает использование SQL подобного языка (HQL - hibernate query language). Запросы HQL могут быть записаны рядом объектами данных (POJO классы подготовленные для работы с базой данных).
Что вы знаете о Hibernate прокси и как это помогает в ленивой загрузке (lazy load)?	Hibernate использует прокси объект для поддержки отложенной загрузки. Обычно при загрузке данных из таблицы Hibernate не загружает все отображенные (замаппинные) объекты. Как только вы ссылаетесь на дочерний объект или ищите объект с помощью геттера, если связанная сущность не находиться в кэше сессии, то прокси код перейдет к базе данных для загрузки связанной сущности. Для этого используется javassist, чтобы эффективно и динамически создавать реализации подклассов ваших entity объектов.
Как управлять транзакциями с помощью Hibernate?	Hibernate вообще не допускает большинство операций без использования транзакций. Поэтому после получения экземпляра session от SessionFactory необходимо выполнить beginTransaction() для начала транзакции. Метод вернет ссылку, которую мы можем использовать для подтверждения или отката транзакции. В целом, управление транзакциями в фреймворке выполнено гораздо лучше, чем в JDBC, т.к. мы не должны полагаться на возникновение исключения для отката транзакции. Любое исключение автоматически вызовет rollback.
Что такое каскадные связи (обновления) в Hibernate?	Если у нас имеются зависимости между сущностями (entities), то нам необходимо определить как различные операции будут влиять на другую сущность. Это реализуется с помощью каскадных связей (или обновлений). Вот пример кода с использованием аннотации @Cascade: import org.hibernate.annotations.Cascade @Entity @Table(name = "EMPLOYEE") public class Employee { @OneToOne(mappedBy = "employee") @Cascade(value = org.hibernate.annotations.CascadeType.ALL) private Address address; } Обратите внимание, что есть некоторые различия между enum CascadeType в Hibernate и в JPA. Поэтому обращайте внимание какой пакет вы импортируете при использовании аннотации и константы типа. Наиболее часто используемые CascadeType перечисления описаны ниже. None: без Cascading. Формально это не тип, но если мы не указали каскадной связи, то никакая операция для родителя не будет иметь эффекта для ребенка. ALL: Cascades save, delete, update, evict, lock, replicate, merge, persist. В общем - всё. SAVE_UPDATE: Cascades save и update. Доступно только для hibernate. DELETE: передает в Hibernate native DELETE действие. Только для hibernate. DETATCH, MERGE, PERSIST, REFRESH и REMOVE - для простых операций. LOCK: передает в Hibernate native LOCK действие. REPLICATE: передает в Hibernate native REPLICATE действие.
Какие каскадные типы есть в Hibernate?	Наиболее часто используемые CascadeType перечисления описаны ниже. None: без Cascading. Формально это не тип, но если мы не указали каскадной связи, то никакая операция для родителя не будет иметь эффекта для ребенка. ALL: Cascades save, delete, update, evict, lock, replicate, merge, persist. В общем — всё. SAVE_UPDATE: Cascades save и update. Доступно только для hibernate. DELETE: передает в Hibernate native DELETE действие. Только для hibernate. DETATCH, MERGE, PERSIST, REFRESH и REMOVE - для простых операций. LOCK: передает в Hibernate native LOCK действие. REPLICATE: передает в Hibernate native REPLICATE действие.
Что такое сесиия и фаблика сессий в Hibernate? Как настроить session factory в конфигурационном файле Spring?	Hibernate сессия - это главный интерфейс взаимодействия Java-приложения и Hibernate. SessionFactory позволяет создавать сессии согласно конфигурации hibernate.cfg.xml. Например: // Initialize the Hibernate environment Configuration cfg = new Configuration().configure(); // Create the session factory SessionFactory factory = cfg. buildSessionFactory(); // Obtain the new session object Session session = factory. openSession() При вызове Configuration().configure()  загружается файл hibernate.cfg.xml и происходит настройка среды Hibernate. После того, как конфигурация загружена, вы можете сделать дополнительную модификацию настроек уже на программном уровне. Данные корректировки возможны до создания экземпляра фабрики сессий. Экземпляр SessionFactory как правило создается один раз и используется во всем приложении. Главная задача сессии - обеспечить механизмы создания, чтения и удаления для экземпляров примапленых к БД классов. Экземпляры могут находиться в трёх состояниях: transient - никогда не сохранялись, не ассоциированы ни с одной сессией; persistent - ассоциированы с уникальной сессией; detached - ранее сохраненные, не ассоциированы с сессией. Объект Hibernate Session представляет одну операцию с БД. Сессию открывает фабрика сессий. Сессия должна быть закрыта, когда все операции с БД совершены. Пример: Session session = null; UserInfo user = null; Transaction tx = null; try session = factory. openSession(); tx = session. beginTransaction(); user = (UserInfo) session. load(UserInfo. class, id); tx.commit(); catch(Exception e) if (tx != null) try tx.rollback(); catch (HibernateException e1) throw new DAOException(e1.toString()); throw new DAOException(e.toString()); finally if (session != null) try session. close(); catch (HibernateException e) {
Как использовать JNDI DataSource сервера приложений с Hibernate Framework?	В веб приложении лучше всего использовать контейнер сервлетов для управления пулом соединений. Поэтому лучше определить JNDI ресурс для DataSource и использовать его в веб приложении. Для этого в Hibernate нужно удалить все специфичные для базы данных свойства из и использовать указания свойства JNDI DataSource: <property name="hibernate. connection. datasource">java: comp/env/jdbc/MyLoca1DB</property>
Как интегрировать Hibernate и Spring?	Лучше всего прочитать о настройках на сайтах фреймворков для текущей версии. Оба фреймворка поддерживают интеграцию из коробки и в общем настройка их взаимодействия не составляет труда. Общие шаги выглядят следующим образом. Добавить зависимости для hibernate-entitymanager, hibernate-core и spring-orm. Создать классы модели и передать реализации DAO операции над базой данных. Важно, что DAO классы используют SessionFactory, который внедряется в конфигурации бинов Spring. Настроить конфигурационный файл Spring (смотрите в офф. документации или из примера на этом сайте). Дополнительно появляется возможность использовать аннотацию @Transactional и перестать беспокоиться об управлением транзакцией Hibernate.
Какие паттерны применяются в Hibernate?	Domain Model Pattern - объектная модель предметной области, включающая в себя как поведение так и данные. Data Mapper - слой мапперов (Mappers), который передает данные между объектами и базой данных, сохраняя их независимыми друг от друга и себя. Proxy Pattern - применяется для ленивой загрузки. Factory pattern - используется в SessionFactory
Расскажите о Hibernate Validator Framework.	Проверка данных является неотъемлемой частью любого приложения. Hibernate Validator обеспечивает эталонную реализацию двух спецификаций JSR-303 и JSR-349 применяемых в Java. Для настройки валидации в Hibernate необходимо сделать следующие шаги. Добавить hibernate validation зависимости в проект. Так же требуются зависимости из JSR 341, реализующие Unified Expression Language для обработки динамических выражений и сообщений о нарушении ограничений. Использовать необходимые аннотации в бинах.
Какие преимущества дает использование плагина Hibernate Tools Eclipse?	Плагин Hibernate Tools упрощает настройку маппинга, конфигурационного файла. Упрощает работы с файлами свойств или xml тегами. Помогает минимизировать ошибки написания кода.
Расскажите о преимуществах использования Hibernate Criteria API.	Hibernate Criteria API является более объектно-ориентированным для запросов, которые получают результат из базы данных. Для операций update, delete или других DDL манипуляций использовать Criteria API нельзя. Критерии используются только для выборки из базы данных в более объектно-ориентированном стиле. Вот некоторые области применения Criteria API: Criteria API поддерживает проекцию, которую мы можем использовать для агрегатных функций вроде sum(), min(), max() и т.д. Criteria API может использовать ProjectionList для извлечения данных только из выбранных колонок. Criteria API может быть использована для join запросов с помощью соединения нескольких таблиц, используя методы createAlias(), setFetchMode() и setProjection(). Criteria API поддерживает выборку результатов согласно условиям (ограничениям). Для этого используется метод add() с помощью которого добавляются ограничения (Restrictions). Criteria API позволяет добавлять порядок (сортировку) к результату с помощью метода addOrder().
Что вы знаете о классе HibernateTemplate?	Spring Framework предоставляет различные подходы для интеграции с Hibernate. Тем не менее, мы наиболее часто будем использовать подход, использующий HibernateTemplate. Есть две основные причины: Класс скрывает детали управления сессиями и транзакциями. Предоставляет подход основанный на шаблонах HibernateTemplate класс скрывает трудности управления сессиями и транзакциями при использовании Hibernate для доступа к данным. Нужно только инициализировать HibernateTemplate путем передачи экземпляра SessionFactory. Spring Framework берет на себя беспокойство за детали связанные с сессиями и транзакциями. Это помогает устранить инфраструктурный код, который может вносить суматоху при увеличении сложности. HibernateTemplate, так же как и JdbcTemplate, предоставляет шаблонный подход для доступа к данным. Когда вы используете HibernateTemplate, вы будете работать с callbacks. Обратные вызовы - это единственный механизм в шаблонном подходе, который уведомляет шаблон запускать нужную задачу. Преимущество наличия обратного вызова в том, что там только одна точка входа в слой доступа к данным. И эта точка входа определяется шаблоном, в этом случае HibernateTemplate. В комментариях дополнили, что использование HibernateTemplate не явлется рекомендуемым. Вместо использования HibernateTemplate из пакета org.springframework.orm рекомендуется использовать декларативный подход (@Transactional). Таким образом фреймворк сам позаботится об операциях open, commit, close, flush.
Как интегрировать Hibernate с Servlet или Struts2 веб приложением?	Для интеграции необходимо использовать ServletContextListener.
Best Practices в Hibernate	При использовании фреймворка Hibernate рекомендуется придерживаться некоторых правил. Всегда проверяйте доступ к primary key. Если он создается базой данных, то вы не должны иметь сеттера. По умолчанию hibernate устанавливает значения в поля напрямую без использования сеттеров. Если необходимо заставить хибернейт их применять, то проверьте использование аннотации @Access(value=AccessType.PROPERTY) над свойством. Если тип доступа - property, то удостоверьтесь, что аннотация используется с геттером.  Избегайте смешивания использования аннотации над обоими полями и геттером. Используйте нативный sql запрос только там, где нельзя использовать HQL. Используйте ordered list вместо сортированного списка из Collection API, если вам необходимо получить отсортированные данные. Применяйте именованные запросы разумно - держите их в одном месте и используйте только для часто применяющихся запросов. Для специфичных запросов пишите их внутри конкретного бина. В веб приложениях используйте JNDI DataSource вместо файла конфигурации для соединения с БД. Избегайте отношений многие-ко-многим, т.к. это можно заменить двунаправленной One-to-Many и Many-to-One связью. Для collections попробуйте использовать Lists, maps и sets. Избегайте массивов (array), т.к. они не дают преимуществ ленивой загрузки. Не обрабатывайте исключения, которые могут откатить транзакцию и закрыть сессию. Если это проигнорировать, то Hibernate не сможет гарантировать, что состояние в памяти соответствует состоянию персистентности (могут быть коллизии данных). Применяйте шаблон DAO для методов, которые могут использоваться в entity бинах. Предпочитайте ленивую выборку для ассоциаций.
Что такое Hibernate? В чём разница между JPA и Hibernate?	Я думаю, чтобы ответить на данный вопрос, нам сперва нужно понять, что такое JPA. JPA — это спецификация, описывающая объектно-реляционное отображение простых Java объектов и предоставляющая API для сохранения, получения и управления такими объектами. То есть, как мы помним, реляционные базы данных (БД) представлены в виде множества связанных между собой таблиц. И JPA — общепринятый стандарт, который описывает, как объекты могут взаимодействовать с реляционными базами данных. Как видие, JPA — это что-то абстрактное и неосязаемое. Это как бы сама идея, подход.В то же время Hibernate — это конкретная библиотека, реализующая парадигмы JPA. То, есть с помощью этой библиотеки вы можете работать с реляционной базой данных через объекты, которые представляют данные с БД (Entity). Как говорят, данная библиотека очень близка к идеалам JPA и возможно, поэтому она стала популярна. А как вы понимаете, популярность использования — хороший аргумент для дальнешйей разработки и улучшений. К тому же за частым использованием стоит огромное комьюнити, которое разобрало уже все возможные и невозможные вопросы, связанные с данным инструментом.
Что такое каскадность? Как она используется в Hibernate?	Как я и сказал ранее, в Hibernate взаимодействие ведется через объекты данных, называемые entity. Эти entity представляют какие-то конкретные таблицы в базе данных, и как вы помните, в Java классы могут содержать ссылки на другие классы. Эти отношения отражаются и на базе данных. В БД, как правило, это либо внешние ключи (для OneToOne, OneToMany, ManyToOne), либо промежуточные таблицы (для ManyToMany) Подробнее о взаимосвязи между сущностями можно почитать в этой статье. Когда в вашем entity есть ссылки на другие связанные сущности, над этими ссылками ставятся аннотации для указания типа связи: @OneToOne, @OneToMany, @ManyToOne, @ManyToMane, в чьих параметрах вы можете указать значение свойства — cascade — тип каскаданости для данной связи. У JPA есть специфические методы для взаимодействия с сущностями (persist, save, merge...). Каскадные типы как раз используются для того, чтобы показать, как должны себя вести связанные данные при использовании этих методов на целевую сущность. Итак, какие же существуют стратегии каскаскадности (типы каскадности)? Стандарт JPA подразумевает использование шести видов каскадности: PERSIST — операции сохранения будут происходить каскадно (для методов save() и persist()). То есть, если мы сохраняем сущность, связанную с другими сущностями, они также сохраняются в БД (если их ещё там нет) MERGE — операции обновления будут происходить каскадно (для метода merge()) REMOVE — операции удаления происходят каскадно (метод remove()) ALL — содержит сразу три каскадные операции — PERSIST - MERGE - REMOVE В JPA есть понятие персистентная (persistence) сущность — сущность, связанная с её данными в БД, которая управляется текущей сессией (соединением). Если её изменить, но при этом не сохранить изменения в БД, всё равно её данные в БД будут изменены. DETACH — связанные сущности не будут управляться сессией (метод detach()). То есть, при их изменении не будет автоматического изменения их данных в БД — они переводятся из состояния persistence в detached (сущность, не управляемая JPA) REFRESH — при каждом обновлении сущности данными из БД (refresh() — обновляет detached объекты) связанные сущности обновляются так же. Например, вы изменили как-то данные, взятые из БД, и хотите вернуть их изначальные значения. В таком случае вам и пригодится данная операция. Hibernate поддерживает все эти стандартные каскадные операции, но также привносит три свои: REPLICATE — используется, когда у нас есть более одного источника данных и мы хотим, чтобы данные синхронизировались (метод Hibernate — replicate). У всех сущностей должны быть идентификаторы (id), чтобы не было проблем с их генерацией (чтобы для разных БД одна и та же сущность не имела разных id) SAVE_UPDATE — каскадное сохранение/удаление (для метода Hibernate — saveOrUpdate) LOCK — операция, обратная к DETACHED: переводит detached сущность обратно в состояние persistence, т.е. entity станет снова отслеживаемой текущей сессией Если не выбран тип каскадирования, никакая операция с сущностью не будет иметь эффекта для связанных с ней других entity.
N+1 SELECT problem и пути ее решения?	Проблема n + 1 может возникнуть в случае, когда одна сущность (таблица) ссылается на другую сущность (таблицу). В такой ситуации получается, что для получения значения зависимой сущности выполняется n избыточных запросов, в то время как достаточно одного. Никого не нужно убеждать, что это негативно влияет на производительность системы и создает ненужную нагрузку на базу данных. Особенно то, что количество запросов увеличивается с ростом n. Сама проблема часто представляется как возникающая только в отношениях "один ко многим" (javax.persistence.OneToMany) или только в случае ленивой загрузки данных (javax.persistence.FetchType.LAZY). Это не так, и следует помнить, что эта проблема также может возникнуть в отношениях один-к-одному и при "жадной" загрузке зависимых сущностей. Решение 1)Устранение проблемы с помощью Join Fetch 2)Добавив аннотацию @BatchSize над полем , Hibernate получит данные в рамках одного запроса. (Всего их будет два)
@Transactional	Аннотация @Transactional указывает, что метод должен выполняться в транзакции. Менеджер транзакций открывает новую транзакцию и создаёт для неё экземпляр Session, который доступен через sessionFactory.getCurrentSession(). Все методы, которые вызываются в методе с данной аннотацией, также имеют доступ к этой транзакции, потому что экземпляр Session является переменной потока (ThreadLocal). Вызов sessionFactory.openSession() откроет совсем другую сессию, которая не связана с транзакцией.
Параметр rollbackFor у @Transactional	Параметр rollbackFor указывает исключения, при выбросе которых должен быть произведён откат транзакции. Есть обратный параметр — noRollbackFor, указывающий, что все исключения, кроме перечисленных, приводят к откату транзакции.
Параметр propagation у @Transactional	Параметр propagation он указывает принцип распространения транзакции. Может принимать любое значение из перечисления Propagation.REQUIRED — выполняться в существующей транзакции, если она есть, иначе создавать новую. Propagation.MANDATORY — выполняться в существующей транзакции, если она есть, иначе генерировать исключение. Propagation.SUPPORTS — выполняться в существующей транзакции, если она есть, иначе выполняться вне транзакции. Propagation.NOT_SUPPORTED — всегда выполняться вне транзакции. Если есть существующая, то она будет остановлена. Propagation.REQUIRES_NEW — всегда выполняться в новой независимой транзакции. Если есть существующая, то она будет остановлена до окончания выполнения новой транзакции. Propagation.NESTED — если есть текущая транзакция, выполняться в новой, так называемой, вложенной транзакции. Если вложенная транзакция будет отменена, то это не повлияет на внешнюю транзакцию; если будет отменена внешняя транзакция, то будет отменена и вложенная. Если текущей транзакции нет, то просто создаётся новая. Propagation.NEVER — всегда выполнять вне транзакции, при наличии существующей генерировать исключение.
Что такое Анти-паттерн сессия-на-операцию	Это анти-паттерн про открытие и закрытие объекта Session на каждую операцию к БД в одном потоке. Это также анти-паттерн в терминах транзакций БД. Группируйте ваши вызовы в одну запланированную последовательность. Также, не делайте авто-коммит транзакции на каждое SQL-выражение. Hibernate выключает, или ожидает, что сервер приложений немедленно выключит режим авто-коммита. Транзакции к БД никогда не являлись чем-то необязательным. Все коммуникации с БД должны быть обернуты в транзакцию. Избегайте авто-коммита при чтении данных, потому как довольно редко множество небольших транзакций будут работать быстрее, чем одна должным образом определенная транзакция. К тому же, такое множество транзакций трудно поддерживать и расширять. Использование автокоммита не обязательно приводит к использованию БД-транзакций на каждое выражение. Вместо этого, в режиме автокоммита, драйверы JDBC просто проводят каждый вызов в рамках неявного вызова транзакции. Это тоже самое, как если бы ваше приложение проводило вызов commit() транзакции после каждого вызова JDBC.
Что такое Паттерн сессия-на-запрос	Наиболее распространенный паттерн транзакций. Термин "запрос" здесь следует понимать в контексте системы, реагирующей на серии запросов от пользователя/клиента. Веб-приложения является основным примером таких систем, но, конечно, не только они одни. На этапе начала обработки запроса, приложение открывает объект Session, инициирует транзакцию, проводит всю сопутствующую работу с данными, завершает транзакцию и закрывает Session. Суть паттерна - это отношение один-к-одному между транзакцией и сессией.В рамках паттерна есть распространенная техника определения текущей сессии для упрощения передачи этой Session между компонентами приложения. Hibernate предоставляет поддержку данной техники через метод getCurrentSession() класса SessionFactory. Концепция «текущей» сессии должна иметь область видимости, которая определяет границы, в которых определение "текущая" верно. Это задача контракта org.hibernate.context.spi.CurrentSessionContext.  Есть две надежно определенных области видимости: JTA транзакция, которая через callback может дать знать Hibernate, когда она завершилась, что в свою очередь предоставляет возможность завершить текущую сессию. Данная стратегия представлена org.hibernate.context.internal.JTASessionContext - реализацией контракта org.hibernate.context.spi.CurrentSessionContext. С использованием этой реализации, Session будет открыт, как только вызовется getCurrentSession() в пределах транзакции. Цикл запроса сам по себе. Лучше всего представлено org.hibernate.context.internal.ManagedSessionContext — реализацией контракта org.hibernate.context.spi.CurrentSessionContext. Здесь есть внешний компонент, ответственный за управлением жизненным циклом и областью видимости "текущей" сессии. На этапе старта области видимости, метод bind() вызывается у ManagedSessionContext с передачей ссылки на сессию. В конце, вызывается метод unbind().
Что такое Блокировка?	Блокировки - это меры по предотвращению модификации данных в реляционной базе данных между временем их чтения, и временем их использования.Стратегия блокировок может быть либо оптимистичной, либо пессимистичной.
Какие бывают Стратегии блокировок?	Оптимистичная Оптимистичные блокировки предполагают, что множество транзакций могут завершиться без влияния друг на друга, и таким образом могут выполнятся без блокировок тех ресурсов, на которые они влияют. Перед коммитом, каждая транзакция проверяет, что ни одна другая транзакция не модифицировала ее данные. Если проверка выявила конфликтующие модификации, транзакция, находящаяся в состоянии коммита, откатывается. В hibernate при коммите в базу данных производится сравнивание значения поля, помеченного как version, на момент получения данных и на данный момент. Если оно изменилось, то есть какая-то другая транзакция опередила нашу и успела изменить данные, то в таком случае наша транзакция выбрасывает ошибку, и необходимо заново запускать ее. При использовании оптимистичных блокировок обеспечивается более высокий уровень конкурентности при доступе к базе, но в таком случае приходится повторять транзакции, которые не успели внести изменения раньше других. Пессимистичная Пессимистичная стратегия подразумевает, что параллельные транзакции будут конфликтовать каждая друг с другом, и требует блокировки ресурсов после их чтения, а также ее снятия только после того, как приложение завершило использование данных.  В пессимистичных блокировках накладывается сразу же перед предполагаемой модификацией данных на все строки, которые такая модификация предположительно затрагивает А при использовании пессимистичных блокировок гарантируется отсутствие противоречий при выполнении транзакции, за счет помещение остальных в режим ожидания(но на это тратится время), как следствие понижение уровня конкурентности. Hibernate предоставляет механизмы для реализации обеих стратегий блокировок в вашем приложении.
Оптимистичные блокировки описать?	Вы можете хранить версионированные данные, когда ваше приложение использует долгоживущие транзакции или диалоги, покрывающие несколько БД-транзакций. Таким образом, если одна и та же сущность будет модифицироваться двумя диалогами, последний диалог, коммитивший изменения, будет оповещен о конфликте, и не перезапишет результаты другого диалога. Этот подход гарантирует некоторую степень изоляции, но при этом хорошо масштабируется, и довольно неплохо себя показывает в ситуациях Read-Often Write-Sometimes Hibernate предоставляет два различных механизма для хранения версионной информации - выделенный номер версии, или временную метку (timestamp).
Выделенный номер версии для Оптимистичной блокировки	Механизм номера версии для оптимистичных блокировок предоставляется аннотацией Version Version решает проблему с потерянными обновлениями. @Entity  public class Flight implements Serializable { ...  @Version  @Column(name="OPTLOCK")  public Integer getVersion() { ... }  } Здесь свойство версии маппится на колонку OPTLOCK, а менеджер сущностей (entity manager) использует ее для выявления конфликтующих обновлений, и предотвращения потери обновлений, которые были бы перезаписаны стратегией last-commit-wins Колонка версии может быть любого типа, при условии, что вы определите и реализуете подходящий UserVersionType. Вашему приложению запрещено изменять номер версии, проставленный Hibernate. Чтобы искусственно увеличить номер версии, см. описание свойств LockModeType.OPTIMISTIC_FORCE_INCREMENT или LockModeType.PESSIMISTIC_FORCE_INCREMENT в документации по Hibernate Entity Manager. Если номер версии сгенерирован базой данных, например триггером, используйте аннотацию org.hibernate.annotations.Generated(GenerationTime.ALWAYS). LockModeType.OPTIMISTIC Это оптимистическая блокировка, ну это и так логично. Как я писал выше, происходит сравнения значение поля version, если оно отличается, то бросается ошибка. LockModeType.OPTIMISTIC_FORCE_INCREMENT Работает по тому же алгоритму, что и LockModeType.OPTIMISTIC за тем исключением, что после commit значение поле Version принудительно увеличивается на 1. В итоге окончательно после каждого коммита поле увеличится на 2(увеличение, которое можно увидеть в Post-Update + принудительное увеличение). Вопрос. Зачем? Если после коммита мы хотим еще «поколдовать» над этими же данными, и нам не нужны сторонние транзакции, которые могут ворваться между первым коммитом и закрытием нашей транзакции. LockModeType.PESSIMISTIC_READ — пессимистичная блокировка на чтение. LockModeType.PESSIMISTIC_WRITE — пессимистичная блокировка на запись (и чтение). LockModeType.PESSIMISTIC_FORCE_INCREMENT — пессимистичная блокировка на запись (и чтение) с принудительным увеличением поля Version.
Timestamp для Оптимистичной блокировки	Временные метки (timestamps) — менее надежный способ оптимистичных блокировок чем номера версий, который также может быть использован приложениями для других целей. Временные метки используются автоматически, если вы используете аннотацию Version на свойстве типа Date или Calendar. @Entity  public class Flight implements Serializable { ...  @Version  public Date getLastUpdate() { ... }  } Hibernate может извлечь значение временной метки из базы данных или JVM, прочитав значение аннотации org.hibernate.annotations.Source. Значение может быть либо org.hibernate.annotations.SourceType.DB, либо org.hibernate.annotations.SourceType.VM. Поведение по-умолчанию - это использование БД, также используемое, если вы не укажете аннотацию.Временная метка также может быть сгенерирована базой данных вместо Hibernate, если вы используете аннотацию org.hibernate.annotations.Generated(GenerationTime.ALWAYS).
Пессимистичные блокировки	Класс LockMode определяет различные уровни блокировок, которые может захватывать Hibernate. LockMode.WRITE Захватывается автоматически, когда Hibernate обновляет или вставляет строку. LockMode.UPGRADE Захватывается после явного запроса пользователя с использованием SELECT... FOR UPDATE на БД, поддерживающих данный синтаксис. LockMode.UPGRADE_NOWAIT Захватывается после явного запроса пользователя с использованием SELECT... FOR UPDATE NOWAIT в Oracle LockMode.READ Захватывается автоматически когда Hibernate читает данные под уровнями изоляции Repeatable Read или Serializable. Может быть повторно захвачен явным запросом пользователя. LockMode.NONE Отсутствие блокировки. Все объекты переключаются на этот режим блокировки в конце транзакции. Объекты, ассоциированные с сессиейчерез вызов update() или saveOrUpdate также начинают в этом режиме . Явный запрос пользователя, обозначенный выше, происходит как следствие любых из следующих действий: Вызов Session.load(), с указанием LockMode Вызов Session.lock() Вызов Query.setLockMode() Если вы вызовете Session.load() с опцией UPGRADE или UPGRADE_NOWAIT, и запрошенный объект еще не подгрузился сессией, объект подгружается с помощью SELECT... FOR UPDATE. Если вы вызовете load() для объекта, которые уже подгружен с менее строгой блокировкой, чем с той, что вы запросили, Hibernate вызовет lock() для этого объекта.Session.lock() осуществляет проверку номера версии в режимах READ, UPGRADE, или UPGRADE_NOWAIT. В случаях UPGRADE или UPGRADE_NOWAIT, будет использован синтаксис SELECT... FOR UPDATE.Если запрошенный режим блокировки не поддерживается базой данных, Hibernate будет использовать подходящий альтернативный режим вместо выбрасывания исключения. Это гарантирует переносимость приложений.